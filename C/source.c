/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_13C();
void sub_144();
void __fastcall __noreturn sub_15A(int a1, int a2);
_BYTE *__fastcall sub_168(_BYTE *result, _BYTE *a2, unsigned int a3);
int sub_1B4();
__int64 get0x2000146020001060();
void __fastcall __noreturn sub_1EE(int a1, int a2);
void __fastcall __noreturn sub_1F4(int a1, int a2);
void nullsub_1();
_BYTE *__fastcall sub_280(_BYTE *result, int a2, unsigned int a3);
void *Get20001000();
void __noreturn sub_348();
_BYTE *sub_354();
int *sub_36C();
int *sub_3A0();
int *sub_3C0();
int sub_3E0();
signed int __fastcall sub_410(int a1, unsigned int a2, int a3);
unsigned int __fastcall sub_6B4(_BYTE *a1, signed int a2);
int sub_738();
int sub_800();
int sub_978();
int __fastcall sub_193C(int a1, int format, int *a3); // idb
void sub_1960();
void emptySub();
_BYTE *__fastcall strcpy(_BYTE *target, _BYTE *source, unsigned int len); // idb
int entryPoint();
void *get1FFFFE40();
// int __usercall sprintf@<R0>(int a1@<R0>, const char *a2@<R1>, int a3@<R3>, ...);
int __fastcall sub_1A20(int a1);
int __fastcall sub_1A4C(int a1);
int __fastcall sub_1A6E(int a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_1AC0(_DWORD *a1, int a2, int *a3);
int __fastcall sub_1B2C(int a1, _DWORD *a2);
_BYTE *__fastcall sub_1C64(_BYTE *result, int a2);
char *__fastcall strLength(_DWORD *a1);
_BYTE *__fastcall memcpy(_BYTE *result, int a2, unsigned int a3);
_BYTE *__fastcall sub_1D76(_BYTE *a1, _BYTE *a2, unsigned int a3);
_WORD *__fastcall setupDMA(_WORD *targetAddress, unsigned int numbButesToSend, unsigned __int8 a3); // idb
void callSetupDMA();
void __fastcall div_Other(unsigned int a1, unsigned int a2);
int __fastcall div_(unsigned int a1, unsigned int a2);
signed int __fastcall sub_204C(int a1, int a2, int a3, int a4);
int __fastcall sub_20FC(int a1);
int __fastcall someSprintfMethod(int a1, int a2, _DWORD *a3, int a4);
int __fastcall sub_212C(int result, _BYTE **a2);
signed int __fastcall sub_2136(int a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_215C(int a1, int a2, int *a3);
unsigned int __fastcall divBy10(unsigned int value); // idb
int sub_218C(void); // weak
_DWORD *sub_21D8();
void __noreturn sub_21E0();
int adc_setup();
char *calibrateADC();
int sub_232C();
int __fastcall adcMethod2(int a1);
int __fastcall sub_237C(int a1, int a2);
signed int sub_23F4();
_BYTE *__fastcall sub_24D0(char a1);
int getKeyCode();
int getInputStates();
signed int sub_2574();
signed int rxBindingShow();
signed int __fastcall sub_25A4(char a1);
int callSetupDMAandSend();
int LCD_updateCALL();
void nullsub_2();
int __cdecl main(int argc, const char **argv, const char **envp);
unsigned int configurePINS();
signed int SwashAFRPage();
void __fastcall ChooseSensors(int a1, int a2, int a3, int a4, int a5);
signed int DualRateExp();
int DisplayChannels();
int FirmwareVerPAge();
int SensorsList();
signed int ElevonPage();
signed int endpointsPage();
int __fastcall i2cMethod(_BYTE *a1, int a2, int a3, char a4, int a5);
signed int kindOfInit2();
signed int __fastcall flashMethod(int a1, int a2, int a3);
signed int __fastcall readEeprom(int target, __int16 offset, int len); // idb
signed int __fastcall saveEepromData(_BYTE *a1, int a2, unsigned int a3);
signed int FactoryReset();
signed int FailsafeMEnu();
int FailsafeReset();
int __fastcall failsafeOnOff(int a1);
signed int __fastcall FirmwareUpdatePage(int a1, int a2, int a3, int a4);
signed int FactResConfirm();
signed int __fastcall showSingleValuePage(_BYTE *namePtr, int a2, int a3); // idb
unsigned int __fastcall displayGFX(int a1, int a2, signed int a3);
signed int __fastcall fillRegion(int a1, signed int a2, int a3, signed int a4, int a5);
signed int __fastcall sub_4E8C(int a1, signed int a2, int a3, signed int a4, int a5);
int __fastcall getGFX(int a1, signed int a2, int a3);
int __fastcall drawLine(int a1, int a2, int a3, int a4, int a5);
int __fastcall displayTextAt(_BYTE *text, int x, signed int y, int a4); // idb
int __fastcall displayTextAt2(_BYTE *text, int a2, signed int a3, int a4); // idb
int __fastcall displaySmallTextAt(_BYTE *a1, int a2, signed int a3);
int __fastcall displayTextFromRight(_DWORD *a1, int a2, signed int a3, int a4);
const char *__fastcall getSensorNameObsolet(signed int a1);
signed int __fastcall sensorsFunction(int sensorID, int index, _DWORD *a3); // idb
int __fastcall formatSensorData(int a1, int a2, _BYTE *a3);
signed int GyroscopePAge();
int i2cInterrupt();
void __fastcall setSensorValue(char *a1);
signed int keyTestPage();
signed int LCDBrightM();
signed int sub_5C3C();
void __fastcall controlBackLight(int a1);
signed int setupDMAandSend();
signed int LCD_clear();
int __fastcall setLCDBrightnes(unsigned int a1);
signed int LCD_update();
int __fastcall send_to_lcd(unsigned int a1, int a2);
int settingsValidation();
char *afhd2Init();
void sub_618C();
unsigned int sub_61EC();
int sensorsFunction4();
unsigned int __fastcall rxpacketHandle(_BYTE *a1);
int sensorsListMainScreen();
int sub_68A8();
int __fastcall factoryModeMenu(_DWORD *a1, unsigned int a2, char **a3);
int __fastcall displayPageHeader(_BYTE *a1);
signed int __fastcall showNavigationPage(_BYTE *namePtr, unsigned int numberOfItems, char **pageName); // idb
signed int sub_6FE0();
signed int modelCopyPage();
signed int modelNamePAge();
signed int modelResetPage();
signed int modelSelectPage();
int sub_7A38();
__int16 *tpmMethod();
signed int sub_7B14();
void startupWarning();
int sub_7CAC();
char *sub_7E9C();
char *callSendPacket();
signed int sendSettingsPacket();
signed int sub_8028();
signed int sub_8038();
char *configurePINandTimers();
unsigned int __fastcall callRxpacketHandle(_BYTE *a1);
int sub_810C();
signed int __fastcall addPacketToResend1FFFFCF5When2000013C(signed int result);
char *__fastcall sendPacketToRadio(_BYTE *targetAddress, char *a2, int a3); // idb
int __fastcall setC7_unsetC4(int result);
int __fastcall setPortE1_unsetE0(int result);
int __fastcall sub_8540(int result);
char *trySendSettingsPacket();
char *sendPAcket();
int __fastcall sub_8AD4(int a1, int a2, int a3, int a4);
int methodOnTPM_Event();
char *rxBindingPage();
int RxSetupPage();
signed int RFStandardPage();
signed int ServosFreqMenu();
int ibussetupmenu();
void PPMOutMenu();
int setFactVal();
signed int ResetOdo1Menu();
signed int ResetOdo2Menu();
signed int ReverseMenu();
signed int __fastcall RotationLenMenu(int a1, int a2, int a3, int a4);
int sub_9BC0();
unsigned int buzzerSetup();
int __fastcall beep(int result, __int16 a2);
int *TMP1_method_beep_modulation();
signed int setupPortsC4_c5_c6_spi_DMA2_DMA3();
signed int __fastcall sendOverSPI_useDMA(char a1, _BYTE *destination, unsigned int length); // idb
signed int __fastcall spiSend(_BYTE *a1, unsigned int a2);
signed int sendPacketWithTimer();
unsigned int __fastcall dualRateExpFunction(unsigned int a1, int a2);
unsigned int __fastcall crcCheck(_BYTE *startPTR, signed int length); // idb
int __fastcall strageSPILoop(int a1);
signed int __fastcall timerSendPacket(int a1);
char *sub_A158();
int __fastcall div__0(int a1, signed int a2);
char *sub_A190();
int getCurrentTicks();
unsigned int kindOfInit();
int __fastcall intToString(signed int sourceVal, char *targetText, unsigned int length); // idb
int __fastcall printNumberAsStringAt(signed int a1, char *a2, unsigned int a3);
char *sub_A320();
signed int someSPImethod();
int *createRadioPacket();
int __fastcall toSysTick(int a1);
int saveModelSettings();
int SpeedDistancePage();
signed int SpeedSensor();
signed int SticksAdjustPage();
signed int SticksMode();
signed int StudentModePage();
signed int SubtrimPage();
signed int SwitchesAssigPage();
int TPM0_method();
int ThrottleCurvePage();
signed int ThrottleHoldPage();
signed int TrainerModePage();
signed int typeSelectPage();
signed int vTailPage();
int __fastcall copy6Bytes(int result, int a2);
bool __fastcall isASCICodeSingleDigit(int a1);
void __noreturn main_screen();
int __fastcall RemapSensorIndex(signed int a1, int a2);
signed int __fastcall auxChannelsPage(int a1, int a2, int a3, int a4);
void __fastcall createPacketsForCH7_10(unsigned int switch_1);
int *__fastcall channelDataHelper(int a1);
void loadTimerSettingsFromEeprom();
void printTimer();
bool isTimerActive();
int timerConfiguration();
void __fastcall GetSensorName(signed int a1);
int __fastcall formatSensorValue(int a1, signed int a2, signed int a3);

//-------------------------------------------------------------------------
// Data declarations

_BYTE byte_1[3] = { 20, 0, 32 }; // idb
int Reset = 417; // weak
int NMI = 425; // weak
int HardFault = 427; // weak
int dword_14 = 0; // weak
int *off_1D4 = &dword_1800; // weak
void **off_1D8 = &off_1804; // weak
__int64 qword_1DC = 2305865412299984992LL; // weak
void *off_344 = &unk_20001000; // weak
void *off_364 = (void *)0x38D; // weak
int *off_368[3] = { &dword_20000044, (int *)0x4905B510, (int *)0x70082070 }; // weak
int dword_384 = 1073872896; // weak
int (*off_388)(void) = (int (*)(void))0x20000045; // weak
int *off_3B8 = &dword_20000030; // weak
int dword_3BC = 3758153984; // weak
int *off_3D8 = &dword_20000030; // weak
int dword_3DC = 3758153984; // weak
int dword_3EC = 1074036992; // weak
_UNKNOWN unk_401; // weak
int dword_4B8 = 1073872896; // weak
void *off_4BC = (void *)0x20000045; // weak
_UNKNOWN loc_4C0; // weak
_UNKNOWN unk_5DC; // weak
int dword_72C = 65535; // weak
int dword_730 = 2147483647; // weak
void *off_734 = &unk_B80; // weak
int dword_7E0 = 1074036992; // weak
int *off_7E4 = &dword_20000030; // weak
int dword_7E8 = 16777215; // weak
int dword_7EC = 3758153728; // weak
int dword_7F0 = 1074151424; // weak
int dword_7F4 = 1074036800; // weak
int dword_7F8 = 1074155520; // weak
int dword_7FC = 1074036736; // weak
int dword_960 = 1073774848; // weak
int *off_964 = &dword_20000038; // weak
int dword_968 = 65535; // weak
void *off_96C = (void *)0x20000800; // weak
int dword_970 = 1074184192; // weak
int dword_974 = 1073807360; // weak
void *off_9D8 = (void *)0x20000800; // weak
int *off_9DC = &dword_20000038; // weak
int dword_9E0 = 1074036736; // weak
int dword_9E4 = 1074057280; // weak
int dword_9E8 = 1074184192; // weak
int dword_9EC = 1073876992; // weak
int dword_9F0 = 1074184199; // weak
int dword_9F4 = 1073774848; // weak
int dword_9F8 = 542244992; // weak
int dword_9FC = 65535; // weak
int dword_A00 = 1612318720; // weak
int dword_B74 = 2136315052; // weak
char byte_BB8 = '½'; // weak
char byte_DA0[1632] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
int TX_ID = 2000062800; // weak
char RANDOM_BYTES[32] =
{
  'c',
  'V',
  'y',
  '$',
  'C',
  'Ž',
  '6',
  '\\',
  '?',
  '\x15',
  'k',
  'p',
  '\x0E',
  '~',
  '\x1B',
  'L',
  'c',
  'V',
  'y',
  '$',
  'C',
  'Ž',
  '6',
  '\\',
  '?',
  '\x15',
  'k',
  'p',
  '\x0E',
  '~',
  '\x1B',
  'L'
}; // weak
__int16 UNKNOWN_ID = 1; // weak
char byte_1426[986] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
int dword_1800 = 536876608; // weak
_UNKNOWN unk_1920; // weak
_UNKNOWN unk_1B1C; // weak
void *off_1B20 = &unk_2D; // weak
_UNKNOWN unk_1B24; // weak
_UNKNOWN unk_1B28; // weak
_UNKNOWN loc_1E38; // weak
_UNKNOWN loc_1EA0; // weak
_UNKNOWN loc_1EBC; // weak
_UNKNOWN loc_1EEC; // weak
_UNKNOWN loc_1F1E; // weak
_UNKNOWN loc_1F4E; // weak
void *off_2328 = &adcFlag; // weak
int dword_2710[28] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_2F5E; // weak
_UNKNOWN unk_2F94; // weak
_UNKNOWN unk_3AD8; // weak
_UNKNOWN unk_3AE0; // weak
_UNKNOWN unk_43BC; // weak
__int16 word_47BE = 62399; // weak
_UNKNOWN unk_5392; // weak
_UNKNOWN unk_65D6; // weak
_UNKNOWN unk_6614; // weak
_UNKNOWN unk_6792; // weak
_UNKNOWN unk_7774; // weak
int dword_7778 = 4078909; // weak
_UNKNOWN loc_7FFE; // weak
_UNKNOWN loc_8000; // weak
_UNKNOWN unk_B698; // weak
_UNKNOWN unk_BE78; // weak
_UNKNOWN unk_BE80; // weak
_UNKNOWN unk_C1FA; // weak
_UNKNOWN unk_C954; // weak
int afhd_logo[2] = { 56, 36 }; // weak
char heli_img = '4'; // weak
char plain_img = '4'; // weak
_UNKNOWN unk_CBA4; // weak
int dword_CBBC = 46; // weak
int *off_CBC8[2] = { &IRQ0, &HardFault }; // weak
_UNKNOWN unk_CBD4; // weak
_UNKNOWN unk_CBE0; // weak
_UNKNOWN unk_CBEC; // weak
_UNKNOWN arrow_gfx; // weak
_UNKNOWN unk_CC04; // weak
_UNKNOWN unk_CC10; // weak
_UNKNOWN unk_CC1C; // weak
_UNKNOWN unk_CC28; // weak
_UNKNOWN unk_CC34; // weak
int *off_CC40[2] = { &dword_4C, &HardFault }; // weak
_UNKNOWN unk_D198; // weak
int dword_D20C[15] =
{
  4278714368,
  15,
  1048328,
  4278714368,
  15,
  1048328,
  4278714368,
  15,
  17825544,
  1588264,
  16908288,
  33619971,
  16909059,
  33620736,
  0
}; // weak
char *off_D248 = "Sticks adjust"; // weak
char byte_D2A0 = '='; // weak
_UNKNOWN unk_D2C0; // weak
_UNKNOWN unk_D308; // weak
_UNKNOWN unk_D368; // weak
_UNKNOWN unk_D3C0; // weak
_UNKNOWN unk_D420; // weak
_UNKNOWN unk_D488; // weak
int dword_D554[41] =
{
  4160749568,
  1879048191,
  4294967295,
  3890735103,
  1608507343,
  1431655773,
  1431655765,
  1431655765,
  357913941,
  524169477,
  809377555,
  155139840,
  1061093377,
  1061094404,
  557793024,
  637541951,
  423439663,
  959512576,
  2502441,
  320814640,
  1882209823,
  528449407,
  1008467975,
  1903786301,
  2139061107,
  1431658335,
  1431655765,
  1431655765,
  17110357,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_DD3C[63] =
{
  2174071217,
  3959389822,
  4293644239,
  1058999934,
  236928894,
  1042024448,
  136068735,
  2671392768,
  943366143,
  3191609344,
  406634239,
  402653184,
  1588284,
  3892313856,
  4293379011,
  1715208447,
  1013334594,
  2579758848,
  3281632701,
  2297983231,
  125828488,
  1598947343,
  1314910705,
  4292919296,
  117769599,
  2147467271,
  2137326853,
  1012554303,
  1513940967,
  1044283226,
  134749212,
  470288384,
  2134785564,
  1713635328,
  610729983,
  1600061440,
  1600061440,
  151979520,
  2130804607,
  3214557311,
  1509795237,
  1886388226,
  1886417008,
  3063185408,
  2495021055,
  100925568,
  67534719,
  806354944,
  271613823,
  134744064,
  136068650,
  1042024448,
  134744106,
  540818432,
  538976288,
  1042024448,
  473827336,
  1010315272,
  943472190,
  504235568,
  236863038,
  6,
  0
}; // weak
_UNKNOWN unk_E7A8; // weak
int dword_E828[128] =
{
  270598144,
  811802690,
  1353007236,
  1894211782,
  2435416328,
  2976620874,
  3517825420,
  4059029966,
  34607665,
  575812211,
  1117016757,
  1658221303,
  2199425849,
  2740630395,
  3281834941,
  3823039487,
  876815458,
  335610912,
  1959224550,
  1418020004,
  3041633642,
  2500429096,
  4124042734,
  3582838188,
  645019219,
  103814673,
  1727428311,
  1186223765,
  2809837403,
  2268632857,
  3892246495,
  3351041949,
  1491421380,
  2024237190,
  409012288,
  941828098,
  3656239564,
  4189055374,
  2573830472,
  3106646282,
  1255430901,
  1788246711,
  173021809,
  705837619,
  3420249085,
  3953064895,
  2337839993,
  2870655803,
  2089249958,
  1556434148,
  1006840866,
  474025056,
  4254068142,
  3721252332,
  3171659050,
  2638843240,
  1857453719,
  1324637909,
  775044627,
  242228817,
  4022271903,
  3489456093,
  2939862811,
  2407047001,
  2175373704,
  2716578250,
  3241005324,
  3782209870,
  10555520,
  551760066,
  1076187140,
  1617391686,
  2476245945,
  3017450491,
  3541877565,
  4083082111,
  311427761,
  852632307,
  1377059381,
  1918263927,
  2781591018,
  2240386472,
  3847222638,
  3306018092,
  616772834,
  75568288,
  1682404454,
  1141199908,
  3086657499,
  2545452953,
  4152289119,
  3611084573,
  921839315,
  380634769,
  1987470935,
  1446266389,
  3379419468,
  3912235278,
  2313787848,
  2846603658,
  1214601284,
  1747417094,
  148969664,
  681785474,
  3680291709,
  4213107519,
  2614660089,
  3147475899,
  1515473525,
  2048289335,
  449841905,
  982657715,
  3977248046,
  3444432236,
  2911616426,
  2378800616,
  1812429862,
  1279614052,
  746798242,
  213982432,
  4282314527,
  3749498717,
  3216682907,
  2683867097,
  2117496343,
  1584680533,
  1051864723,
  519048913
}; // weak
int ADCH_Values[] = { 7 }; // weak
int dword_EA48[6] = { 1409679360, 19580277, 336855874, 525346070, 54657295, 622203941 }; // weak
_UNKNOWN unk_EA60; // weak
int dword_EA64[182] =
{
  337969986,
  520103190,
  54526238,
  621155364,
  18751232,
  337380162,
  520103190,
  37880094,
  68420352,
  134219520,
  167774464,
  201394944,
  235212092,
  273682176,
  306909598,
  335680256,
  371922198,
  402659090,
  444602722,
  469769088,
  506600714,
  537862083,
  583213340,
  620766208,
  658187776,
  689383424,
  729819719,
  755051523,
  790113861,
  822161408,
  1682004495,
  2015260180,
  2352120360,
  927372860,
  1665161552,
  1998417171,
  2335277351,
  910529851,
  1648318543,
  1981574162,
  2318434342,
  893686842,
  1631475534,
  1964731153,
  2301591333,
  876843833,
  1614632525,
  1947888144,
  2284748324,
  692228664,
  1597789516,
  1931045135,
  2267905315,
  675385655,
  1580946507,
  1914202126,
  2251062306,
  658542646,
  1564103498,
  1897359117,
  2234219297,
  641699637,
  1547260489,
  1880516108,
  2217376288,
  624856628,
  1530417480,
  1863673099,
  2200533279,
  540904755,
  50331975,
  117703938,
  185075974,
  252448010,
  202313230,
  134941197,
  67569161,
  197125,
  251658497,
  218235662,
  184812812,
  151389962,
  101255176,
  67832327,
  34409477,
  986627,
  17172225,
  51252992,
  184812802,
  218630410,
  135072780,
  67832329,
  235078149,
  100728847,
  118361863,
  83886342,
  151653124,
  51121416,
  201523714,
  168364045,
  328715,
  235341313,
  219025167,
  118098700,
  150995206,
  50595080,
  67305986,
  591877,
  168232449,
  235736075,
  185339151,
  118361866,
  83886342,
  50858244,
  134414850,
  328713,
  235341313,
  202050063,
  17566989,
  50989824,
  118361858,
  151258374,
  67700744,
  235341317,
  167969295,
  201392139,
  17566989,
  185470720,
  84281098,
  50858244,
  134414850,
  100992009,
  235604487,
  201392143,
  50462989,
  117835012,
  185207048,
  252579084,
  34603280,
  68027151,
  101451021,
  134874891,
  252186633,
  218500615,
  184814597,
  151128579,
  202248193,
  67504138,
  185405186,
  50661129,
  117702913,
  34606346,
  235603973,
  201917955,
  151785231,
  185467654,
  268567816,
  67570189,
  117702913,
  51383562,
  252446982,
  185074946,
  151388942,
  67178252,
  269289991,
  185074946,
  4279697422,
  4284153664,
  4287889276,
  4291887015,
  4281466860,
  4285988695,
  4289593240,
  4292804545,
  4282777595,
  4287168360,
  4290576299,
  4294049744,
  4283432961,
  4288479087,
  4291690424,
  4294705117
}; // weak
__int16 word_ED3E = 4; // weak
_UNKNOWN unk_EE89; // weak
_UNKNOWN unk_EE9F; // weak
_UNKNOWN unk_EEB5; // weak
_UNKNOWN unk_EEC2; // weak
_UNKNOWN unk_EED0; // weak
_UNKNOWN unk_EF10; // weak
int ch5PTr = 52328; // weak
char aSwaB[6] = "SwA+B"; // weak
_UNKNOWN loc_F740; // weak
_UNKNOWN loc_F758; // weak
void *off_F9F4 = (void *)0x303A3000; // weak
int dword_F9FC = 1212350464; // weak
_UNKNOWN unk_FD60; // weak
_UNKNOWN unk_FD61; // weak
int dword_FFFC = 4294967295; // weak
int dword_1FFFF800 = 0; // weak
int dword_1FFFF804 = 0; // weak
char byte_1FFFF880 = '\0'; // weak
int dword_1FFFF884 = 1100259974; // weak
int dword_1FFFF888 = 4; // weak
int dword_1FFFF88C = 4; // weak
int dword_1FFFF890 = 0; // weak
char byte_1FFFF894 = '\x03'; // weak
char byte_1FFFF895 = '\x13'; // weak
char byte_1FFFF896 = '\x01'; // weak
char byte_1FFFF897 = '\x03'; // weak
int tempInputs = 0; // weak
int inputStates = 983040; // weak
unsigned __int16 inputStates2[2] = { 0u, 0u }; // idb
int counterMain = 33590; // weak
int dword_1FFFF8A8 = 0; // weak
int dword_1FFFF8AC = 0; // weak
unsigned int timer = 33591u; // idb
int lastTimerCheck = 0; // weak
_BYTE byte_1FFFF8B8[8] = { 16, 17, 18, 19, 0, 0, 0, 0 }; // idb
char GFX_ARRAY[] = { '\0' }; // weak
_DWORD dword_1FFFFCC0[6] = { 4294957296, 7100, 7100, 5220, 7100, 5220 }; // idb
_WORD dword_1FFFFCD8[14] =
{
  57176,
  56325,
  59397,
  56579,
  16133,
  53255,
  53255,
  53255,
  56327,
  50693,
  56327,
  56325,
  56325,
  56325
}; // idb
int dword_1FFFFCDC = 3708020741; // weak
int dword_1FFFFCE4 = 3490172935; // weak
_BYTE dword_1FFFFCF4[30] =
{
  5,
  154,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255
}; // idb
_WORD word_1FFFFD12[32] =
{
  523,
  50,
  659,
  50,
  784,
  50,
  1047,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_DWORD byte_1FFFFD54[18] =
{
  2014,
  1824,
  308,
  2095,
  2215,
  3056,
  0,
  0,
  0,
  0,
  0,
  0,
  51,
  0,
  4294957296,
  11,
  10000,
  10000
}; // idb
_DWORD dword_1FFFFD7C[8] = { 0, 0, 51, 0, 4294957296, 11, 10000, 10000 }; // idb
char byte_1FFFFD9C = 'X'; // weak
char byte_1FFFFDB9 = '\x05'; // weak
char byte_1FFFFDBA = 'X'; // weak
char byte_1FFFFDBB = 'P'; // weak
char byte_1FFFFDBC = '‰'; // weak
char byte_1FFFFDBD = '6'; // weak
char byte_1FFFFDBE = 'w'; // weak
__int16 word_1FFFFDBF = 41606; // weak
char byte_1FFFFDC1 = '”'; // weak
char byte_1FFFFDC2 = 'A'; // weak
__int16 word_1FFFFDC3 = 1503; // weak
_DWORD dword_1FFFFDE0[136] =
{
  51,
  0,
  4294957296,
  11,
  7100,
  10000,
  10000,
  10000,
  0,
  9800,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  536870368,
  6513,
  1768062951,
  2595938983,
  2033762114,
  1752790569,
  2648260095,
  59505923,
  3391556503,
  722124970,
  16751569,
  371790040,
  3364415912,
  3730358050,
  676081356,
  620818510,
  994803033,
  2219746872,
  2312440584,
  3518553625,
  3700842167,
  887986626,
  1711926066,
  2949277905,
  2343773268,
  1350783313,
  4103600665,
  2064242222,
  2593515245,
  526782640,
  1179952609,
  2971259026,
  3772861338,
  1291698897,
  838517618,
  882178334,
  2616724783,
  3427671420,
  1491533262,
  114845004,
  3446203552,
  3630945529,
  512224749,
  1633136781,
  1035597198,
  3119766936,
  2452658016,
  202893760,
  3584924128,
  2439975322,
  1855059224,
  1641575640,
  4169212386,
  2623082821,
  2763303569,
  3907404704,
  1600582881,
  1115509534,
  652753929,
  1405646517,
  3234820148,
  1601658692,
  808280419,
  2313522383,
  1426101721,
  1770307028,
  1645181161,
  341425298,
  549808134,
  2346842044,
  1328534696,
  4291552356,
  2941038185,
  347808988,
  1057889489,
  1074233721,
  2312724614,
  2943088295,
  606012172,
  3820071586,
  673910434,
  909703336,
  3897642621,
  1650655732,
  2232422303,
  368792567,
  496872472,
  1214262484,
  961816587,
  93787148,
  993754146,
  4057406949,
  1703167879,
  2486521756,
  3386561850,
  2185780286,
  3036660014,
  569363433,
  719119572,
  10194045,
  3283935470,
  703928729,
  1905919763,
  2457133278,
  2042596384,
  4116581751,
  358745802,
  553688189,
  3804020390,
  1210193810,
  231304821,
  3021080786,
  798123894,
  2083980180
}; // idb
int dword_1FFFFDE4 = 0; // weak
int dword_1FFFFDE8 = 4294957296; // weak
int dword_1FFFFDEC = 11; // weak
int dword_1FFFFDF0 = 7100; // weak
int dword_1FFFFDF4 = 10000; // weak
int dword_1FFFFDF8 = 10000; // weak
int dword_1FFFFDFC = 10000; // weak
int dword_1FFFFE00 = 0; // weak
int dword_1FFFFE04 = 9800; // weak
_UNKNOWN unk_1FFFFE40; // weak
char byte_20000000 = '\0'; // weak
char factoryMode = '\0'; // weak
char byte_20000002 = '\x01'; // weak
char byte_20000003 = '\x01'; // weak
char byte_20000004 = '\0'; // weak
char byte_20000005 = 'C'; // weak
char byte_20000007 = '1'; // weak
char sw_X = 'S'; // weak
char sw_X_val = 'A'; // weak
char var_X = 'V'; // weak
char var_X_val = 'A'; // weak
int dword_20000014 = 33591; // weak
int dword_20000018 = 0; // weak
int dword_2000001C = 33548; // weak
int dword_20000020 = 32828; // weak
int activeSensors = 8; // weak
int dword_20000028 = 0; // weak
int usedModelPtr = 536871598; // weak
int dword_20000030 = 0; // weak
int dword_20000034 = 0; // weak
int dword_20000038 = 0; // weak
int dword_2000003C = 0; // weak
int dword_20000040 = 32020; // weak
int dword_20000044 = 0; // weak
int dword_20000048 = 0; // weak
int dword_2000004C = 0; // weak
int dword_20000050 = 0; // weak
int dword_20000054 = 0; // weak
int dword_20000058 = 0; // weak
int dword_2000005C = 0; // weak
char a100_0[5] = "100%"; // weak
char a100_1[6] = "-100%"; // weak
char voltage[6] = "7.71V"; // weak
char aL100_0[7] = "L 100%"; // weak
char aMix1[7] = "Mix #1"; // weak
_UNKNOWN aA; // idb
char aModel00[9] = "Model 00"; // weak
_UNKNOWN aT; // idb
_DWORD dword_200000B8[7] = { 56139, 60859, 60867, 60863, 60871, 60875, 60879 }; // idb
_BYTE *dword_200000D4[3] = { &unk_ED8F, &unk_ED7B, &unk_ED85 }; // idb
_UNKNOWN unk_200000E0; // weak
_BYTE *off_200000F4[3] = { &unk_EE71, &unk_ED4F, &unk_EE16 }; // idb
char aMode1[7] = "Mode 1"; // weak
char byte_20000114 = '\0'; // weak
char byte_20000115 = '\0'; // weak
char byte_20000116 = '\x01'; // weak
char byte_20000117 = '\x01'; // weak
char byte_20000118 = '\x01'; // weak
int dword_2000011C = 9637; // weak
int dword_20000120 = 536871546; // weak
int dword_20000124 = 4; // weak
int dword_20000128 = 4; // weak
__int16 word_2000012C = 51200; // weak
char byte_2000013C = '\x01'; // weak
char resend1FFFFCF5 = '\0'; // weak
char sendingPacket = '\0'; // weak
char byte_2000013F = '\0'; // weak
int dword_20000140 = 283; // weak
char studentMode = '\0'; // weak
unsigned __int8 byte_20000145[3] = { 0u, 0u, 0u }; // idb
int dword_20000148 = 2; // weak
int dword_2000014C = 0; // weak
int dword_20000150 = 0; // weak
int dword_20000154 = 0; // weak
int dword_20000158 = 2152628480; // weak
int dword_2000015C = 3661111552; // weak
char byte_20000160 = '\x01'; // weak
char adcFlag = '\0'; // weak
char byte_20000165 = '\0'; // weak
int adcChannelIndex = 0; // weak
char byte_2000016C = '\0'; // weak
char byte_2000016D = '\x01'; // weak
char byte_2000016E = '\x01'; // weak
char byte_2000016F = '\0'; // weak
char byte_20000170 = '\0'; // weak
char byte_20000171 = '\x02'; // weak
char byte_20000172 = '\x02'; // weak
char byte_20000173 = '\x02'; // weak
char byte_20000174 = '\0'; // weak
char byte_20000175 = '\x04'; // weak
char byte_20000176 = 'C'; // weak
char byte_20000177 = '\0'; // weak
char byte_20000178 = '\0'; // weak
char byte_20000179 = '\0'; // weak
char byte_2000017A = '\0'; // weak
char byte_2000017B = '\x01'; // weak
char byte_2000017C = '\0'; // weak
char byte_2000017D = 'ð'; // weak
__int16 word_2000017E = 1; // weak
char byte_20000180 = '\x0F'; // weak
char byte_20000181 = 'C'; // weak
int dword_20000184 = 33588901; // weak
int packetSendAt = 3662694912; // weak
int dword_2000018C = 1100259974; // weak
int dword_20000190 = 23; // weak
int dword_20000194 = 23; // weak
int dword_20000198 = 16; // weak
int dword_2000019C = 0; // weak
int dword_200001A0 = 0; // weak
char sensorsArrayInRam[] =
{
  '\0',
  '\0',
  'I',
  '\x04',
  '<',
  '€',
  '\0',
  '\0',
  '\x03',
  '\x02',
  'a',
  '\x04',
  '<',
  '€',
  '\0',
  '\0',
  '\n',
  '\x01',
  'º',
  '­',
  '<',
  '€',
  '\0',
  '\0',
  '',
  '\0',
  '\x03',
  '\x03',
  '\x14',
  '}',
  '\0',
  '\0',
  'ú',
  '\0',
  '(',
  '\0',
  '<',
  '€',
  '\0',
  '\0',
  'û',
  '\0',
  'd',
  '\0',
  '<',
  '€',
  '\0',
  '\0',
  'ü',
  '\0',
  '<',
  '\0',
  '<',
  '€',
  '\0',
  '\0',
  'þ',
  '\0',
  '\x01',
  '\0',
  '<',
  '€',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '°',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char rxsettings[] = { 'Ø', '\0', '\0', '\0' }; // idb
char trainerMode = '\0'; // weak
char trainerSW = '\x13'; // weak
char stickModeSW = '\x01'; // weak
char byte_200002AB = '\x01'; // weak
char lcdBrightnes = '('; // weak
char currentModel = '\0'; // weak
char modelname[9] = "Flysky01"; // weak
char settings_10 = '\x02'; // weak
char settings_11 = '\0'; // weak
char settings_12 = '\0'; // weak
char settings_13 = '\0'; // weak
char FailSafeCH1L = '\xFF'; // weak
char FailSafeCH1H = ''; // weak
char FailSafeCH2L = '\xFF'; // weak
char FailSafeCH2H = ''; // weak
char FailSafeCH3L = '\b'; // weak
char FailSafeCH3H = 'Õ'; // weak
char FailSafeCH4L = '\xFF'; // weak
char FailSafeCH4H = ''; // weak
char FailSafeCH5L = '\xFF'; // weak
char FailSafeCH5H = ''; // weak
char FailSafeCH6L = '\xFF'; // weak
char FailSafeCH6H = ''; // weak
__int16 settingsCRC = 10667; // weak
__int16 stickAdjustData[] =
{
  204,
  1994,
  3773,
  6,
  1824,
  3775,
  343,
  2215,
  4095,
  398,
  2074,
  3876,
  0,
  2048,
  4095,
  0,
  2048,
  4095,
  10241,
  5314
}; // idb
__int16 CRC_STICKDATA = 12236; // weak
char tmpModelData[146] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_DWORD settingRelatedValue[4] = { 215, 214, 216, 213 }; // idb
char RX_BUFFER[] = { '\0' }; // idb
char byte_20000EE5 = '\0'; // weak
char byte_20000EE6 = 'H'; // weak
char byte_20000EE7 = '\x04'; // weak
_DWORD ch1_ADC_VAL = 2014; // idb
int ch2_ADC_VAL = 1823; // weak
int ch3_ADC_VAL = 307; // weak
int ch4_ADC_VAL = 2094; // weak
int voltageADC = 4095; // weak
int SWC_ADC = 4095; // weak
int ADC_Results[] = { 2014 }; // weak


//----- (0000013C) --------------------------------------------------------
void sub_13C()
{
  ;
}

//----- (00000144) --------------------------------------------------------
void sub_144()
{
  ;
}

//----- (0000015A) --------------------------------------------------------
void __fastcall __noreturn sub_15A(int a1, int a2)
{
  sub_144();
  sub_348();
}

//----- (00000168) --------------------------------------------------------
_BYTE *__fastcall sub_168(_BYTE *result, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // r5@1
  _BYTE *v4; // r4@1
  unsigned int i; // r6@1
  int v6; // r1@2
  int v7; // r2@2
  int v8; // r3@2
  int v9; // r1@5
  char v10; // cf@9

  v3 = result;
  v4 = a2;
  for ( i = a3; i >= 0x10; i -= 16 )
  {
    result = *(_BYTE **)v4;
    v6 = *((_DWORD *)v4 + 1);
    v7 = *((_DWORD *)v4 + 2);
    v8 = *((_DWORD *)v4 + 3);
    v4 += 16;
    *(_DWORD *)v3 = result;
    *((_DWORD *)v3 + 1) = v6;
    *((_DWORD *)v3 + 2) = v7;
    *((_DWORD *)v3 + 3) = v8;
    v3 += 16;
  }
  if ( i >= 8 )
  {
    result = *(_BYTE **)v4;
    v9 = *((_DWORD *)v4 + 1);
    v4 += 8;
    *(_DWORD *)v3 = result;
    *((_DWORD *)v3 + 1) = v9;
    v3 += 8;
    i -= 8;
  }
  if ( i >= 4 )
  {
    result = *(_BYTE **)v4;
    v4 += 4;
    *(_DWORD *)v3 = result;
    v3 += 4;
    i -= 4;
  }
  while ( 1 )
  {
    v10 = i-- >= 1;
    if ( !v10 )
      break;
    *v3++ = *v4++;
  }
  return result;
}

//----- (000001B4) --------------------------------------------------------
int sub_1B4()
{
  int v0; // t1@1

  v0 = *off_1D4;
  return ((int (*)(void))*off_1D8)();
}
// 1D4: using guessed type int *off_1D4;
// 1D8: using guessed type void **off_1D8;

//----- (000001C0) --------------------------------------------------------
__int64 get0x2000146020001060()
{
  return qword_1DC;
}
// 1DC: using guessed type __int64 qword_1DC;

//----- (000001EE) --------------------------------------------------------
void __fastcall __noreturn sub_1EE(int a1, int a2)
{
  sub_1F4(a1, a2);
}

//----- (000001F4) --------------------------------------------------------
void __fastcall __noreturn sub_1F4(int a1, int a2)
{
  int v2; // r4@0

  sub_15A(v2, a2);
}

//----- (00000280) --------------------------------------------------------
_BYTE *__fastcall sub_280(_BYTE *result, int a2, unsigned int a3)
{
  char v3; // r3@3
  char v4; // r3@4
  char v5; // r3@5
  int v6; // r3@6
  _DWORD *v7; // r1@7
  char v8; // r7@7
  unsigned int v9; // r6@7
  char *v10; // r1@7
  unsigned int v11; // r3@7
  unsigned int v12; // r5@10
  signed int v13; // r2@13
  char v14; // r3@14
  _BYTE *v15; // r1@14
  int v16; // r2@14
  char v17; // r3@15
  _BYTE *v18; // r1@15

  if ( a3 >= 4 )
  {
    if ( (_DWORD)result << 30 )
    {
      v3 = *(_BYTE *)a2++;
      *result++ = v3;
      --a3;
      if ( (_DWORD)result << 30 )
      {
        v4 = *(_BYTE *)a2++;
        *result++ = v4;
        --a3;
        if ( (_DWORD)result << 30 )
        {
          v5 = *(_BYTE *)a2++;
          *result++ = v5;
          --a3;
        }
      }
    }
    v6 = a2 & 3;
    if ( !(a2 & 3) )
      return sub_168(result, (_BYTE *)a2, a3);
    v7 = (_DWORD *)(a2 - v6);
    v8 = 8 * v6;
    v9 = 32 - 8 * v6;
    v11 = *v7;
    v10 = (char *)(v7 + 1);
    while ( a3 >= 4 )
    {
      v12 = v11;
      v11 = *(_DWORD *)v10;
      v10 += 4;
      *(_DWORD *)result = (v11 << v9) | (v12 >> v8);
      result += 4;
      a3 -= 4;
    }
    a2 = (int)&v10[-(v9 >> 3)];
  }
  v13 = a3 - 1;
  if ( v13 >= 0 )
  {
    v14 = *(_BYTE *)a2;
    v15 = (_BYTE *)(a2 + 1);
    *result++ = v14;
    v16 = v13 - 1;
    if ( v16 >= 0 )
    {
      v17 = *v15;
      v18 = v15 + 1;
      *result++ = v17;
      if ( v16 - 1 >= 0 )
        *result = *v18;
    }
  }
  return result;
}

//----- (00000302) --------------------------------------------------------
#error "31A: positive sp value has been found (funcsize=0)"

//----- (00000340) --------------------------------------------------------
void *Get20001000()
{
  return off_344;
}
// 344: using guessed type void *off_344;

//----- (00000348) --------------------------------------------------------
void __noreturn sub_348()
{
  __breakpoint(171);
  while ( 1 )
    ;
}

//----- (00000354) --------------------------------------------------------
_BYTE *sub_354()
{
  return sub_280((_BYTE *)off_368[0], (int)off_364 - 1, 0x28u);
}
// 364: using guessed type void *off_364;
// 368: using guessed type int *off_368[3];

//----- (0000036C) --------------------------------------------------------
int *sub_36C()
{
  *(_BYTE *)dword_384 = 112;
  sub_3A0();
  off_388();
  return sub_3C0();
}
// 384: using guessed type int dword_384;
// 388: using guessed type int (*off_388)(void);

//----- (000003A0) --------------------------------------------------------
int *sub_3A0()
{
  int *result; // r0@1
  int v1; // r1@1
  _DWORD *v2; // r2@2

  result = off_3B8;
  v1 = *off_3B8;
  if ( !*off_3B8 )
  {
    v2 = (_DWORD *)dword_3BC;
    off_3B8[1] = *(_DWORD *)dword_3BC;
    *v2 = 0;
  }
  *result = v1 + 1;
  return result;
}
// 4: using guessed type int Reset;
// 3B8: using guessed type int *off_3B8;
// 3BC: using guessed type int dword_3BC;

//----- (000003C0) --------------------------------------------------------
int *sub_3C0()
{
  int *result; // r0@1
  int v1; // r1@2

  result = off_3D8;
  if ( *off_3D8 )
  {
    v1 = *off_3D8 - 1;
    *off_3D8 = v1;
    if ( !v1 )
    {
      result = (int *)result[1];
      *(_DWORD *)dword_3DC = result;
    }
  }
  return result;
}
// 4: using guessed type int Reset;
// 3D8: using guessed type int *off_3D8;
// 3DC: using guessed type int dword_3DC;

//----- (000003E0) --------------------------------------------------------
int sub_3E0()
{
  int result; // r0@1

  result = dword_3EC;
  *(_DWORD *)(dword_3EC + 4) = 85;
  *(_DWORD *)(result + 4) = 170;
  return result;
}
// 3EC: using guessed type int dword_3EC;

//----- (00000410) --------------------------------------------------------
signed int __fastcall sub_410(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // r4@1
  int v4; // r6@1
  int v5; // r7@2
  int v6; // r5@3
  signed int result; // r0@6
  void (*v8)(void); // [sp+0h] [bp-28h]@2
  int v9; // [sp+10h] [bp-18h]@1

  v9 = a3;
  v3 = a2;
  v4 = a1;
  if ( a2 )
  {
    v5 = dword_4B8;
    v8 = (void (*)(void))off_4BC;
    while ( 1 )
    {
      v6 = *(_BYTE *)v9 | (*(_BYTE *)(v9 + 1) << 8) | (*(_BYTE *)(v9 + 2) << 16) | (*(_BYTE *)(v9 + 3) << 24);
      if ( v3 < 4 )
        v6 |= ~((1 << 8 * v3) - 1);
      *(_DWORD *)(v5 + 8) = v6;
      *(_DWORD *)(v5 + 4) = v4 | 0x6000000;
      *(_BYTE *)v5 = 112;
      sub_3A0();
      v8();
      sub_3C0();
      if ( *(_BYTE *)v5 & 0x71 )
        return 2;
      *(_DWORD *)(v5 + 4) = v4 | 0x2000000;
      *(_DWORD *)(v5 + 12) = v6;
      *(_DWORD *)(v5 + 8) = 0x1000000;
      *(_BYTE *)v5 = 112;
      sub_3A0();
      v8();
      sub_3C0();
      if ( *(_BYTE *)v5 & 0x71 )
        break;
      if ( v3 > 4 )
      {
        v3 -= 4;
        v4 += 4;
        v9 += 4;
        if ( v3 )
          continue;
      }
      goto LABEL_11;
    }
    result = 3;
  }
  else
  {
LABEL_11:
    result = 0;
  }
  return result;
}
// 4B8: using guessed type int dword_4B8;
// 4BC: using guessed type void *off_4BC;

//----- (000006B4) --------------------------------------------------------
unsigned int __fastcall sub_6B4(_BYTE *a1, signed int a2)
{
  unsigned int v2; // r2@1
  int v3; // r4@3
  signed int i; // r1@8
  __int16 v5; // r4@9
  _BYTE *v6; // r0@9
  int v7; // r4@9

  v2 = dword_72C;
  if ( a2 <= (unsigned int)dword_730 )
  {
    if ( a2 > 0 )
    {
      if ( a2 << 31 )
        v2 = (unsigned __int16)(*((_WORD *)off_734 + (*a1++ ^ 0xFF)) ^ 0xFF00);
      for ( i = a2 >> 1; i; --i )
      {
        v5 = *((_WORD *)off_734 + ((v2 >> 8) ^ *a1));
        v6 = a1 + 1;
        v7 = *((_WORD *)off_734 + (((unsigned int)(unsigned __int16)(v5 ^ ((_WORD)v2 << 8)) >> 8) ^ *v6)) ^ ((unsigned __int16)(v5 ^ ((_WORD)v2 << 8)) << 8);
        a1 = v6 + 1;
        v2 = (unsigned __int16)v7;
      }
    }
  }
  else
  {
    for ( ; a2; --a2 )
    {
      v3 = *((_WORD *)off_734 + ((v2 >> 8) ^ *a1++)) ^ (v2 << 8);
      v2 = (unsigned __int16)v3;
    }
  }
  return v2;
}
// 72C: using guessed type int dword_72C;
// 730: using guessed type int dword_730;
// 734: using guessed type void *off_734;

//----- (00000738) --------------------------------------------------------
int sub_738()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r1@1
  _DWORD *v3; // r2@7
  int v4; // r0@9
  int result; // r0@9

  *(_DWORD *)dword_7E0 = 13;
  *off_7E4 = 0;
  v0 = dword_7EC;
  *(_DWORD *)(dword_7EC + 20) = dword_7E8;
  *(_DWORD *)(v0 + 16) |= 1u;
  v1 = dword_7F0;
  *(_BYTE *)(dword_7F0 + 1) = -100;
  *(_BYTE *)v1 = -104;
  v2 = *(_BYTE *)(v1 + 6);
  while ( *(_BYTE *)(v1 + 6) & 0x10 )
    ;
  while ( (unsigned int)*(_BYTE *)(v1 + 6) << 28 >> 30 != 2 )
    ;
  *(_BYTE *)(v1 + 4) = 32 * (*(_BYTE *)(v1 + 4) >> 5) + 3;
  *(_BYTE *)(v1 + 5) |= 0x40u;
  *(_BYTE *)(v1 + 5) = 32 * (*(_BYTE *)(v1 + 5) >> 5);
  while ( !(*(_BYTE *)(v1 + 6) & 0x20) )
    ;
  while ( !(*(_BYTE *)(v1 + 6) & 0x40) )
    ;
  v3 = (_DWORD *)dword_7F4;
  *(_DWORD *)(dword_7F4 + 4) = *(_DWORD *)(dword_7F4 + 4) & 0x70000 | 0x10000;
  *(_BYTE *)v1 &= 0x3Fu;
  while ( (unsigned int)*(_BYTE *)(v1 + 6) << 28 >> 30 != 3 )
    ;
  *(_BYTE *)dword_7F8 |= 0x80u;
  v4 = dword_7FC;
  *(_DWORD *)(dword_7FC + 56) |= 0x3E00u;
  *(_DWORD *)(v4 + 60) |= 2u;
  result = *v3 | 0x100;
  *v3 = result;
  return result;
}
// 7E0: using guessed type int dword_7E0;
// 7E4: using guessed type int *off_7E4;
// 7E8: using guessed type int dword_7E8;
// 7EC: using guessed type int dword_7EC;
// 7F0: using guessed type int dword_7F0;
// 7F4: using guessed type int dword_7F4;
// 7F8: using guessed type int dword_7F8;
// 7FC: using guessed type int dword_7FC;

//----- (00000800) --------------------------------------------------------
int sub_800()
{
  signed int v0; // r1@1
  int result; // r0@1
  int *v2; // r7@1
  signed int v3; // r6@2
  char *v4; // r5@2
  unsigned int v5; // r1@3
  unsigned int v6; // r2@3
  unsigned int v7; // r1@6
  unsigned int v8; // r0@7
  int v9; // r4@10
  __int16 *i; // r2@10
  int v11; // r4@16
  unsigned int v12; // r0@19
  int v13; // r0@21
  int v14; // r0@23
  __int16 v15; // r2@25
  unsigned int j; // r1@25
  __int16 v17; // r3@26
  int v18; // r1@29
  int v19; // r4@34
  int v20; // r0@36
  _BYTE *v21; // [sp+8h] [bp-140h]@21
  int v22; // [sp+Ch] [bp-13Ch]@0
  __int16 v23; // [sp+16h] [bp-132h]@2
  unsigned __int16 v24; // [sp+18h] [bp-130h]@10
  __int16 *v25; // [sp+12Ch] [bp-1Ch]@2

  v0 = dword_960;
  result = *(_DWORD *)(dword_960 + 20);
  v2 = off_964;
  off_964[1] = result;
  if ( result != v2[2] )
  {
    v2[2] = result;
    *(_DWORD *)(v0 + 24) = dword_968;
    v25 = &v23;
    v3 = v0 >> 19;
    v4 = (char *)off_96C + (v0 >> 19);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_3E0();
        v5 = v2[1];
        result = *v2;
        v6 = v5 - *v2;
        if ( *v2 > v5 )
          v6 += v3;
        if ( v6 < 4 )
          return result;
        v7 = (*(_BYTE *)(result + 1) << 8) | *(_BYTE *)result;
        if ( v7 - 4 >= 0x10D )
          break;
        if ( v6 < v7 )
          return result;
        v9 = 0;
        for ( i = (__int16 *)&v24; v7; v7 = (v7 - 1) & 0xFFFF )
        {
          *(_BYTE *)i = *(_BYTE *)result;
          if ( v7 > 2 )
            v9 += *(_BYTE *)result;
          i = (__int16 *)((char *)i + 1);
          if ( ++result >= (unsigned int)v4 )
            result -= v3;
        }
        v11 = v9 ^ dword_968;
        if ( ((*((_BYTE *)v25 + v24 + 1) << 8) | *((_BYTE *)v25 + v24)) == v11 )
        {
          v12 = v24 + *v2;
          *v2 = v12;
          if ( v12 >= (unsigned int)v4 )
            *v2 = v12 - v3;
          v13 = ((int (__fastcall *)(unsigned __int16 *))loc_4C0)(&v24);
          v21 = (_BYTE *)v13;
          if ( v13 )
          {
            LOWORD(v11) = 0;
            v22 = (*(_BYTE *)(v13 + 2) << 8) | *(_BYTE *)(v13 + 1);
            if ( v22 != 2 )
            {
              v14 = v13 - 1;
              if ( v22 << 31 )
              {
                v14 = (int)v21;
                LOWORD(v11) = *v21;
              }
              v15 = 0;
              for ( j = (unsigned int)(v22 - 2) >> 1; j; --j )
              {
                v17 = *(_BYTE *)(v14 + 1);
                v14 += 2;
                LOWORD(v11) = v17 + v11;
                v15 += *(_BYTE *)v14;
              }
              LOWORD(v11) = v11 + v15;
            }
            sub_3E0();
          }
          v18 = (int)&v21[v22 - 16];
          *(_BYTE *)(v18 + 14) = ~(_BYTE)v11;
          *(_BYTE *)(v18 + 15) = (unsigned __int16)~(_WORD)v11 >> 8;
          while ( *(_DWORD *)(dword_960 + 8) << 8 )
            ;
          if ( *(_DWORD *)(dword_960 + 8) & 0x1000000 )
            *(_DWORD *)(dword_960 + 8) |= 0x1000000u;
          v19 = dword_970;
          while ( (unsigned int)*(_BYTE *)(v19 + 4) >> 6 != 3 )
            sub_3E0();
          v20 = dword_960;
          *(_DWORD *)dword_960 = v21;
          *(_DWORD *)(v20 + 8) = v22;
          *(_DWORD *)(v20 + 12) |= dword_974;
        }
        else
        {
          v8 = *v2 + 1;
          *v2 = v8;
          if ( v8 >= (unsigned int)v4 )
            goto LABEL_18;
        }
      }
      v8 = result + 1;
      *v2 = v8;
      if ( v8 >= (unsigned int)v4 )
LABEL_18:
        *v2 = v8 - v3;
    }
  }
  return result;
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// 960: using guessed type int dword_960;
// 964: using guessed type int *off_964;
// 968: using guessed type int dword_968;
// 96C: using guessed type void *off_96C;
// 970: using guessed type int dword_970;
// 974: using guessed type int dword_974;

//----- (00000978) --------------------------------------------------------
int sub_978()
{
  int *v0; // r0@1
  void *v1; // r1@1
  int v2; // r2@1
  int v3; // r0@1
  int v4; // r2@1
  int result; // r0@1
  int v6; // r3@1

  v0 = off_9DC;
  v1 = off_9D8;
  *off_9DC = (int)off_9D8;
  v0[1] = (int)v1;
  v0[2] = (int)v1;
  *(_DWORD *)(dword_9E0 + 52) |= 0x1000u;
  v2 = dword_9E4;
  *(_DWORD *)dword_9E4 = 768;
  *(_DWORD *)(v2 + 4) = 768;
  v3 = dword_9E8;
  *(_BYTE *)dword_9E8 = 0;
  *(_BYTE *)(v3 + 1) = 13;
  *(_BYTE *)(v3 + 3) |= 0xACu;
  *(_BYTE *)(v3 + 8) |= 0xA0u;
  v4 = dword_9EC;
  *(_BYTE *)dword_9EC = -121;
  result = dword_9F4;
  v6 = dword_9F0;
  *(_DWORD *)(dword_9F4 + 4) = dword_9F0;
  *(_DWORD *)(result + 12) = dword_9F8;
  *(_BYTE *)(v4 + 1) = -122;
  *(_DWORD *)(result + 16) = v6;
  *(_DWORD *)(result + 20) = v1;
  *(_DWORD *)(result + 24) = dword_9FC;
  *(_DWORD *)(result + 28) = dword_A00;
  return result;
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// 9D8: using guessed type void *off_9D8;
// 9DC: using guessed type int *off_9DC;
// 9E0: using guessed type int dword_9E0;
// 9E4: using guessed type int dword_9E4;
// 9E8: using guessed type int dword_9E8;
// 9EC: using guessed type int dword_9EC;
// 9F0: using guessed type int dword_9F0;
// 9F4: using guessed type int dword_9F4;
// 9F8: using guessed type int dword_9F8;
// 9FC: using guessed type int dword_9FC;
// A00: using guessed type int dword_A00;

//----- (0000193C) --------------------------------------------------------
int __fastcall sub_193C(int a1, int format, int *a3)
{
  int result; // r0@2

  switch ( format )
  {
    case 100:
      result = sub_1AC0((_DWORD *)a1, 100, a3);
      break;
    case 117:
      result = sub_1AC0((_DWORD *)a1, 117, a3);
      break;
    case 115:
      result = sub_215C(a1, 115, a3);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00001960) --------------------------------------------------------
void sub_1960()
{
  ;
}

//----- (00001968) --------------------------------------------------------
void emptySub()
{
  ;
}

//----- (0000198C) --------------------------------------------------------
_BYTE *__fastcall strcpy(_BYTE *target, _BYTE *source, unsigned int len)
{
  _BYTE *v3; // r5@1
  _BYTE *v4; // r4@1
  unsigned int i; // r6@1
  int v6; // r1@2
  int v7; // r2@2
  int v8; // r3@2
  int v9; // r1@5
  char v10; // cf@9

  v3 = target;
  v4 = source;
  for ( i = len; i >= 0x10; i -= 16 )
  {
    target = *(_BYTE **)v4;
    v6 = *((_DWORD *)v4 + 1);
    v7 = *((_DWORD *)v4 + 2);
    v8 = *((_DWORD *)v4 + 3);
    v4 += 16;
    *(_DWORD *)v3 = target;
    *((_DWORD *)v3 + 1) = v6;
    *((_DWORD *)v3 + 2) = v7;
    *((_DWORD *)v3 + 3) = v8;
    v3 += 16;
  }
  if ( i >= 8 )
  {
    target = *(_BYTE **)v4;
    v9 = *((_DWORD *)v4 + 1);
    v4 += 8;
    *(_DWORD *)v3 = target;
    *((_DWORD *)v3 + 1) = v9;
    v3 += 8;
    i -= 8;
  }
  if ( i >= 4 )
  {
    target = *(_BYTE **)v4;
    v4 += 4;
    *(_DWORD *)v3 = target;
    v3 += 4;
    i -= 4;
  }
  while ( 1 )
  {
    v10 = i-- >= 1;
    if ( !v10 )
      break;
    *v3++ = *v4++;
  }
  return target;
}

//----- (000019C4) --------------------------------------------------------
int entryPoint()
{
  nullsub_2();
  if ( &unk_EED0 == &unk_EF10 )
  {
    sub_218C();
    sub_1960();
    main_screen();
  }
  return ((int (__fastcall *)(signed int, signed int, signed int))unk_1920)(61200, 536868992, 64);
}
// 218C: using guessed type int sub_218C(void);

//----- (000019D8) --------------------------------------------------------
void *get1FFFFE40()
{
  return &unk_1FFFFE40;
}

//----- (000019F8) --------------------------------------------------------
int __usercall sprintf@<R0>(int a1@<R0>, const char *a2@<R1>, int a3@<R3>, ...)
{
  int v4; // [sp+0h] [bp-20h]@1
  int v5; // [sp+4h] [bp-1Ch]@1
  int varg_r2; // [sp+18h] [bp-8h]@1

  v5 = a3;
  v4 = a1;
  someSprintfMethod((int)a2, (int)&v4, &varg_r2, (int)sub_212C);
  return sub_212C(0, (_BYTE **)&v4);
}

//----- (00001A20) --------------------------------------------------------
int __fastcall sub_1A20(int a1)
{
  int v1; // r4@1
  int v2; // r5@1
  int v3; // r0@1
  signed int v4; // r6@2
  int result; // r0@4

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)a1;
  if ( v3 & 0x10 )
    v4 = 48;
  else
    v4 = 32;
  result = v3 << 31;
  if ( !result )
  {
    while ( --v2 >= 0 )
    {
      (*(void (__fastcall **)(signed int, _DWORD))(v1 + 4))(v4, *(_DWORD *)(v1 + 8));
      result = *(_DWORD *)(v1 + 32) + 1;
      *(_DWORD *)(v1 + 32) = result;
    }
  }
  return result;
}

//----- (00001A4C) --------------------------------------------------------
int __fastcall sub_1A4C(int a1)
{
  int v1; // r4@1
  int v2; // r5@1
  int result; // r0@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 24);
  result = *(_BYTE *)a1 << 31;
  if ( result )
  {
    while ( --v2 >= 0 )
    {
      (*(void (__fastcall **)(signed int, _DWORD))(v1 + 4))(32, *(_DWORD *)(v1 + 8));
      result = *(_DWORD *)(v1 + 32) + 1;
      *(_DWORD *)(v1 + 32) = result;
    }
  }
  return result;
}

//----- (00001A6E) --------------------------------------------------------
int __fastcall sub_1A6E(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // r4@1
  int v4; // r5@1
  unsigned int i; // r3@4
  _BYTE *v6; // r6@9
  int v7; // r0@10

  v3 = a2;
  v4 = a1;
  if ( a3 == 1 )
  {
    i = 1;
  }
  else
  {
    if ( *(_BYTE *)a1 & 0x20 )
      a3 = *(_DWORD *)(a1 + 28);
    for ( i = 0; i < a3 && a2[i]; ++i )
      ;
  }
  v6 = &a2[i];
  *(_DWORD *)(a1 + 24) -= i;
  *(_DWORD *)(a1 + 32) += i;
  sub_1A20(a1);
  while ( v3 < v6 )
  {
    v7 = *v3++;
    (*(void (__fastcall **)(int, _DWORD))(v4 + 4))(v7, *(_DWORD *)(v4 + 8));
  }
  return sub_1A4C(v4);
}

//----- (00001AC0) --------------------------------------------------------
int __fastcall sub_1AC0(_DWORD *a1, int a2, int *a3)
{
  int v3; // r5@1
  int v4; // r0@1
  void **v5; // r6@1
  int v6; // r4@9
  char v7; // r1@10
  _DWORD *v9; // [sp+0h] [bp-20h]@1

  v9 = a1;
  v3 = 0;
  v4 = *a3;
  v5 = (void **)&unk_1B1C;
  if ( a2 != 117 )
  {
    if ( v4 < 0 )
    {
      v4 = -v4;
      v5 = &off_1B20;
LABEL_8:
      v3 = 1;
      goto LABEL_9;
    }
    if ( *v9 & 2 )
    {
      v5 = (void **)&unk_1B24;
      goto LABEL_8;
    }
    if ( *v9 & 4 )
    {
      v5 = (void **)&unk_1B28;
      goto LABEL_8;
    }
  }
LABEL_9:
  v6 = 0;
  while ( v4 )
  {
    v4 = divBy10(v4);
    *((_BYTE *)v9 + v6++ + 36) = v7 + 48;
  }
  return sub_204C((int)v9, v6, (int)v5, v3);
}
// 1B20: using guessed type void *off_1B20;

//----- (00001B2C) --------------------------------------------------------
int __fastcall sub_1B2C(int a1, _DWORD *a2)
{
  int v2; // r4@1
  int v3; // r0@1
  int v4; // r0@3
  void (__fastcall *v5)(int, int); // r2@5
  int v6; // r1@5
  int i; // r5@6
  int v8; // r0@7
  int v9; // r6@7
  int v10; // r0@9
  int v11; // r7@13
  int v12; // r0@25
  int v13; // r0@32
  int v15; // [sp+0h] [bp-20h]@16
  int *a3; // [sp+8h] [bp-18h]@1

  a3 = a2;
  v2 = a1;
  v3 = 0;
LABEL_2:
  *(_DWORD *)(v2 + 32) = v3;
LABEL_3:
  v4 = (*(int (__fastcall **)(int))(v2 + 12))(v2);
  if ( v4 )
  {
    if ( v4 != 37 )
    {
      v5 = *(void (__fastcall **)(int, int))(v2 + 4);
      v6 = *(_DWORD *)(v2 + 8);
      goto LABEL_38;
    }
    for ( i = 0; ; i |= v10 )
    {
      v8 = (*(int (__fastcall **)(int))(v2 + 12))(v2);
      v9 = v8;
      if ( v8 < 32 )
        break;
      if ( (unsigned int)v8 >= 0x31 )
        break;
      v10 = *((_BYTE *)&word_ED3E + v8 - 32);
      if ( !*((_BYTE *)&word_ED3E + v9 - 32) )
        break;
    }
    if ( i & 2 )
      i &= 0xFFFFFFFB;
    *(_DWORD *)(v2 + 28) = 0;
    v11 = 0;
    *(_DWORD *)(v2 + 24) = 0;
    while ( 1 )
    {
      if ( v9 == 42 )
      {
        *(_DWORD *)(4 * v11 + v2 + 24) = *a3;
        ++a3;
        v9 = (*(int (__fastcall **)(_DWORD))(v2 + 12))(v2);
        if ( v11 == 1 )
        {
          if ( *(_DWORD *)(v2 + 28) < 0 )
            i &= 0xFFFFFFDF;
LABEL_25:
          v12 = *(_DWORD *)(v2 + 24);
          if ( v12 < 0 )
          {
            *(_DWORD *)(v2 + 24) = -v12;
            i |= 1u;
          }
          if ( i << 31 )
            i &= 0xFFFFFFEF;
          if ( !v9 )
            return *(_DWORD *)(v2 + 32);
          if ( (unsigned int)(v9 - 65) <= 0x19 )
          {
            i |= 0x800u;
            v9 += 32;
          }
          *(_DWORD *)v2 = i;
          v13 = sub_193C(v2, v9, a3);
          if ( v13 )
          {
            if ( v13 == 1 )
              ++a3;
            else
              a3 = (int *)(8 * (((unsigned int)a3 + 7) >> 3) + 8);
            goto LABEL_3;
          }
          v5 = *(void (__fastcall **)(int, int))(v2 + 4);
          v4 = v9;
          v6 = *(_DWORD *)(v2 + 8);
LABEL_38:
          v5(v4, v6);
          v3 = *(_DWORD *)(v2 + 32) + 1;
          goto LABEL_2;
        }
      }
      else
      {
        if ( isASCICodeSingleDigit(v9) )
        {
          v15 = 4 * v11 + v2;
          for ( *(_DWORD *)(v15 + 24) = v9 - 48; ; *(_DWORD *)(v15 + 24) = 10 * *(_DWORD *)(v15 + 24) + v9 - 48 )
          {
            v9 = (*(int (__fastcall **)(_DWORD))(v2 + 12))(v2);
            if ( !isASCICodeSingleDigit(v9) )
              break;
          }
        }
        if ( v11 == 1 )
          goto LABEL_25;
      }
      if ( v9 == 46 )
      {
        v9 = (*(int (__fastcall **)(_DWORD))(v2 + 12))(v2);
        i |= 0x20u;
        if ( ++v11 < 2 )
          continue;
      }
      goto LABEL_25;
    }
  }
  return *(_DWORD *)(v2 + 32);
}
// ED3E: using guessed type __int16 word_ED3E;

//----- (00001C64) --------------------------------------------------------
_BYTE *__fastcall sub_1C64(_BYTE *result, int a2)
{
  _BYTE *v2; // r2@1
  unsigned int v3; // r3@4
  int v4; // r3@7
  _BYTE *v5; // r1@7
  _BYTE *v6; // r2@7
  int v7; // r3@8

  v2 = result;
  if ( ((unsigned int)result | a2) << 30 )
  {
    do
    {
      v4 = *(_BYTE *)a2;
      v5 = (_BYTE *)(a2 + 1);
      *v2 = v4;
      v6 = v2 + 1;
      if ( !v4 )
        break;
      v7 = *v5;
      a2 = (int)(v5 + 1);
      *v6 = v7;
      v2 = v6 + 1;
    }
    while ( v7 );
  }
  else
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)a2;
      a2 += 4;
      if ( (v3 - 16843009) & ~v3 & 0x80808080 )
        break;
      *(_DWORD *)v2 = v3;
      v2 += 4;
    }
    while ( 1 )
    {
      *v2++ = v3;
      if ( !(_BYTE)v3 )
        break;
      v3 >>= 8;
    }
  }
  return result;
}

//----- (00001CB0) --------------------------------------------------------
char *__fastcall strLength(_DWORD *a1)
{
  char *v1; // r4@1
  int v2; // r1@2
  int v3; // r2@4
  unsigned int v4; // r1@4
  char *result; // r0@5

  v1 = (char *)a1 + 1;
  while ( (_DWORD)a1 << 30 )
  {
    v2 = *(_BYTE *)a1;
    a1 = (_DWORD *)((char *)a1 + 1);
    if ( !v2 )
      return (char *)((char *)a1 - v1);
  }
  do
  {
    v3 = *a1;
    ++a1;
    v4 = (v3 - 16843009) & ~v3 & 0x80808080;
  }
  while ( !v4 );
  result = (char *)((char *)a1 - v1);
  if ( v4 << 24 )
  {
    result -= 3;
  }
  else if ( v4 << 16 )
  {
    result -= 2;
  }
  else if ( v4 << 8 )
  {
    --result;
  }
  return result;
}

//----- (00001CF4) --------------------------------------------------------
_BYTE *__fastcall memcpy(_BYTE *result, int a2, unsigned int a3)
{
  char v3; // r3@3
  char v4; // r3@4
  char v5; // r3@5
  int v6; // r3@6
  _DWORD *v7; // r1@7
  char v8; // r7@7
  unsigned int v9; // r6@7
  char *v10; // r1@7
  unsigned int v11; // r3@7
  unsigned int v12; // r5@10
  signed int v13; // r2@13
  char v14; // r3@14
  _BYTE *v15; // r1@14
  int v16; // r2@14
  char v17; // r3@15
  _BYTE *v18; // r1@15

  if ( a3 >= 4 )
  {
    if ( (_DWORD)result << 30 )
    {
      v3 = *(_BYTE *)a2++;
      *result++ = v3;
      --a3;
      if ( (_DWORD)result << 30 )
      {
        v4 = *(_BYTE *)a2++;
        *result++ = v4;
        --a3;
        if ( (_DWORD)result << 30 )
        {
          v5 = *(_BYTE *)a2++;
          *result++ = v5;
          --a3;
        }
      }
    }
    v6 = a2 & 3;
    if ( !(a2 & 3) )
      return strcpy(result, (_BYTE *)a2, a3);
    v7 = (_DWORD *)(a2 - v6);
    v8 = 8 * v6;
    v9 = 32 - 8 * v6;
    v11 = *v7;
    v10 = (char *)(v7 + 1);
    while ( a3 >= 4 )
    {
      v12 = v11;
      v11 = *(_DWORD *)v10;
      v10 += 4;
      *(_DWORD *)result = (v11 << v9) | (v12 >> v8);
      result += 4;
      a3 -= 4;
    }
    a2 = (int)&v10[-(v9 >> 3)];
  }
  v13 = a3 - 1;
  if ( v13 >= 0 )
  {
    v14 = *(_BYTE *)a2;
    v15 = (_BYTE *)(a2 + 1);
    *result++ = v14;
    v16 = v13 - 1;
    if ( v16 >= 0 )
    {
      v17 = *v15;
      v18 = v15 + 1;
      *result++ = v17;
      if ( v16 - 1 >= 0 )
        *result = *v18;
    }
  }
  return result;
}

//----- (00001D76) --------------------------------------------------------
_BYTE *__fastcall sub_1D76(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // r1@2
  _BYTE *result; // r0@2
  int v5; // r4@6
  int v6; // r5@6
  int v7; // r6@6

  if ( a1 - a2 >= a3 )
  {
    result = strcpy(a1, a2, a3);
  }
  else
  {
    v3 = &a2[a3];
    result = &a1[a3];
    while ( a3 << 30 )
    {
      --v3;
      --a3;
      *--result = *v3;
    }
    while ( a3 >= 0x10 )
    {
      v3 -= 16;
      result -= 16;
      a3 -= 16;
      v5 = *((_DWORD *)v3 + 1);
      v6 = *((_DWORD *)v3 + 2);
      v7 = *((_DWORD *)v3 + 3);
      *(_DWORD *)result = *(_DWORD *)v3;
      *((_DWORD *)result + 1) = v5;
      *((_DWORD *)result + 2) = v6;
      *((_DWORD *)result + 3) = v7;
    }
    while ( 1 )
    {
      a3 -= 4;
      if ( (a3 & 0x80000000) != 0 )
        break;
      result -= 4;
      v3 -= 4;
      *(_DWORD *)result = *(_DWORD *)v3;
    }
  }
  return result;
}

//----- (00001E0C) --------------------------------------------------------
_WORD *__fastcall setupDMA(_WORD *targetAddress, unsigned int numbButesToSend, unsigned __int8 a3)
{
  int v3; // r2@1

  v3 = 0x1010101 * a3;
  if ( numbButesToSend )
  {
    if ( (_DWORD)targetAddress << 31 )
    {
      *(_BYTE *)targetAddress = v3;
      targetAddress = (_WORD *)((char *)targetAddress + 1);
      --numbButesToSend;
    }
    if ( numbButesToSend >= 2 && (unsigned __int8)targetAddress & 2 )
    {
      *targetAddress = v3;
      ++targetAddress;
      numbButesToSend -= 2;
    }
  }
  while ( numbButesToSend >= 4 )
  {
    *(_DWORD *)targetAddress = v3;
    targetAddress += 2;
    numbButesToSend -= 4;
  }
  if ( numbButesToSend & 2 )
  {
    *targetAddress = v3;
    ++targetAddress;
  }
  if ( numbButesToSend << 31 )
    *(_BYTE *)targetAddress = v3;
  return targetAddress;
}

//----- (00001E56) --------------------------------------------------------
void callSetupDMA()
{
  JUMPOUT(&loc_1E38);
}

//----- (00001E5E) --------------------------------------------------------
void __fastcall div_Other(unsigned int a1, unsigned int a2)
{
  if ( a1 >> 4 < a2 )
    JUMPOUT(&loc_1F4E);
  if ( a1 >> 8 < a2 )
    JUMPOUT(&loc_1F1E);
  if ( a1 >> 12 < a2 )
    JUMPOUT(&loc_1EEC);
  if ( a1 >> 16 < a2 )
    JUMPOUT(&loc_1EBC);
  JUMPOUT(&loc_1EA0);
}

//----- (00001E7A) --------------------------------------------------------
int __fastcall div_(unsigned int a1, unsigned int a2)
{
  signed int v2; // r2@2
  unsigned __int8 v3; // cf@12
  int v4; // r2@14
  unsigned __int8 v5; // cf@14
  int v6; // r2@16
  unsigned __int8 v7; // cf@16
  int v8; // r2@18
  unsigned __int8 v9; // cf@18
  unsigned __int8 v10; // cf@21
  int v11; // r2@23
  unsigned __int8 v12; // cf@23
  int v13; // r2@25
  unsigned __int8 v14; // cf@25
  int v15; // r2@27
  unsigned __int8 v16; // cf@27
  int v17; // off@29
  unsigned __int8 v18; // cf@30
  int v19; // r2@32
  unsigned __int8 v20; // cf@32
  int v21; // r2@34
  unsigned __int8 v22; // cf@34
  int v23; // r2@36
  unsigned __int8 v24; // cf@36
  unsigned __int8 v25; // cf@39
  int v26; // r2@41
  unsigned __int8 v27; // cf@41
  int v28; // r2@43
  unsigned __int8 v29; // cf@43
  int result; // r0@46
  unsigned int v31; // r2@48
  signed int v32; // r3@50
  char v33; // r3@53
  signed int v34; // r2@53
  char v35; // r12@53
  unsigned int v36; // r3@55
  unsigned __int8 v37; // cf@61
  int v38; // r2@63
  unsigned __int8 v39; // cf@63
  int v40; // r2@65
  unsigned __int8 v41; // cf@65
  int v42; // r2@67
  unsigned __int8 v43; // cf@67
  unsigned __int8 v44; // cf@70
  int v45; // r2@72
  unsigned __int8 v46; // cf@72
  int v47; // off@74
  unsigned __int8 v48; // cf@75
  int v49; // r2@77

  if ( ((a1 | a2) & 0x80000000) == 0 )
  {
    v2 = 0;
    if ( a1 >> 1 < a2 )
      return v2 + (a1 >= a2) + v2;
    if ( a1 >> 4 < a2 )
    {
LABEL_39:
      v25 = a1 >> 3 >= a2;
      if ( a1 >> 3 >= a2 )
      {
        v25 = a1 >= 8 * a2;
        a1 -= 8 * a2;
      }
      v26 = v2 + v25 + v2;
      v27 = a1 >> 2 >= a2;
      if ( a1 >> 2 >= a2 )
      {
        v27 = a1 >= 4 * a2;
        a1 -= 4 * a2;
      }
      v28 = v26 + v27 + v26;
      v29 = a1 >> 1 >= a2;
      if ( a1 >> 1 >= a2 )
      {
        v29 = a1 >= 2 * a2;
        a1 -= 2 * a2;
      }
      v2 = v28 + v29 + v28;
      return v2 + (a1 >= a2) + v2;
    }
    if ( a1 >> 8 < a2 )
    {
LABEL_30:
      v18 = a1 >> 7 >= a2;
      if ( a1 >> 7 >= a2 )
      {
        v18 = a1 >= a2 << 7;
        a1 -= a2 << 7;
      }
      v19 = v2 + v18 + v2;
      v20 = a1 >> 6 >= a2;
      if ( a1 >> 6 >= a2 )
      {
        v20 = a1 >= a2 << 6;
        a1 -= a2 << 6;
      }
      v21 = v19 + v20 + v19;
      v22 = a1 >> 5 >= a2;
      if ( a1 >> 5 >= a2 )
      {
        v22 = a1 >= 32 * a2;
        a1 -= 32 * a2;
      }
      v23 = v21 + v22 + v21;
      v24 = a1 >> 4 >= a2;
      if ( a1 >> 4 >= a2 )
      {
        v24 = a1 >= 16 * a2;
        a1 -= 16 * a2;
      }
      v2 = v23 + v24 + v23;
      goto LABEL_39;
    }
    if ( a1 >> 12 < a2 )
      goto LABEL_21;
    if ( a1 >> 16 < a2 )
    {
      while ( 1 )
      {
LABEL_12:
        v3 = a1 >> 15 >= a2;
        if ( a1 >> 15 >= a2 )
        {
          v3 = a1 >= a2 << 15;
          a1 -= a2 << 15;
        }
        v4 = v2 + v3 + v2;
        v5 = a1 >> 14 >= a2;
        if ( a1 >> 14 >= a2 )
        {
          v5 = a1 >= a2 << 14;
          a1 -= a2 << 14;
        }
        v6 = v4 + v5 + v4;
        v7 = a1 >> 13 >= a2;
        if ( a1 >> 13 >= a2 )
        {
          v7 = a1 >= a2 << 13;
          a1 -= a2 << 13;
        }
        v8 = v6 + v7 + v6;
        v9 = a1 >> 12 >= a2;
        if ( a1 >> 12 >= a2 )
        {
          v9 = a1 >= a2 << 12;
          a1 -= a2 << 12;
        }
        v2 = v8 + v9 + v8;
LABEL_21:
        v10 = a1 >> 11 >= a2;
        if ( a1 >> 11 >= a2 )
        {
          v10 = a1 >= a2 << 11;
          a1 -= a2 << 11;
        }
        v11 = v2 + v10 + v2;
        v12 = a1 >> 10 >= a2;
        if ( a1 >> 10 >= a2 )
        {
          v12 = a1 >= a2 << 10;
          a1 -= a2 << 10;
        }
        v13 = v11 + v12 + v11;
        v14 = a1 >> 9 >= a2;
        if ( a1 >> 9 >= a2 )
        {
          v14 = a1 >= a2 << 9;
          a1 -= a2 << 9;
        }
        v15 = v13 + v14 + v13;
        v16 = a1 >> 8 >= a2;
        if ( a1 >> 8 >= a2 )
        {
          v16 = a1 >= a2 << 8;
          a1 -= a2 << 8;
        }
        v17 = v16 + v15;
        v3 = __CFADD__(v16, v15) | __CFADD__(v15, v17);
        v2 = v15 + v17;
        if ( !v3 )
          break;
        a2 >>= 8;
      }
      goto LABEL_30;
    }
    a2 <<= 8;
    v2 = __rev(0xFFu);
    if ( a1 >> 16 < a2 || (v2 >>= 8, (a2 <<= 8) != 0) )
    {
      if ( a1 >> 12 < a2 )
        goto LABEL_21;
      goto LABEL_12;
    }
    return 0;
  }
  v31 = a2 >> 31;
  if ( a2 >> 31 )
    a2 = -a2;
  v32 = (signed int)a1 >> 32;
  if ( __CFSHR__(a1, 32) )
    a1 = -a1;
  v33 = v32 ^ v31;
  v34 = 0;
  v35 = v33;
  if ( a1 >> 4 < a2 )
    goto LABEL_70;
  if ( a1 >> 8 >= a2 )
  {
    a2 <<= 6;
    v34 = __rev(0xFCu);
    v36 = a1 >> 8;
    if ( a1 >> 8 >= a2 )
    {
      a2 <<= 6;
      v34 >>= 6;
      if ( v36 >= a2 )
      {
        a2 <<= 6;
        v34 >>= 6;
        if ( v36 >= a2 )
        {
          a2 <<= 6;
          if ( !a2 )
            return 0;
          v34 >>= 6;
        }
      }
    }
  }
  while ( 1 )
  {
    v37 = a1 >> 7 >= a2;
    if ( a1 >> 7 >= a2 )
    {
      v37 = a1 >= a2 << 7;
      a1 -= a2 << 7;
    }
    v38 = v34 + v37 + v34;
    v39 = a1 >> 6 >= a2;
    if ( a1 >> 6 >= a2 )
    {
      v39 = a1 >= a2 << 6;
      a1 -= a2 << 6;
    }
    v40 = v38 + v39 + v38;
    v41 = a1 >> 5 >= a2;
    if ( a1 >> 5 >= a2 )
    {
      v41 = a1 >= 32 * a2;
      a1 -= 32 * a2;
    }
    v42 = v40 + v41 + v40;
    v43 = a1 >> 4 >= a2;
    if ( a1 >> 4 >= a2 )
    {
      v43 = a1 >= 16 * a2;
      a1 -= 16 * a2;
    }
    v34 = v42 + v43 + v42;
LABEL_70:
    v44 = a1 >> 3 >= a2;
    if ( a1 >> 3 >= a2 )
    {
      v44 = a1 >= 8 * a2;
      a1 -= 8 * a2;
    }
    v45 = v34 + v44 + v34;
    v46 = a1 >> 2 >= a2;
    if ( a1 >> 2 >= a2 )
    {
      v46 = a1 >= 4 * a2;
      a1 -= 4 * a2;
    }
    v47 = v46 + v45;
    v3 = __CFADD__(v46, v45) | __CFADD__(v45, v47);
    v34 = v45 + v47;
    if ( !v3 )
      break;
    a2 >>= 6;
  }
  v48 = a1 >> 1 >= a2;
  if ( a1 >> 1 >= a2 )
  {
    v48 = a1 >= 2 * a2;
    a1 -= 2 * a2;
  }
  v49 = v34 + v48 + v34 + (a1 >= a2) + v34 + v48 + v34;
  result = v49;
  if ( v35 & 1 )
    result = -v49;
  return result;
}

//----- (0000204C) --------------------------------------------------------
signed int __fastcall sub_204C(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r1@1
  signed int v7; // r0@2
  int v8; // r7@5
  int v9; // r6@9
  int v10; // r0@15
  int v11; // r0@18
  signed int result; // r0@20
  int v13; // [sp+0h] [bp-28h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  int v15; // [sp+10h] [bp-18h]@1

  v14 = a3;
  v15 = a4;
  v4 = a1;
  v5 = a2;
  v13 = a1 + 36;
  v6 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x20 )
  {
    v7 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)v4 = v6 & 0xFFFFFFEF;
  }
  else
  {
    v7 = 1;
  }
  if ( v7 <= v5 )
    v8 = 0;
  else
    v8 = v7 - v5;
  *(_DWORD *)(v4 + 24) -= v8 + v5 + a4;
  if ( !(*(_BYTE *)v4 & 0x10) )
    sub_1A20(v4);
  v9 = 0;
  while ( v9 < v15 )
  {
    (*(void (__fastcall **)(_DWORD, _DWORD))(v4 + 4))(*(_BYTE *)(v14 + v9++), *(_DWORD *)(v4 + 8));
    ++*(_DWORD *)(v4 + 32);
  }
  if ( *(_BYTE *)v4 & 0x10 )
    sub_1A20(v4);
  while ( 1 )
  {
    v10 = v8--;
    if ( v10 <= 0 )
      break;
    (*(void (__fastcall **)(signed int, _DWORD))(v4 + 4))(48, *(_DWORD *)(v4 + 8));
    ++*(_DWORD *)(v4 + 32);
  }
  while ( 1 )
  {
    v11 = v5--;
    if ( v11 <= 0 )
      break;
    (*(void (__fastcall **)(_DWORD, _DWORD))(v4 + 4))(*(_BYTE *)(v13 + v5), *(_DWORD *)(v4 + 8));
    ++*(_DWORD *)(v4 + 32);
  }
  sub_1A4C(v4);
  if ( *(_BYTE *)v4 & 0x80 )
    result = 2;
  else
    result = 1;
  return result;
}

//----- (000020FC) --------------------------------------------------------
int __fastcall sub_20FC(int a1)
{
  int v1; // r1@1

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v1 + 1;
  return *(_BYTE *)v1;
}

//----- (00002106) --------------------------------------------------------
int __fastcall someSprintfMethod(int a1, int a2, _DWORD *a3, int a4)
{
  int v5; // [sp+0h] [bp-40h]@1
  int v6; // [sp+4h] [bp-3Ch]@1
  int v7; // [sp+8h] [bp-38h]@1
  int (__fastcall *v8)(int); // [sp+Ch] [bp-34h]@1
  int v9; // [sp+10h] [bp-30h]@1
  int v10; // [sp+14h] [bp-2Ch]@1

  v7 = a2;
  v10 = 0;
  v6 = a4;
  v8 = sub_20FC;
  v9 = a1;
  return sub_1B2C((int)&v5, a3);
}

//----- (0000212C) --------------------------------------------------------
int __fastcall sub_212C(int result, _BYTE **a2)
{
  _BYTE *v2; // r2@1

  v2 = *a2;
  *v2 = result;
  *a2 = v2 + 1;
  return result;
}

//----- (00002136) --------------------------------------------------------
signed int __fastcall sub_2136(int a1, _BYTE *a2, unsigned int a3)
{
  if ( !*(_DWORD *)(a1 + 20) )
    sub_1A6E(a1, a2, a3);
  return 1;
}

//----- (0000215C) --------------------------------------------------------
int __fastcall sub_215C(int a1, int a2, int *a3)
{
  return sub_2136(a1, (_BYTE *)*a3, 0xFFFFFFFF);
}

//----- (00002164) --------------------------------------------------------
unsigned int __fastcall divBy10(unsigned int value)
{
  unsigned int valueCpy; // r1@1
  unsigned int v2; // r0@1
  unsigned int result; // r0@1
  unsigned int v4; // r1@1

  valueCpy = value;
  v2 = ((value - (value >> 2)) >> 4) + value - (value >> 2);
  result = ((((v2 >> 8) + v2) >> 16) + (v2 >> 8) + v2) >> 3;
  v4 = valueCpy - 10 * result;
  while ( v4 >= 0xA )
  {
    v4 -= 10;
    ++result;
  }
  return result;
}

//----- (0000218C) --------------------------------------------------------
#error "21A4: positive sp value has been found (funcsize=0)"

//----- (000021D8) --------------------------------------------------------
_DWORD *sub_21D8()
{
  return dword_1FFFFDE0;
}

//----- (000021E0) --------------------------------------------------------
void __noreturn sub_21E0()
{
  __breakpoint(171);
  while ( 1 )
    ;
}

//----- (000021EC) --------------------------------------------------------
int adc_setup()
{
  unsigned int channel; // r3@1
  char not_20000164; // r2@1
  int offset; // r4@1
  int result; // r0@7
  unsigned int v4; // r3@10

  channel = adcChannelIndex;
  not_20000164 = adcFlag ^ 1;
  offset = adcChannelIndex;
  if ( adcFlag )
  {
    *(_DWORD *)((char *)&ch1_ADC_VAL + offset * 4) = (unsigned int)(ADC_Results[offset] + v4003B010) >> 1;// // GET ADC ResultRegister
    if ( channel == 7 )
    {
      adcChannelIndex = 0;
      adcFlag = not_20000164;
      byte_20000165 = 0;
      result = 64;                              // BIN 1000000
      v4003B000 &= 0xFFFFFFBF;                  // unset bit 7
      return result;
    }
  }
  else
  {
    ADC_Results[offset] = v4003B010;            // GET ADC ResultRegister
  }
  if ( channel >= 7 )
  {
    adcChannelIndex = 0;
    adcFlag = not_20000164;
  }
  else
  {
    adcChannelIndex = channel + 1;
  }
  byte_20000165 = 1;
  if ( adcChannelIndex == 5 )
    v4 = v4003B00C & 0xFFFFFFEF;                // unset 5th bit - ADxxa channels are selected. 
  else
    v4 = v4003B00C | 0x10;                      // set 5th bit - ADxxb channels are selected.
  v4003B00C = v4;                               // ADC configuration register
  result = ADCH_Values[adcChannelIndex] | 0x40; // set to ADCH_values[channel] COCO flag always 1
  v4003B000 = ADCH_Values[adcChannelIndex] | 0x40;
  return result;
}
// EA28: using guessed type int ADCH_Values[];
// 20000164: using guessed type char adcFlag;
// 20000165: using guessed type char byte_20000165;
// 20000168: using guessed type int adcChannelIndex;
// 20000F20: using guessed type int ADC_Results[];

//----- (00002278) --------------------------------------------------------
char *calibrateADC()
{
  char *result; // r0@5

  v4004803C |= 0x8000000u;                      // System Clock Gating Control Register 6 (SIM_SCGC6)
  v4004C018 = 0;                                // Pin Control Register n (PORTD_PCR6
  v4004C014 = 0;                                // Pin Control Register n (PORTD_PCR5)
  v4004C004 = 0;                                // Pin Control Register n (PORTD_PCR1)
  v4004B008 = 0;                                // Pin Control Register n (PORTC_PCR2)
  v4004D058 = 0;                                // Pin Control Register n (PORTE_PCR22)
  v4004D05C = 0;                                // Pin Control Register n (PORTE_PCR23)
  v4004D074 = 0;                                // Pin Control Register n (PORTE_PCR29) 
  v4004B000 = 0;                                // Port C multiplexing control 
  v4003B008 = 52;                               // ADC Configuration Register 1 (ADC0_CFG1)
                                                // 10-bit conversion div Ratio 8
  v4003B00C = 22;                               // ADC Configuration Register 2 (ADC0_CFG2) 
                                                // 6 extra ADCK cycles; 10 ADCK cycles total sample time
                                                // High-speed conversion 
                                                // Asynchronous clock and clock output is enabled 
                                                // 1 ADxxb channels are selected.
                                                // 
  v4003B020 = 0;                                //  Status and Control Register 2 (ADC0_SC2) 
  v4003B024 = 133;                              // Status and Control Register 3 (ADC0_SC3
                                                // 8 samples averaged. 
                                                // 1 Hardware average function enabled.
                                                // 7 Calibration
  while ( v4003B024 & 0x80 )
    ;
  if ( !(v4003B024 & 0x40) )                    // ADC Plus-Side Gain Register (ADC0_PG)
    v4003B02C = ((unsigned int)(v4003B04C + v4003B048 + v4003B044 + v4003B040 + v4003B03C + v4003B038) >> 1) | (unsigned int)&loc_8000;
  vE000E40C = (vE000E40C & 0xFFFFFF) + 2147483648;
  vE000E100 |= (unsigned int)&loc_8000;
  result = &adcFlag;
  adcChannelIndex = 0;
  adcFlag = 0;
  return result;
}
// 2328: using guessed type void *off_2328;
// 20000164: using guessed type char adcFlag;
// 20000168: using guessed type int adcChannelIndex;

//----- (0000232C) --------------------------------------------------------
int sub_232C()
{
  return (unsigned __int8)byte_20000165;
}
// 20000165: using guessed type char byte_20000165;

//----- (00002338) --------------------------------------------------------
int __fastcall adcMethod2(int a1)
{
  unsigned int v1; // r0@4
  int result; // r0@5

  byte_20000165 = 1;
  if ( a1 )                                     // a1 is always true adcChannelIndex is set to 0
  {
    adcChannelIndex = 0;
  }
  else if ( adcChannelIndex == 5 )
  {
    v1 = v4003B00C & 0xFFFFFFEF;                // ADC Configuration Register 2 (ADC0_CFG2)
    goto LABEL_5;
  }
  v1 = v4003B00C | 0x10;
LABEL_5:
  v4003B00C = v1;
  result = ADCH_Values[adcChannelIndex] | 0x40;
  v4003B000 = ADCH_Values[adcChannelIndex] | 0x40;
  return result;
}
// EA28: using guessed type int ADCH_Values[];
// 20000165: using guessed type char byte_20000165;
// 20000168: using guessed type int adcChannelIndex;

//----- (0000237C) --------------------------------------------------------
int __fastcall sub_237C(int a1, int a2)
{
  int v2; // r6@1
  int v3; // r5@1
  int v4; // r4@1
  char *v5; // r1@5
  int v6; // r0@5
  int v7; // r4@5
  int v8; // r0@5
  unsigned int v9; // r0@6

  v2 = a1;
  v3 = a2;
  v4 = 0;
  while ( (signed int)&byte_DA0[1512] * v4 - 5000 < a1 )
  {
    if ( ++v4 >= 4 )
      return 0;
  }
  if ( getInputStates() & (1 << *(_BYTE *)(usedModelPtr + 44)) )
    v3 += 5;
  v5 = (char *)dword_2710 + v2 - (_DWORD)&byte_DA0[1512] * v4;
  v6 = *(_BYTE *)(v3 + v4 + 1);
  v7 = *(_BYTE *)(v3 + v4);
  v8 = (v6 - v7) * (_DWORD)v5;
  if ( v8 >= 0 )
    v9 = v8 + 12;
  else
    v9 = v8 - 12;
  return 200 * v7 + div_(v9, 0x19u) - 10000;
}
// 2710: using guessed type int dword_2710[28];
// 2000002C: using guessed type int usedModelPtr;

//----- (000023F4) --------------------------------------------------------
signed int sub_23F4()
{
  int v0; // r5@1
  int v1; // r1@3
  int v2; // r0@5

  v0 = 0;
  beep(784, 100);
  fillRegion(0, 48, 127, 63, 1);
  displayTextAt2("Are you sure?", 64, 48, 0);
  displayTextAt("Yes", 28, 56, 0);
  displayTextAt("No", 76, 56, 0);
  while ( 1 )
  {
    while ( 1 )
    {
      fillRegion(20, 56, 27, 63, 1);
      fillRegion(68, 56, 75, 63, 1);
      v1 = v0 ? 20 : 68;
      displayGFX((int)&arrow_gfx, v1, 56);
      LCD_updateCALL();
      v2 = getKeyCode();
      if ( v2 != 24 && v2 != 23 && v2 != 8 && v2 != 9 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v2 == 10 || v2 == 25 )
      break;
    if ( v2 == 11 )
      goto LABEL_12;
  }
  if ( !v0 )
  {
LABEL_12:
    beep(523, 100);
    return 0;
  }
  return 1;
}

//----- (000024D0) --------------------------------------------------------
_BYTE *__fastcall sub_24D0(char a1)
{
  char v1; // r5@1
  unsigned int v2; // r0@1
  int v3; // r1@4
  _BYTE *result; // r0@6

  v1 = a1;
  byte_1FFFF895 = a1;
  v2 = (a1 & 0x7F) - 16;
  if ( byte_1FFFF880 )
  {
    if ( v2 >= 6 )
    {
      controlBackLight(1);
      lastTimerCheck = timer;
    }
  }
  else if ( v2 >= 6 )
  {
    sub_A320();
    controlBackLight(1);
    result = (_BYTE *)timer;
    lastTimerCheck = timer;
    return result;
  }
  sub_A320();
  v3 = dword_1FFFF8AC + 1;
  if ( (unsigned int)(dword_1FFFF8AC + 1) >= 8 )
    v3 = 0;
  result = (_BYTE *)dword_1FFFF8A8;
  if ( v3 != dword_1FFFF8A8 )
  {
    result = byte_1FFFF8B8;
    byte_1FFFF8B8[dword_1FFFF8AC] = v1;
    dword_1FFFF8AC = v3;
  }
  return result;
}
// 1FFFF880: using guessed type char byte_1FFFF880;
// 1FFFF895: using guessed type char byte_1FFFF895;
// 1FFFF8A8: using guessed type int dword_1FFFF8A8;
// 1FFFF8AC: using guessed type int dword_1FFFF8AC;
// 1FFFF8B4: using guessed type int lastTimerCheck;

//----- (00002534) --------------------------------------------------------
int getKeyCode()
{
  int result; // r0@3
  int v1; // r1@3

  while ( dword_1FFFF8A8 == dword_1FFFF8AC )
    sendPacketWithTimer();
  result = byte_1FFFF8B8[dword_1FFFF8A8];
  v1 = dword_1FFFF8A8 + 1;
  if ( (unsigned int)(dword_1FFFF8A8 + 1) >= 8 )
    v1 = 0;
  dword_1FFFF8A8 = v1;
  return result;
}
// 1FFFF8A8: using guessed type int dword_1FFFF8A8;
// 1FFFF8AC: using guessed type int dword_1FFFF8AC;

//----- (00002568) --------------------------------------------------------
int getInputStates()
{
  return inputStates;
}
// 1FFFF89C: using guessed type int inputStates;

//----- (00002574) --------------------------------------------------------
signed int sub_2574()
{
  signed int result; // r0@2

  sendPacketWithTimer();
  if ( dword_1FFFF8A8 == dword_1FFFF8AC )
    result = 255;
  else
    result = byte_1FFFF8B8[dword_1FFFF8A8];
  return result;
}
// 1FFFF8A8: using guessed type int dword_1FFFF8A8;
// 1FFFF8AC: using guessed type int dword_1FFFF8AC;

//----- (00002598) --------------------------------------------------------
signed int rxBindingShow()
{
  rxBindingPage();
  return 1;
}

//----- (000025A4) --------------------------------------------------------
signed int __fastcall sub_25A4(char a1)
{
  signed int result; // r0@1

  byte_20000118 = a1;
  result = 1;
  byte_20000117 = 1;
  return result;
}
// 20000117: using guessed type char byte_20000117;
// 20000118: using guessed type char byte_20000118;

//----- (000025B4) --------------------------------------------------------
int callSetupDMAandSend()
{
  return setupDMAandSend();
}

//----- (000025BC) --------------------------------------------------------
int LCD_updateCALL()
{
  return LCD_update();
}

//----- (00002800) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // r0@5
  _BYTE *v4; // r1@46
  int v5; // r2@47
  __int16 v6; // r4@70
  int v7; // r0@71
  int v8; // r0@76
  char v9; // r0@81
  signed int v10; // r0@82
  char *v11; // r1@95
  char v12; // r0@97
  char *v13; // r0@104
  char v14; // r1@107
  signed int v15; // r5@134
  char v16; // r0@139
  int v17; // r1@149
  int v18; // r1@152

  v4003710C |= 1u;                              // Timer Flag Register (PIT_TFLG0
  if ( (unsigned __int8)++byte_1FFFF897 >= 4u )
  {
    byte_1FFFF897 = 0;
    ++timer;
  }
  tempInputs |= (~v400FF050 & 0xFFFFFu) >> 16 << 4 * byte_1FFFF894++;// Port Data Input Register (GPIOB_PDIR) 
  if ( (unsigned __int8)byte_1FFFF894 >= 4u )
    byte_1FFFF894 = 0;
  result = (unsigned __int8)byte_1FFFF894;
  v400FF040 = v400FF040 & 0xFFFFFFF1 | (1 << (byte_1FFFF894 + 1)) ^ 0xE;// Port Data Output Register (GPIOB_PDOR)
  if ( !byte_1FFFF894 )
  {
    if ( timer - lastTimerCheck > 0x4E20 )
      controlBackLight(0);
    if ( !(v400FF010 & 0x20) )                  // Port Data Input Register (GPIOA_PDIR
      tempInputs |= 0x1000u;
    if ( !(v400FF0D0 << 31) )                   //  Port Data Input Register (GPIOD_PDIR) 
      tempInputs |= 0x10000u;
    if ( v400FF090 & 2 )                        //  Port Data Input Register (GPIOC_PDIR) 
      tempInputs |= 0x20000u;
    if ( SWC_ADC > (unsigned int)&byte_DA0[312] )
      tempInputs |= 0x40000u;
    if ( (unsigned int)SWC_ADC < 500 )
      tempInputs |= 0x100000u;
    result = tempInputs;
    if ( !(v400FF0D0 & 0x10) )                  // Port Data Input Register (GPIOD_PDIR)
    {
      result = tempInputs | 0x80000;
      tempInputs |= 0x80000u;
    }
    if ( result != inputStates )
    {
      if ( (unsigned int)counterMain >= 2 )
        *(_DWORD *)inputStates2 = inputStates;
      tempInputs = 0;
      counterMain = 0;
      inputStates = result;
      return result;
    }
    tempInputs = 0;
    result = counterMain + 1;
    counterMain = result;
    if ( (unsigned int)result < 2 )
      return result;
    byte_1FFFF896 = 1;
    if ( !factoryMode && (_BYTE)inputStates )
    {
      controlBackLight(1);
      lastTimerCheck = timer;
      result = counterMain - 2;
      if ( (unsigned int)(counterMain - 2) >= 0x400 )
      {
        if ( (unsigned int)result >= 0x800 )
        {
          if ( (counterMain - 2) << 26 )
            return result;
          if ( (unsigned int)result >= 0xC00 )
          {
            result = 8;
            goto LABEL_38;
          }
          result = ((unsigned int)(counterMain - 2050) >> 8) + 4;
        }
        else
        {
          if ( (counterMain - 2) << 25 )
            return result;
          result = ((unsigned int)(counterMain - 1026) >> 9) + 2;
        }
        if ( !result )
          return result;
      }
      else
      {
        result = (unsigned __int8)result;
        if ( (_BYTE)result )
          return result;
        result = 1;
      }
LABEL_38:
      if ( (unsigned __int16)inputStates == 2 )
      {
        v4 = (_BYTE *)(usedModelPtr + 10);
      }
      else
      {
        if ( (unsigned __int16)inputStates == 1 )
        {
          v4 = (_BYTE *)(usedModelPtr + 10);
          goto LABEL_47;
        }
        if ( (unsigned __int16)inputStates == 8 )
        {
          v4 = (_BYTE *)(usedModelPtr + 11);
        }
        else
        {
          if ( (unsigned __int16)inputStates == 4 )
          {
            v4 = (_BYTE *)(usedModelPtr + 11);
            goto LABEL_47;
          }
          if ( (unsigned __int16)inputStates == 32 )
          {
            v4 = (_BYTE *)(usedModelPtr + 12);
          }
          else
          {
            if ( (unsigned __int16)inputStates == 16 )
            {
              v4 = (_BYTE *)(usedModelPtr + 12);
              goto LABEL_47;
            }
            if ( (unsigned __int16)inputStates != 128 )
            {
              if ( (unsigned __int16)inputStates != 64 )
                return result;
              v4 = (_BYTE *)(usedModelPtr + 13);
LABEL_47:
              v5 = *v4;
              result += v5;
              if ( result < -120 )
              {
                result = -120;
                goto LABEL_66;
              }
              if ( result > 120 )
              {
                result = 120;
                goto LABEL_66;
              }
              if ( result )
              {
                if ( result <= 0 )
                {
                  if ( v5 <= 0 )
                    goto LABEL_66;
                }
                else if ( v5 >= 0 )
                {
LABEL_66:
                  if ( *v4 == result )
                    return result;
                  *v4 = result;
                  if ( result )
                  {
                    if ( result == -120 )
                    {
                      v6 = 100;
                      goto LABEL_71;
                    }
                    if ( result == 120 )
                    {
                      v6 = 100;
                    }
                    else
                    {
                      v6 = 20;
                      if ( result < 0 )
                      {
LABEL_71:
                        v7 = div_(330 * (result + 120) * (result + 120), 0x3840u);
                        return beep(v7 + 330, v6);
                      }
                    }
                  }
                  else
                  {
                    v6 = 200;
                  }
                  v8 = div_(659 * result * result, 0x3840u);
                  return beep(v8 + 659, v6);
                }
              }
              result = 0;
              counterMain = 2;
              goto LABEL_66;
            }
            v4 = (_BYTE *)(usedModelPtr + 13);
          }
        }
      }
      result = -result;
      goto LABEL_47;
    }
    if ( result != 2 )
    {
      if ( (unsigned __int16)inputStates == 1024 )
      {
        if ( result != 502 )
          return result;
        v9 = 22;
      }
      else if ( (unsigned __int16)inputStates == 2048 )
      {
        if ( result != 502 )
          return result;
        v9 = 25;
      }
      else
      {
        if ( byte_20000002 )
          return result;
        if ( (unsigned __int16)inputStates == 512 )
        {
          div_Other(result, 0x96u);
          if ( v17 )
            return result;
          v9 = 23;
        }
        else
        {
          if ( (unsigned __int16)inputStates != 256 )
            return result;
          div_Other(result, 0x96u);
          if ( v18 )
            return result;
          v9 = 24;
        }
      }
      return (int)sub_24D0(v9);
    }
    v10 = 0;
LABEL_87:
    if ( !inputStates2[0] && 1 << v10 == (unsigned __int16)inputStates )
    {
      sub_24D0(v10);
      goto LABEL_134;
    }
    if ( 1 << v10 == inputStates2[0] && !(_WORD)inputStates )
    {
      sub_24D0(v10 | 0x80);
      goto LABEL_134;
    }
    if ( (unsigned int)++v10 >= 0x10 )
    {
LABEL_134:
      v15 = 16;
      while ( 1 )
      {
        result = 1 << v15;
        if ( (1 << v15) & *(_DWORD *)inputStates2 )
          break;
        if ( result & inputStates )
        {
          v16 = v15;
LABEL_141:
          result = (int)sub_24D0(v16);
        }
LABEL_142:
        if ( (unsigned int)++v15 > 0x15 )
          return result;
      }
      if ( result & inputStates )
        goto LABEL_142;
      v16 = v15 | 0x80;
      goto LABEL_141;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( v10 == 10 )
          {
            if ( inputStates2[0] )
            {
              if ( inputStates2[0] == 1024 && !(_WORD)inputStates )
              {
                v11 = &byte_1FFFF894;
                if ( byte_1FFFF895 == 22 )
                {
                  v12 = -118;
                  goto LABEL_115;
                }
                LOBYTE(v10) = 10;
                goto LABEL_106;
              }
            }
            else if ( (unsigned __int16)inputStates == 1024 )
            {
              goto LABEL_134;
            }
            v10 = 11;
          }
          if ( v10 != 11 )
            break;
          if ( inputStates2[0] )
          {
            if ( inputStates2[0] == 2048 && !(_WORD)inputStates )
            {
              v13 = &byte_1FFFF894;
              if ( byte_1FFFF895 != 25 )
              {
                LOBYTE(v10) = 11;
                goto LABEL_106;
              }
              v14 = -117;
LABEL_125:
              v13[(_DWORD)byte_1] = v14;
              goto LABEL_134;
            }
          }
          else if ( (unsigned __int16)inputStates == 2048 )
          {
            goto LABEL_134;
          }
          v10 = 12;
        }
        if ( v10 != 9 )
          break;
LABEL_108:
        if ( !inputStates2[0] && 1 << v10 == (unsigned __int16)inputStates )
          goto LABEL_134;
        if ( 1 << v10 == inputStates2[0] && !(_WORD)inputStates )
        {
          v11 = &byte_1FFFF894;
          if ( byte_1FFFF895 == 23 )
          {
            v12 = v10 | 0x80;
LABEL_115:
            v11[(_DWORD)byte_1] = v12;
            goto LABEL_134;
          }
LABEL_106:
          sub_24D0(v10);
          goto LABEL_134;
        }
        ++v10;
      }
      if ( v10 != 8 )
        goto LABEL_87;
      if ( inputStates2[0] )
      {
        if ( inputStates2[0] == 256 )
        {
          if ( !(_WORD)inputStates )
          {
            v13 = &byte_1FFFF894;
            if ( byte_1FFFF895 != 24 )
            {
              LOBYTE(v10) = 8;
              goto LABEL_106;
            }
            v14 = -120;
            goto LABEL_125;
          }
          v10 = 9;
          goto LABEL_108;
        }
      }
      else if ( (unsigned __int16)inputStates == 256 )
      {
        goto LABEL_134;
      }
      v10 = 9;
    }
  }
  return result;
}
// 1FFFF894: using guessed type char byte_1FFFF894;
// 1FFFF895: using guessed type char byte_1FFFF895;
// 1FFFF896: using guessed type char byte_1FFFF896;
// 1FFFF897: using guessed type char byte_1FFFF897;
// 1FFFF898: using guessed type int tempInputs;
// 1FFFF89C: using guessed type int inputStates;
// 1FFFF8A4: using guessed type int counterMain;
// 1FFFF8B4: using guessed type int lastTimerCheck;
// 20000001: using guessed type char factoryMode;
// 20000002: using guessed type char byte_20000002;
// 2000002C: using guessed type int usedModelPtr;
// 20000F1C: using guessed type int SWC_ADC;

//----- (00002C00) --------------------------------------------------------
unsigned int configurePINS()
{
  unsigned int result; // r0@1
                                                // set all pins to 001 Alternative 1 (GPIO). 
  v40049014 = 256;                              // Pin Control Register n (PORTA_PCR5)
  v4004A040 = 256;                              // Pin Control Register n (PORTB_PCR16)
  v4004A044 = 256;                              // Pin Control Register n (PORTB_PCR17) 
  v4004A048 = 256;                              // Pin Control Register n (PORTB_PCR18
  v4004A04C = 256;                              // Pin Control Register n (PORTB_PCR19)
  v4004A004 = 256;                              // Pin Control Register n (PORTB_PCR1)
  v4004A008 = 256;                              // Pin Control Register n (PORTB_PCR2)
  v4004A00C = 256;                              // Pin Control Register n (PORTB_PCR3)
  v4004C000 = 256;                              // Pin Control Register n (PORTD_PCR0)
  v4004C010 = 256;                              // Pin Control Register n (PORTD_PCR4)
  v4004B004 = 256;                              // Pin Control Register n (PORTC_PCR1)
  v400FF094 &= 0xFFFFFFFD;                      // Port Data Direction Register (GPIOC_PDDR)
                                                // ?11111111111111111111111111111101?
                                                // PC1 - is input
  v400FF014 &= 0xFFFFFFDF;                      // Port Data Direction Register (GPIOA_PDDR
  v400FF054 &= 0xFFF0FFF1;                      // Port Data Direction Register (GPIOB_PDDR)
  v400FF0D4 = 2 * (v400FF0D4 >> 1);             // Port Data Direction Register (GPIOD_PDDR)
  v400FF054 |= 0xEu;                            // Port Data Direction Register (GPIOB_PDDR)
  v4004803C |= 0x800000u;                       // System Clock Gating Control Register 6 (SIM_SCGC6)
  v40037000 &= 0xFFFFFFFD;                      // PIT Module Control Register (PIT_MCR)
  v40037100 = &byte_1426[842];                  // Timer Load Value Register (PIT_LDVAL0)
  v40037108 |= 3u;                              // Timer Control Register (PIT_TCTRL0)
  vE000E414 = (vE000E414 & 0xFF00FFFF) + 0x800000;
  vE000E100 |= 0x400000u;
  dword_1FFFF8A8 = 0;
  dword_1FFFF8AC = 0;
  byte_1FFFF894 = 0;
  tempInputs = 0;
  inputStates = 0;
  *(_DWORD *)inputStates2 = 0;
  counterMain = 0;
  byte_1FFFF895 = 0;
  byte_1FFFF896 = 0;
  controlBackLight(1);
  result = timer;
  lastTimerCheck = timer;
  byte_1FFFF897 = 0;
  timer = 0;
  return result;
}
// 1FFFF894: using guessed type char byte_1FFFF894;
// 1FFFF895: using guessed type char byte_1FFFF895;
// 1FFFF896: using guessed type char byte_1FFFF896;
// 1FFFF897: using guessed type char byte_1FFFF897;
// 1FFFF898: using guessed type int tempInputs;
// 1FFFF89C: using guessed type int inputStates;
// 1FFFF8A4: using guessed type int counterMain;
// 1FFFF8A8: using guessed type int dword_1FFFF8A8;
// 1FFFF8AC: using guessed type int dword_1FFFF8AC;
// 1FFFF8B4: using guessed type int lastTimerCheck;

//----- (00002D00) --------------------------------------------------------
signed int SwashAFRPage()
{
  unsigned int v0; // r5@1
  int v1; // r0@2
  signed int v3; // r0@14
  signed int v4; // r0@19
  signed int v5; // r1@22
  signed int v6; // r0@28
  signed int v7; // r0@31
  signed int v8; // r1@34
  int v9; // [sp+0h] [bp-20h]@2
  char v10; // [sp+4h] [bp-1Ch]@2

  v0 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            callSetupDMAandSend();
            displayPageHeader("Swash AFR");
            displayTextFromRight((_DWORD *)"Swash type", 84, 16, 0);
            displayTextAt(dword_200000D4[*(_BYTE *)(usedModelPtr + 9) - 3], 92, 16, 0);
            displayTextAt("Aileron", 12, 32, 0);
            intToString(*(_BYTE *)(usedModelPtr + 41), (char *)&v9, 4u);
            v10 = 0;
            displayTextAt(&v9, 84, 32, 0);
            displayTextAt("Elevator", 12, 40, 0);
            intToString(*(_BYTE *)(usedModelPtr + 42), (char *)&v9, 4u);
            displayTextAt(&v9, 84, 40, 0);
            displayTextAt("Pitch", 12, 48, 0);
            intToString(*(_BYTE *)(usedModelPtr + 43), (char *)&v9, 4u);
            displayTextAt(&v9, 84, 48, 0);
            displayGFX((int)&arrow_gfx, 4, 8 * v0 + 32);
            LCD_updateCALL();
            v1 = getKeyCode();
            if ( v1 != 8 && v1 != 24 )
              break;
            if ( v0 )
            {
              if ( v0 == 1 )
              {
                v5 = *(_BYTE *)(usedModelPtr + 42);
                if ( v5 > -100 )
                {
                  *(_BYTE *)(usedModelPtr + 42) = v5 - 1;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_17;
                }
              }
              else if ( v0 == 2 )
              {
                v3 = *(_BYTE *)(usedModelPtr + 43);
                if ( v3 > -100 )
                {
                  *(_BYTE *)(usedModelPtr + 43) = v3 - 1;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_17;
                }
              }
            }
            else
            {
              v4 = *(_BYTE *)(usedModelPtr + 41);
              if ( v4 > -100 )
              {
                *(_BYTE *)(usedModelPtr + 41) = v4 - 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_17;
              }
            }
          }
          if ( v1 != 9 && v1 != 23 )
            break;
          if ( v0 )
          {
            if ( v0 == 1 )
            {
              v8 = *(_BYTE *)(usedModelPtr + 42);
              if ( v8 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 42) = v8 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_17;
              }
            }
            else if ( v0 == 2 )
            {
              v6 = *(_BYTE *)(usedModelPtr + 43);
              if ( v6 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 43) = v6 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_17;
              }
            }
          }
          else
          {
            v7 = *(_BYTE *)(usedModelPtr + 41);
            if ( v7 < 100 )
            {
              *(_BYTE *)(usedModelPtr + 41) = v7 + 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_17;
            }
          }
        }
        if ( v1 != 22 )
          break;
        if ( v0 )
        {
          if ( v0 == 1 )
          {
            *(_BYTE *)(usedModelPtr + 42) = 50;
          }
          else if ( v0 == 2 )
          {
            *(_BYTE *)(usedModelPtr + 43) = 50;
          }
        }
        else
        {
          *(_BYTE *)(usedModelPtr + 41) = 50;
        }
        if ( (unsigned int)sub_9BC0() >= 2 )
        {
LABEL_17:
          beep(784, 15);
          beep(0, 15);
        }
      }
      if ( v1 != 10 )
        break;
      if ( v0 < 2 )
        v0 = (unsigned __int8)(v0 + 1);
      else
        v0 = 0;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_17;
    }
    if ( v1 == 25 )
      return 1;
    if ( v1 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00002F30) --------------------------------------------------------
void __fastcall ChooseSensors(int a1, int a2, int a3, int a4, int a5)
{
  int activeSens; // r1@1
  int nextSensorOffset; // r3@1
  char sensorsConfig; // [sp+D0h] [bp-20h]@1

  copy6Bytes((int)&sensorsConfig, usedModelPtr + 129);
  activeSens = activeSensors;
  nextSensorOffset = 8 * activeSensors;         // this is wrong
  sensorsArrayInRam[nextSensorOffset] = -1;
  sensorsArrayInRam[nextSensorOffset + 1] = 0;
  if ( activeSens )
    JUMPOUT(unk_2F5E);
  callSetupDMAandSend();
  displayPageHeader("Choose sensors");
  JUMPOUT(unk_2F94);
}
// 20000024: using guessed type int activeSensors;
// 2000002C: using guessed type int usedModelPtr;

//----- (000031B8) --------------------------------------------------------
signed int DualRateExp()
{
  signed int v0; // r5@1
  signed int v1; // r6@3
  const char *v2; // r0@3
  int v3; // r6@4
  int v4; // r7@4
  unsigned int v5; // r4@4
  unsigned int v6; // r0@6
  unsigned int v7; // r0@6
  int v8; // r6@6
  int v9; // r0@9
  int v11; // r0@20
  int v12; // r1@28
  signed int v13; // r0@28
  char v14; // cf@29
  int v15; // r0@39
  int v16; // r0@45
  signed int v17; // r1@45
  int v18; // r1@56
  unsigned int v19; // r0@56
  unsigned int v20; // r0@61
  unsigned int v21; // r0@63
  char text; // [sp+4h] [bp-2Ch]@4
  char v23; // [sp+7h] [bp-29h]@4
  char v24; // [sp+8h] [bp-28h]@4
  unsigned int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@4
  int v27; // [sp+14h] [bp-1Ch]@4

  v0 = 0;
  v25 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( getInputStates() & (1 << *(_BYTE *)(usedModelPtr + 14)) )
            {
              v1 = 1;
              callSetupDMAandSend();
              displayPageHeader("Dual rate/exp.");
              v2 = "Sport";
            }
            else
            {
              v1 = 0;
              callSetupDMAandSend();
              displayPageHeader("Dual rate/exp.");
              v2 = "Normal";
            }
            displayTextAt(v2, 8, 20, 0);
            byte_20000007 = v0 + 49;
            displayTextAt(&byte_20000005, 8, 28, 0);
            displayTextAt("Rate", 8, 36, 0);
            v3 = 4 * v1;
            v26 = v3;
            intToString(*(_BYTE *)(v3 + usedModelPtr + v0 + 15), &text, 3u);
            v23 = 0;
            displayTextAt(&text, 48, 36, 0);
            displayTextAt("Exp", 8, 44, 0);
            intToString(-*(_BYTE *)(v3 + usedModelPtr + v0 + 23), &text, 4u);
            v24 = 0;
            displayTextAt(&text, 40, 44, 0);
            displayGFX((int)&arrow_gfx, 0, 8 * v25 + 28);
            sub_4E8C(73, 8, 127, 8, 0);
            sub_4E8C(127, 8, 127, 62, 0);
            sub_4E8C(73, 60, 127, 60, 0);
            sub_4E8C(75, 8, 75, 62, 0);
            sub_4E8C(73, 34, 127, 34, 0);
            sub_4E8C(101, 8, 101, 62, 0);
            getGFX(74, 21, 0);
            getGFX(74, 47, 0);
            getGFX(88, 61, 0);
            getGFX(114, 61, 0);
            v4 = 0;
            v5 = 0;
            v27 = 98 * *(_BYTE *)(v3 + usedModelPtr + v0 + 23) + 0x4000;
            do
            {
              div_Other(v5 << 15, 0x1Au);
              v7 = dualRateExpFunction(v6, v27);
              v8 = div__0(26 * v7 * *(_BYTE *)(v26 + usedModelPtr + v0 + 15), 3276800);
              if ( v5 )
              {
                sub_4E8C(102 - v5, v4 + 34, 101 - v5, v8 + 34, 0);
                sub_4E8C(v5 + 100, 34 - v4, v5 + 101, 34 - v8, 0);
              }
              ++v5;
              v4 = v8;
            }
            while ( v5 <= 0x1A );
            LCD_updateCALL();
            v9 = getKeyCode();
            if ( v9 != 10 )
              break;
            if ( v25 < 2 )
              v11 = v25 + 1;
            else
              v11 = 0;
            v25 = v11;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_23;
          }
          if ( v9 != 8 && v9 != 24 )
            break;
          if ( v25 )
          {
            if ( v25 == 1 )
            {
              v15 = v26 + usedModelPtr + v0;
              if ( *(_BYTE *)(v15 + 15) )
              {
                --*(_BYTE *)(v15 + 15);
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_23;
              }
            }
            else if ( v25 == 2 )
            {
              v12 = v26 + usedModelPtr + v0;
              v13 = *(_BYTE *)(v12 + 23);
              if ( v13 <= 98 )
              {
                *(_BYTE *)(v12 + 23) = v13 + 2;
                v14 = (unsigned int)sub_9BC0() >= 2;
                goto LABEL_30;
              }
            }
          }
          else if ( v0 == 3 )
          {
            v0 = 1;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_23;
          }
          else if ( v0 == 1 )
          {
            v0 = 0;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_23;
          }
        }
        if ( v9 != 9 && v9 != 23 )
          break;
        if ( v25 )
        {
          if ( v25 == 1 )
          {
            v18 = v26 + usedModelPtr + v0;
            v19 = *(_BYTE *)(v18 + 15);
            if ( v19 < 0x64 )
            {
              *(_BYTE *)(v18 + 15) = v19 + 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_23;
            }
          }
          else if ( v25 == 2 )
          {
            v16 = v26 + usedModelPtr + v0;
            v17 = *(_BYTE *)(v16 + 23);
            if ( v17 >= -98 )
            {
              *(_BYTE *)(v16 + 23) = v17 - 2;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_23;
            }
          }
        }
        else if ( v0 )
        {
          if ( v0 == 1 )
          {
            v0 = 3;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_23;
          }
        }
        else
        {
          v0 = 1;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_23;
        }
      }
      if ( v9 != 22 )
        break;
      if ( v25 == 1 )
      {
        *(_BYTE *)(v26 + usedModelPtr + v0 + 15) = *((_BYTE *)&HardFault + v0 + 53628);
        v21 = sub_9BC0();
        v14 = v21 >= 2;
        if ( v21 < 2 )
          goto LABEL_30;
LABEL_23:
        beep(784, 15);
        beep(0, 15);
      }
      else if ( v25 == 2 )
      {
        *(_BYTE *)(v26 + usedModelPtr + v0 + 23) = *((_BYTE *)&dword_14 + v0 + 53628);
        v20 = sub_9BC0();
        v14 = v20 >= 2;
        if ( v20 >= 2 )
          goto LABEL_23;
LABEL_30:
        if ( v14 )
          goto LABEL_23;
      }
    }
    if ( v9 == 25 )
      return 1;
    if ( v9 == 11 )
      return 0;
  }
}
// C: using guessed type int HardFault;
// 14: using guessed type int dword_14;
// 20000005: using guessed type char byte_20000005;
// 20000007: using guessed type char byte_20000007;
// 2000002C: using guessed type int usedModelPtr;

//----- (00003524) --------------------------------------------------------
int DisplayChannels()
{
  unsigned int v0; // r6@1
  int v1; // r5@2
  int v2; // r0@2
  int v3; // r5@3
  int v4; // r2@3
  int v5; // r0@7
  int result; // r0@14

  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          do
          {
            callSetupDMAandSend();
            v0 = 0;
            do
            {
              displayGFX((int)&unk_E7A8 + 12 * v0, 2, 6 * v0 + 2);
              v1 = 6 * v0 + 6;
              drawLine(10, 6 * v0 + 2, 126, v1, 0);
              sub_4E8C(21, 6 * v0 + 2, 21, v1, 0);
              sub_4E8C(68, 6 * v0 + 2, 68, v1, 0);
              sub_4E8C(115, 6 * v0 + 2, 115, v1, 0);
              v2 = div__0(47 * dword_1FFFFDE0[v0], (signed int)dword_2710) + 68;
              if ( dword_1FFFFDE0[v0] >= 0 )
              {
                v3 = 68;
                v4 = v2;
              }
              else
              {
                v3 = v2;
                v4 = 68;
              }
              fillRegion(v3, 6 * v0 + 3, v4, 6 * v0 + 5, 0);
              ++v0;
            }
            while ( v0 < 0xA );
            LCD_updateCALL();
          }
          while ( sub_2574() == 255 );
          v5 = getKeyCode();
          if ( v5 != 9 && v5 != 23 )
            break;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_16;
        }
        if ( v5 != 8 && v5 != 24 )
          break;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_16;
      }
      if ( v5 != 25 )
        break;
      dword_20000150 = timer;
      byte_20000145[0] ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
LABEL_16:
        beep(784, 15);
        beep(0, 15);
      }
    }
  }
  while ( v5 != 10 && v5 != 11 );
  result = 0;
  byte_20000145[0] = 0;
  return result;
}
// 2710: using guessed type int dword_2710[28];
// 20000150: using guessed type int dword_20000150;

//----- (00003658) --------------------------------------------------------
int FirmwareVerPAge()
{
  int v0; // r0@2

  callSetupDMAandSend();
  displayPageHeader("Firmware ver.");
  displaySmallTextAt(&unk_EE89, 1, 12);
  displayTextAt2("FLY SKY FS-i6", 64, 20, 0);
  displayTextAt2("1.1 25-NOV-2014", 64, 28, 0);
  displaySmallTextAt(&unk_EE9F, 1, 40);
  displayTextAt2(&unk_EEB5, 64, 48, 0);
  displayTextAt2(&unk_EEC2, 64, 56, 0);
  LCD_updateCALL();
  do
    v0 = getKeyCode();
  while ( v0 != 10 && v0 != 25 && v0 != 11 );
  return 0;
}

//----- (000036E0) --------------------------------------------------------
int SensorsList()
{
  unsigned int v0; // r6@1
  unsigned int v1; // r4@2
  unsigned int v2; // r0@2
  unsigned int v3; // r0@2
  unsigned int v4; // r5@9
  int v5; // r0@10
  char *v6; // r7@11
  int v7; // r0@11
  int v8; // r2@11
  int v9; // r3@11
  const char *v10; // r0@16
  unsigned int lastSend; // r7@18
  int v12; // r0@20
  unsigned int v14; // [sp+8h] [bp-210h]@2
  unsigned int v15; // [sp+14h] [bp-204h]@2
  char v16[256]; // [sp+38h] [bp-1E0h]@9
  char text; // [sp+138h] [bp-E0h]@11
  __int16 v18; // [sp+16Ah] [bp-AEh]@11
  char v19; // [sp+19Ch] [bp-7Ch]@11

  byte_20000002 = 1;
  v0 = 0;
  do
  {
LABEL_2:
    callSetupDMAandSend();
    displayPageHeader("Sensors list");
    sub_A158();
    v1 = activeSensors;
    div_Other(activeSensors + 4, 5u);
    v14 = v2;
    v3 = v2 - 1;
    v15 = v3;
    if ( v0 > v3 )
      v0 = v14 - 1;
    if ( v1 > 5 )
    {
      if ( v0 == v3 )
        v1 -= 5 * v0;
      else
        v1 = 5;
    }
    else
    {
      v0 = 0;
    }
    strcpy(v16, sensorsArrayInRam, 0x100u);
    sub_A190();
    v4 = 0;
    if ( v1 )
    {
      v5 = 5 * v0;
LABEL_11:
      v6 = &v16[8 * (v5 + v4)];
      formatSensorData((unsigned __int8)*v6, (unsigned __int8)v6[1], &v19);
      GetSensorName((unsigned __int8)*v6);
      sub_1C64(&text, v7);
      v8 = (unsigned __int8)v6[1];
      sprintf((int)&v18, "%u", v9);
      displayTextAt(&text, 0, 8 * v4 + 12, 0);
      displayTextAt(&v18, 50, 8 * v4 + 12, 0);
      displayTextAt(&v19, 66, 8 * v4 + 12, 0);
      while ( ++v4 < v1 )
      {
        if ( v4 < 0xF )
        {
          v5 = 5 * v0;
          goto LABEL_11;
        }
      }
    }
    if ( v0 >= v15 )
      v10 = "   ";
    else
      v10 = "==>";
    displayTextAt(v10, 96, 56, 0);
    LCD_updateCALL();
    lastSend = timer;
  }
  while ( timer - timer >= 0x3E8 );
  while ( 1 )
  {
    if ( sub_2574() == 255 )
      goto LABEL_36;
    v12 = getKeyCode();
    if ( v12 == 9 )
    {
      if ( !v0 )
        goto LABEL_36;
      if ( --v0 > v14 )
        v0 = v14;
      if ( (unsigned int)sub_9BC0() < 2 )
        goto LABEL_36;
LABEL_33:
      beep(784, 15);
      beep(0, 15);
      goto LABEL_36;
    }
    if ( v12 != 8 )
      break;
    if ( v0 >= v15 )
    {
      if ( v0 <= v14 )
        goto LABEL_36;
      v0 = v14;
      if ( (unsigned int)sub_9BC0() < 2 )
        goto LABEL_36;
      goto LABEL_33;
    }
    ++v0;
    if ( (unsigned int)sub_9BC0() >= 2 )
      goto LABEL_33;
LABEL_36:
    if ( timer - lastSend >= 0x3E8 )
      goto LABEL_2;
  }
  if ( v12 != 25 && v12 != 10 && v12 != 11 )
    goto LABEL_36;
  byte_20000002 = 0;
  return 0;
}
// 20000002: using guessed type char byte_20000002;
// 20000024: using guessed type int activeSensors;
// 36E0: using guessed type char var_1E0[256];

//----- (00003898) --------------------------------------------------------
signed int ElevonPage()
{
  int v0; // r0@3
  unsigned int v1; // r5@7
  _BYTE *v2; // r0@9
  int v3; // r1@12
  const char *v4; // r0@12
  int v5; // r0@14
  signed int v7; // r0@25
  signed int v8; // r1@31
  signed int v9; // r0@36
  signed int v10; // r0@41

  if ( !(*(_BYTE *)(usedModelPtr + 55) & 2) )
  {
    v1 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Elevon");
        displayTextAt("Elevon", 28, 16, 0);
        v2 = (_BYTE *)(*(_BYTE *)(usedModelPtr + 55) & 4 ? 51831 : "Off");
        displayTextAt(v2, 92, 16, 0);
        displayTextAt(&unk_3AD8, 28, 24, 0);
        intToString(*(_BYTE *)(usedModelPtr + 74), a100_1, 4u);
        displayTextAt(a100_1, 60, 24, 0);
        displayTextAt(&unk_3AE0, 28, 32, 0);
        intToString(*(_BYTE *)(usedModelPtr + 75), a100_1, 4u);
        displayTextAt(a100_1, 60, 32, 0);
        displayGFX((int)&arrow_gfx, 20, 8 * v1 + 16);
        if ( *(_BYTE *)(usedModelPtr + 55) & 4 )
        {
          displayTextAt("CH1 <= CH2+CH1", 8, 48, 0);
          v3 = 8;
          v4 = "CH2 <= CH2-CH1";
        }
        else
        {
          displayTextAt("CH1 <= CH1", 24, 48, 0);
          v3 = 24;
          v4 = "CH2 <= CH2";
        }
        displayTextAt(v4, v3, 56, 0);
        LCD_updateCALL();
        v5 = getKeyCode();
        if ( v5 != 8 && v5 != 24 )
          break;
        if ( v1 )
        {
          if ( v1 == 1 )
          {
            v8 = *(_BYTE *)(usedModelPtr + 74);
            if ( v8 > -100 )
            {
              *(_BYTE *)(usedModelPtr + 74) = v8 - 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_54;
            }
          }
          else
          {
            v7 = *(_BYTE *)(usedModelPtr + 75);
            if ( v7 > -100 )
            {
              *(_BYTE *)(usedModelPtr + 75) = v7 - 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_54;
            }
          }
        }
        else
        {
          *(_BYTE *)(usedModelPtr + 55) ^= 4u;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_54;
        }
      }
      switch ( v5 )
      {
        case 9:
        case 23:
          if ( v1 )
          {
            if ( v1 == 1 )
            {
              v10 = *(_BYTE *)(usedModelPtr + 74);
              if ( v10 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 74) = v10 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_54;
              }
            }
            else
            {
              v9 = *(_BYTE *)(usedModelPtr + 75);
              if ( v9 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 75) = v9 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_54;
              }
            }
          }
          else
          {
            *(_BYTE *)(usedModelPtr + 55) ^= 4u;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_54;
          }
          break;
        case 22:
          if ( v1 == 1 )
          {
            *(_BYTE *)(usedModelPtr + 74) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_54;
          }
          else if ( v1 == 2 )
          {
            *(_BYTE *)(usedModelPtr + 75) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_54;
          }
          break;
        case 10:
          if ( v1 < 2 )
            ++v1;
          else
            v1 = 0;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_54:
            beep(784, 15);
            beep(0, 15);
          }
          break;
        default:
          if ( v5 == 25 )
            return 1;
          if ( v5 == 11 )
            return 0;
          break;
      }
    }
  }
  callSetupDMAandSend();
  displayPageHeader("Elevon");
  displayTextAt2("V tail enabled", 64, 32, 0);
  LCD_updateCALL();
  do
    v0 = getKeyCode();
  while ( v0 != 10 && v0 != 25 && v0 != 11 );
  return 0;
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00003B20) --------------------------------------------------------
signed int endpointsPage()
{
  unsigned int v0; // r5@1
  unsigned int v1; // r4@2
  unsigned int v2; // r4@4
  int v3; // r1@7
  int v4; // r0@14
  _BYTE *v5; // r1@15
  unsigned int v7; // r0@26
  int v8; // [sp+0h] [bp-38h]@1
  int v9; // [sp+4h] [bp-34h]@1
  char targetText[4]; // [sp+Ch] [bp-2Ch]@1
  int v11; // [sp+10h] [bp-28h]@1
  int v12; // [sp+14h] [bp-24h]@1

  v11 = 808464672;
  v12 = 37;
  *(_DWORD *)targetText = 623915057;
  v0 = 0;
  v9 = 0;
  v8 = 3237955;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            do
            {
              callSetupDMAandSend();
              displayPageHeader("End points");
              v1 = 0;
              do
              {
                BYTE2(v8) = v1 + 49;
                displayTextAt(&v8, 12, 8 * v1++ + 16, 0);
              }
              while ( v1 < 6 );
              v2 = 0;
              do
              {
                intToString(*(_BYTE *)(2 * v2 + usedModelPtr + 82), targetText, 3u);
                intToString(*(_BYTE *)(2 * v2 + usedModelPtr + 83), (char *)&v11 + 1, 3u);
                displayTextAt(targetText, 44, 8 * v2++ + 16, 0);
              }
              while ( v2 < 6 );
              if ( v0 << 31 )
                v3 = 76;
              else
                v3 = 36;
              displayGFX((int)&arrow_gfx, v3, 8 * (v0 >> 1) + 16);
              LCD_updateCALL();
              if ( dword_1FFFFD7C[(v0 >> 1) + 2] < -5000 )
                v0 = 2 * (v0 >> 1);
              if ( dword_1FFFFD7C[(v0 >> 1) + 2] > (signed int)&byte_DA0[1512] )
                v0 |= 1u;
            }
            while ( sub_2574() == 255 );
            v4 = getKeyCode();
            v5 = (_BYTE *)(v0 << 31 ? 2 * (v0 >> 1) + usedModelPtr + 83 : 2 * (v0 >> 1) + usedModelPtr + 82);
            if ( v4 != 9 && v4 != 23 )
              break;
            v7 = *v5;
            if ( v7 < 0x78 )
            {
              *v5 = v7 + 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_28;
            }
          }
          if ( v4 != 8 && v4 != 24 )
            break;
          if ( *v5 )
          {
            --*v5;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_28;
          }
        }
        if ( v4 != 22 )
          break;
        *v5 = 100;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_28;
      }
      if ( v4 != 10 )
        break;
      if ( v0 < 0xA )
        v0 += 2;
      else
        v0 -= 10;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
LABEL_28:
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v4 == 25 )
      return 1;
    if ( v4 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00003CB8) --------------------------------------------------------
int __fastcall i2cMethod(_BYTE *a1, int a2, int a3, char a4, int a5)
{
  _BYTE *v5; // r6@1
  int result; // r0@9

  v5 = a1;
  dword_20000120 = (int)a1;
  dword_20000124 = a2;
  byte_20000115 = a4;
  dword_2000011C = a5;
  byte_20000116 = 1;
  if ( a3 )
  {
    byte_20000114 = 1;
LABEL_8:
    dword_20000128 = 1;
    goto LABEL_9;
  }
  while ( v40066003 & 0x20 )                    // i2c status bussy
    sendPacketWithTimer();
  v40066002 |= 0x30u;
  if ( !(*v5 << 31) )
  {
    byte_20000114 = 1;
    ++dword_20000124;
    goto LABEL_8;
  }
  byte_20000114 = 2;
  dword_20000128 = 0;
LABEL_9:
  v40066002 &= 0xF7u;
  result = *v5;
  v40066004 = *v5;
  return result;
}
// 20000114: using guessed type char byte_20000114;
// 20000115: using guessed type char byte_20000115;
// 20000116: using guessed type char byte_20000116;
// 2000011C: using guessed type int dword_2000011C;
// 20000120: using guessed type int dword_20000120;
// 20000124: using guessed type int dword_20000124;
// 20000128: using guessed type int dword_20000128;

//----- (00003D20) --------------------------------------------------------
signed int kindOfInit2()
{
  signed int result; // r0@1

  byte_20000114 = 0;
  v40048034 |= 0x40u;                           // System Clock Gating Control Register 4 (SIM_SCGC4) 
  v4004D060 = 0x500;                            // Pin Control Register n (PORTE_PCR24)
  v4004D064 = 0x500;                            // Pin Control Register n (PORTE_PCR25
  v40066001 = 0x12;                             //  I2C Frequency Divider register (I2C0_F)
  v40066002 = -64;                              // I2C Control Register 1 (I2C0_C1)
  vE000E408 = (vE000E408 >> 8 << 8) + 64;
  result = -536813312;
  vE000E100 |= 0x100u;
  return result;
}
// 20000114: using guessed type char byte_20000114;

//----- (00003D74) --------------------------------------------------------
signed int __fastcall flashMethod(int a1, int a2, int a3)
{
  int v3; // r12@1
  signed int result; // r0@5

  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v40020004 = a1 | 0x6000000;               // Flash Common Command Object Registers (FTFA_FCCOB3)
      v40020008 = *(_BYTE *)a3 | (*(_BYTE *)(a3 + 1) << 8) | (*(_BYTE *)(a3 + 2) << 16) | (*(_BYTE *)(a3 + 3) << 24);// Flash Common Command Object Registers (FTFA_FCCOB7)
      v40020000 = 0x80u;                        // Flash Status Register (FTFA_FSTAT) 
      while ( !(v40020000 & 0x80) )
        ;
      if ( v40020000 & 0x71 )
        return 2;
      v40020004 = a1 | 0x2000000;
      v40020008 = 0x1000000;
      v4002000C = *(_BYTE *)a3 | (*(_BYTE *)(a3 + 1) << 8) | (*(_BYTE *)(a3 + 2) << 16) | (*(_BYTE *)(a3 + 3) << 24);
      v40020000 = 0x80u;
      while ( !(v40020000 & 0x80) )
        ;
      if ( v40020000 & 0x71 )
        break;
      a3 += 4;
      a1 += 4;
      v3 -= 4;
      if ( !v3 )
        goto LABEL_11;
    }
    result = 3;
  }
  else
  {
LABEL_11:
    result = 0;
  }
  return result;
}

//----- (00003E10) --------------------------------------------------------
signed int __fastcall readEeprom(int target, __int16 offset, int len)
{
  _BYTE *targetPTR; // r5@1
  signed int result; // r0@3
  int length; // [sp+10h] [bp-18h]@1

  length = len;
  targetPTR = (_BYTE *)target;
  *(_BYTE *)target = 0xA0u;
  *(_BYTE *)(target + 1) = HIBYTE(offset);
  *(_BYTE *)(target + 2) = offset;
  byte_20000117 = 0;
  i2cMethod((_BYTE *)target, 2, 0, 0, (int)sub_25A4);
  while ( !byte_20000117 )
    sendPacketWithTimer();
  result = (unsigned __int8)byte_20000118;
  if ( byte_20000118 )
  {
    byte_20000117 = 0;
    *targetPTR = 0xA1u;
    i2cMethod(targetPTR, length, 0, 0, (int)sub_25A4);
    while ( !byte_20000117 )
      sendPacketWithTimer();
    result = (unsigned __int8)byte_20000118;
    if ( byte_20000118 )
      result = 1;
  }
  return result;
}
// 20000117: using guessed type char byte_20000117;
// 20000118: using guessed type char byte_20000118;

//----- (00003E84) --------------------------------------------------------
signed int __fastcall saveEepromData(_BYTE *a1, int a2, unsigned int a3)
{
  int v3; // r5@1
  unsigned int v4; // r6@2
  signed int result; // r0@6
  int v6; // r7@10
  unsigned __int8 v7; // [sp+4h] [bp-24h]@4
  char v8; // [sp+5h] [bp-23h]@4
  char v9; // [sp+6h] [bp-22h]@4
  _BYTE *v10; // [sp+8h] [bp-20h]@1
  int v11; // [sp+Ch] [bp-1Ch]@1
  unsigned int v12; // [sp+10h] [bp-18h]@1

  v10 = a1;
  v11 = a2;
  v12 = a3;
  v3 = a2;
  if ( !a3 )
    return 1;
  while ( 2 )
  {
    v4 = ((unsigned int)(v3 + 64) >> 6 << 6) - v3;
    if ( v4 > v12 )
      v4 = v12;
    v7 = 0xA0u;
    v8 = BYTE1(v3);
    v9 = v3;
    byte_20000117 = 0;
    i2cMethod(&v7, 2, 0, 1, (int)sub_25A4);
    while ( !byte_20000117 )
      sendPacketWithTimer();
    result = (unsigned __int8)byte_20000118;
    if ( byte_20000118 )
    {
      byte_20000117 = 0;
      i2cMethod(v10, v4, 1, 0, (int)sub_25A4);
      while ( !byte_20000117 )
        sendPacketWithTimer();
      result = (unsigned __int8)byte_20000118;
      if ( byte_20000118 )
      {
        v6 = vE000E018 << 8;
        while ( 1 )
        {
          byte_20000117 = 0;
          i2cMethod(&v7, 2, 0, 0, (int)sub_25A4);
          while ( !byte_20000117 )
            sendPacketWithTimer();
          if ( byte_20000118 )
            break;
          if ( (unsigned int)(v6 - (vE000E018 << 8)) > 3840000 )
            return 0;
          sendPacketWithTimer();
        }
        v3 += v4;
        v10 += v4;
        v12 -= v4;
        sendPacketWithTimer();
        if ( v12 )
          continue;
        return 1;
      }
    }
    break;
  }
  return result;
}
// 20000117: using guessed type char byte_20000117;
// 20000118: using guessed type char byte_20000118;

//----- (00003F7C) --------------------------------------------------------
signed int FactoryReset()
{
  int v0; // r0@2
  signed int result; // r0@4
  unsigned int v2; // r6@5
  int v3; // r4@6
  int v4; // [sp+0h] [bp-58h]@5

  callSetupDMAandSend();
  displayPageHeader("Factory reset");
  displayTextAt2("This will reset", 64, 16, 0);
  displayTextAt2("all parameters", 64, 24, 0);
  displayTextAt2("to their", 64, 32, 0);
  displayTextAt2("factory default", 64, 40, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  displayTextAt2("to proceed", 64, 56, 0);
  LCD_updateCALL();
  do
  {
    v0 = getKeyCode();
    if ( v0 == 11 )
      return 0;
  }
  while ( v0 != 10 );
  result = sub_23F4();
  if ( result )
  {
    setFactVal();
    usedModelPtr = (int)&rxsettings[146 * (unsigned __int8)currentModel + 10];
    setupDMA(&v4, 0x40u, 0xFFu);
    someSPImethod();
    v2 = 0;
    do
    {
      v3 = (v2 << 12) + 64;
      do
      {
        saveEepromData(&v4, v3, 64u);
        v3 += 64;
      }
      while ( v3 - ((v2 << 12) + 64) < (unsigned int)&dword_B74 );
      someSPImethod();
      ++v2;
    }
    while ( v2 < 4 );
    result = 1;
  }
  return result;
}
// B74: using guessed type int dword_B74;
// 2000002C: using guessed type int usedModelPtr;
// 200002AD: using guessed type char currentModel;

//----- (00004068) --------------------------------------------------------
signed int FailsafeMEnu()
{
  signed int v0; // r7@2
  unsigned int channel; // r4@2
  int v2; // r0@3
  signed int v3; // r2@4
  _BYTE *v4; // r0@4
  signed int v5; // r6@5
  int v6; // r0@7
  char v7; // r1@7
  char v8; // r6@7
  char v9; // r1@7
  int v10; // r0@9
  char v11; // r1@9
  char v12; // r6@9
  char v13; // r1@9
  char v14; // r1@10
  int v15; // r0@14
  char v16; // r1@14
  char v17; // r6@14
  char v18; // r1@14
  char v19; // r1@15
  int v20; // r0@18
  signed int result; // r0@27
  char *v22; // r2@39
  char v23; // r3^1@40
  char *v24; // r2@41
  char v25; // r3^1@42
  char *v26; // r2@43
  char v27; // r3^1@44
  char *v28; // r2@45
  char v29; // r3^1@46
  char *v30; // r2@49
  char v31; // r3^1@50
  char *v32; // r0@51
  char v33; // r1^1@52
  int v34; // [sp+0h] [bp-40h]@3
  int v35; // [sp+4h] [bp-3Ch]@3
  int v36; // [sp+8h] [bp-38h]@3
  int v37; // [sp+Ch] [bp-34h]@1
  _BYTE text[4]; // [sp+10h] [bp-30h]@5
  int v39; // [sp+14h] [bp-2Ch]@5

  v37 = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        while ( 2 )
        {
          while ( 2 )
          {
            callSetupDMAandSend();
            displayPageHeader("Failsafe");
            v0 = 8;
            channel = 0;
            do
            {
              v34 = 'nahC';
              v36 = 0;
              v35 = '1len';
              BYTE3(v35) = channel + 49;
              displayTextAt(&v34, 8, v0, 0);
              v2 = (signed __int16)((unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 116]
                                                     + 2 * channel) << 8) | (unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 115]
                                                                                             + 2 * channel);
              if ( v2 == 0x7FFF )
              {
                v3 = v0;
                v4 = &unk_43BC;
                goto LABEL_17;
              }
              *(_DWORD *)text = '001-';
              v39 = 37;
              v5 = (signed __int16)div__0(v2, 100);
              if ( v5 >= 0 )
              {
                if ( (unsigned int)(v5 + 99) < 0xC7 )
                {
                  if ( (unsigned int)(v5 + 9) < 0x13 )
                  {
                    div_(v5, 0xAu);
                    text[0] = v19 + 48;
                    text[1] = '%';
                    text[2] = 0;
                  }
                  else
                  {
                    v15 = div_(v5, 0xAu);
                    v17 = v16;
                    div_(v15, 0xAu);
                    text[0] = v18 + '0';
                    text[1] = v17 + '0';
                    text[2] = '%';
                    text[3] = 0;
                  }
                  goto LABEL_16;
                }
                text[0] = div_(v5, 0x64u) + 48;
LABEL_9:
                v10 = div_(v5, 0xAu);
                v12 = v11;
                div_(v10, 0xAu);
                text[1] = v13 + 48;
                text[2] = v12 + 48;
                text[3] = 37;
                LOBYTE(v39) = 0;
                goto LABEL_16;
              }
              text[0] = 45;
              v5 = (signed __int16)-(signed __int16)v5;
              if ( (unsigned int)(v5 + 99) < 0xC7 )
              {
                if ( (unsigned int)(v5 + 9) < 0x13 )
                {
                  div_(v5, 0xAu);
                  text[1] = v14 + 48;
                  text[2] = 37;
                  text[3] = 0;
                  goto LABEL_16;
                }
                goto LABEL_9;
              }
              text[1] = div_(v5, 100u) + 48;
              v6 = div_(v5, 0xAu);
              v8 = v7;
              div_(v6, 0xAu);
              text[2] = v9 + 48;
              text[3] = v8 + 48;
              LOWORD(v39) = 37;
LABEL_16:
              v3 = v0;
              v4 = text;
LABEL_17:
              displayTextAt(v4, 88, v3, 0);
              v0 += 8;
              ++channel;
            }
            while ( channel < 6 );
            displayTextAt("All channels", 8, v0, 0);
            fillRegion(0, 12, 7, 63, 1);
            displayGFX((int)&arrow_gfx, 0, 8 * v37 + 8);
            LCD_updateCALL();
            v20 = getKeyCode();
            if ( v20 == 9 || v20 == 23 )
            {
              if ( v37 )
              {
                --v37;
                if ( (unsigned int)sub_9BC0() >= 2 )
                {
LABEL_30:
                  beep(784, 15);
                  beep(0, 15);
                  continue;
                }
              }
              continue;
            }
            break;
          }
          if ( v20 == 8 || v20 == 24 )
          {
            if ( (unsigned int)v37 < 6 )
            {
              ++v37;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_30;
            }
            continue;
          }
          break;
        }
        if ( v20 == 10 )
        {
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
            beep(784, 15);
            beep(0, 15);
          }
          if ( (unsigned int)v37 >= 6 )
          {
            v22 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 116] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 115]) != 0x7FFF )
            {
              v23 = BYTE1(dword_1FFFFDE0[0]);
              rxsettings[146 * (unsigned __int8)currentModel + 115] = dword_1FFFFDE0[0];
              v22[3] = v23;
            }
            v24 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 118] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 117]) != 0x7FFF )
            {
              v25 = BYTE1(dword_1FFFFDE4);
              rxsettings[146 * (unsigned __int8)currentModel + 117] = dword_1FFFFDE4;
              v24[5] = v25;
            }
            v26 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 120] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 119]) != 0x7FFF )
            {
              v27 = BYTE1(dword_1FFFFDE8);
              rxsettings[146 * (unsigned __int8)currentModel + 119] = dword_1FFFFDE8;
              v26[7] = v27;
            }
            v28 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 122] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 121]) != 0x7FFF )
            {
              v29 = BYTE1(dword_1FFFFDEC);
              rxsettings[146 * (unsigned __int8)currentModel + 121] = dword_1FFFFDEC;
              v28[9] = v29;
            }
            v30 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 124] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 123]) != 0x7FFF )
            {
              v31 = BYTE1(dword_1FFFFDF0);
              rxsettings[146 * (unsigned __int8)currentModel + 123] = dword_1FFFFDF0;
              v30[11] = v31;
            }
            v32 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
            if ( ((signed __int16)((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 126] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 125]) != 0x7FFF )
            {
              v33 = BYTE1(dword_1FFFFDF4);
              rxsettings[146 * (unsigned __int8)currentModel + 125] = dword_1FFFFDF4;
              v32[13] = v33;
            }
          }
          else
          {
            failsafeOnOff(v37);
          }
          continue;
        }
        break;
      }
      if ( v20 == 22 )
      {
        if ( (unsigned int)sub_9BC0() >= 2 )
        {
          beep(784, 15);
          beep(0, 15);
        }
        FailsafeReset();
        continue;
      }
      break;
    }
    if ( v20 == 25 )
    {
      result = 1;
    }
    else
    {
      if ( v20 != 11 )
        continue;
      result = 0;
    }
    return result;
  }
}
// 8: using guessed type int NMI;
// 1FFFFDE4: using guessed type int dword_1FFFFDE4;
// 1FFFFDE8: using guessed type int dword_1FFFFDE8;
// 1FFFFDEC: using guessed type int dword_1FFFFDEC;
// 1FFFFDF0: using guessed type int dword_1FFFFDF0;
// 1FFFFDF4: using guessed type int dword_1FFFFDF4;
// 200002AD: using guessed type char currentModel;

//----- (000043E0) --------------------------------------------------------
int FailsafeReset()
{
  int v0; // r4@1
  int v1; // r1@3
  int v2; // r0@5
  char *v4; // r2@15
  char *v5; // r2@15
  char *v6; // r2@15
  char *v7; // r2@15
  char *v8; // r2@15
  char *v9; // r1@15

  v0 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      callSetupDMAandSend();
      displayPageHeader("Failsafe");
      displayTextAt2("This will reset", 64, 16, 0);
      displayTextAt2("all Channel", 64, 24, 0);
      displayTextAt2("to their", 64, 32, 0);
      displayTextAt2("factory default", 64, 40, 0);
      displayTextAt("Yes", 28, 52, 0);
      displayTextAt("No", 76, 52, 0);
      v1 = v0 ? 20 : 68;
      displayGFX((int)&arrow_gfx, v1, 52);
      LCD_updateCALL();
      v2 = getKeyCode();
      if ( v2 != 24 && v2 != 23 && v2 != 8 && v2 != 9 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v2 == 10 )
      break;
    if ( v2 == 11 )
      return beep(523, 100);
  }
  if ( v0 == 1 )
  {
    v4 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v4[2] = -1;
    v4[3] = 127;
    v5 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v5[4] = -1;
    v5[5] = 127;
    v6 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v6[6] = -1;
    v6[7] = 127;
    v7 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v7[8] = -1;
    v7[9] = 127;
    v8 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v8[10] = -1;
    v8[11] = 127;
    v9 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
    v9[12] = -1;
    v9[13] = 127;
  }
  return beep(523, 100);
}
// 200002AD: using guessed type char currentModel;

//----- (00004534) --------------------------------------------------------
int __fastcall failsafeOnOff(int a1)
{
  int v1; // r6@1
  int v2; // r1@3
  const char *v3; // r0@3
  int v4; // r2@5
  int v5; // r0@6
  int v6; // r0@9
  int v8; // r0@20
  char *v9; // r1@20
  char *v10; // r0@21
  _BYTE text[4]; // [sp+4h] [bp-2Ch]@1
  int v12; // [sp+8h] [bp-28h]@1
  int v13; // [sp+Ch] [bp-24h]@1
  int v14; // [sp+10h] [bp-20h]@1
  int v15; // [sp+14h] [bp-1Ch]@1

  *(_DWORD *)text = 0x6E616843;
  v13 = 0;
  v12 = 829187438;
  v14 = 2 * a1;
  byte_20000004 = ((signed __int16)((unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 116] + 2 * a1) << 8) | (unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 115] + 2 * a1)) != 0x7FFF;
  v1 = a1;
  v15 = (unsigned __int8)(a1 + 49);
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        callSetupDMAandSend();
        displayPageHeader("Failsafe");
        if ( byte_20000004 )
        {
          v2 = 56;
          v3 = "ON";
        }
        else
        {
          v2 = 52;
          v3 = "OFF";
        }
        displayTextAt(v3, v2, 16, 0);
        BYTE3(v12) = v15;
        displayTextAt(text, 32, 40, 0);
        drawLine(14, 48, 114, 54, 0);
        sub_4E8C(24, 48, 24, 54, 0);
        sub_4E8C(64, 48, 64, 54, 0);
        sub_4E8C(104, 48, 104, 54, 0);
        v4 = div__0(40 * dword_1FFFFDE0[v1], (signed int)dword_2710) + 64;
        if ( dword_1FFFFDE0[v1] >= 0 )
        {
          v5 = 64;
        }
        else
        {
          v5 = v4;
          v4 = 64;
        }
        fillRegion(v5, 50, v4, 52, 0);
        LCD_updateCALL();
      }
      while ( sub_2574() == 255 );
      v6 = getKeyCode();
      if ( v6 != 9 && v6 != 23 && v6 != 8 && v6 != 24 )
        break;
      byte_20000004 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v6 == 10 || v6 == 25 )
      break;
    if ( v6 == 11 )
      return beep(523, 100);
  }
  if ( byte_20000004 )
  {
    v8 = dword_1FFFFDE0[v1];
    v9 = &rxsettings[146 * (unsigned __int8)currentModel + 113] + v14;
    v9[2] = v8;
    v9[3] = BYTE1(v8);
  }
  else
  {
    v10 = &rxsettings[146 * (unsigned __int8)currentModel + 113] + v14;
    v10[2] = -1;
    v10[3] = 127;
  }
  return beep(523, 100);
}
// 2710: using guessed type int dword_2710[28];
// 20000004: using guessed type char byte_20000004;
// 200002AD: using guessed type char currentModel;

//----- (000046E8) --------------------------------------------------------
signed int __fastcall FirmwareUpdatePage(int a1, int a2, int a3, int a4)
{
  int v4; // r0@2
  signed int result; // r0@4
  unsigned int v6; // r0@5
  int v7; // [sp+0h] [bp-10h]@1

  v7 = a4;
  callSetupDMAandSend();
  displayPageHeader("Firmware update");
  displayTextAt2("This will enter", 64, 16, 0);
  displayTextAt2("firmware update", 64, 24, 0);
  displayTextAt2("mode and halt", 64, 32, 0);
  displayTextAt2("other functions", 64, 40, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  displayTextAt2("to proceed", 64, 56, 0);
  LCD_updateCALL();
  do
  {
    v4 = getKeyCode();
    if ( v4 == 11 )
      return 0;
  }
  while ( v4 != 10 );
  result = sub_23F4();
  if ( result )
  {
    callSetupDMAandSend();
    displayPageHeader("Firmware update");
    displayTextAt2("Update mode on", 64, 16, 0);
    displayTextAt2("switch off and", 64, 32, 0);
    displayTextAt2("back on to exit", 64, 40, 0);
    LCD_updateCALL();
    dword_1FFFF800 = 0x1AE811C9;
    dword_1FFFF804 = 0x7F5594AC;
    v6 = crcCheck(&dword_1800, 0xE560);
    v7 = v6 + 0x55550000;
    if ( ((unk_FD61 << 8) | unk_FD60) == v6 )
      JUMPOUT(&word_47BE);
    flashMethod((int)&unk_FD60, 4, (int)&v7);
    JUMPOUT(*(_DWORD *)&word_47BE);
  }
  return result;
}
// 1800: using guessed type int dword_1800;
// 47BE: using guessed type __int16 word_47BE;
// 1FFFF800: using guessed type int dword_1FFFF800;
// 1FFFF804: using guessed type int dword_1FFFF804;

//----- (00004818) --------------------------------------------------------
signed int FactResConfirm()
{
  int v0; // r0@2
  signed int result; // r0@4
  unsigned int v2; // r6@5
  int v3; // r4@6
  unsigned int v4; // r5@9
  int v5; // r4@10
  int v6; // [sp+0h] [bp-58h]@5

  callSetupDMAandSend();
  displayPageHeader("Factory reset");
  displayTextAt2("This will reset", 64, 16, 0);
  displayTextAt2("all parameters", 64, 24, 0);
  displayTextAt2("to their", 64, 32, 0);
  displayTextAt2("factory default", 64, 40, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  displayTextAt2("to proceed", 64, 56, 0);
  LCD_updateCALL();
  do
  {
    v0 = getKeyCode();
    if ( v0 == 11 )
      return 0;
  }
  while ( v0 != 10 );
  result = sub_23F4();
  if ( result )
  {
    setFactVal();
    usedModelPtr = (int)&rxsettings[146 * (unsigned __int8)currentModel + 10];
    setupDMA(&v6, 0x40u, 0xFFu);
    someSPImethod();
    v2 = 0;
    do
    {
      v3 = (v2 << 12) + 64;
      do
      {
        saveEepromData(&v6, v3, 0x40u);
        v3 += 64;
      }
      while ( v3 - ((v2 << 12) + 64) < (unsigned int)&dword_B74 );
      someSPImethod();
      ++v2;
    }
    while ( v2 < 4 );
    v4 = 0;
    do
    {
      v5 = v4 << 12;
      do
      {
        saveEepromData(&v6, v5, 0x40u);
        v5 += 64;
      }
      while ( v5 - (v4 << 12) < 0x2A );
      someSPImethod();
      ++v4;
    }
    while ( v4 < 4 );
    result = 1;
  }
  return result;
}
// B74: using guessed type int dword_B74;
// 2000002C: using guessed type int usedModelPtr;
// 200002AD: using guessed type char currentModel;

//----- (00004924) --------------------------------------------------------
signed int __fastcall showSingleValuePage(_BYTE *namePtr, int a2, int a3)
{
  int v3; // r4@3
  unsigned int v4; // r5@4
  unsigned int v5; // r5@6
  signed int v6; // r1@7
  unsigned int v7; // r5@10
  int v8; // r0@12
  int v9; // r0@20
  int v11; // r0@30
  unsigned int v12; // r0@37
  char text; // [sp+4h] [bp-34h]@11
  char v14; // [sp+5h] [bp-33h]@11
  unsigned int v15; // [sp+8h] [bp-30h]@1
  int v16; // [sp+Ch] [bp-2Ch]@1
  int v17; // [sp+10h] [bp-28h]@7
  _BYTE *v18; // [sp+18h] [bp-20h]@1
  int v19; // [sp+1Ch] [bp-1Ch]@1
  int v20; // [sp+20h] [bp-18h]@1

  v18 = namePtr;
  v19 = a2;
  v20 = a3;
  v16 = 0;
  v15 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                callSetupDMAandSend();
                displayPageHeader(v18);
                if ( getInputStates() & (1 << *(_BYTE *)(usedModelPtr + 44)) )
                {
                  displayTextAt("Idle up", 0, 12, 0);
                  v3 = v19 + 5;
                }
                else
                {
                  displayTextAt("Normal", 0, 12, 0);
                  v3 = v19;
                }
                v4 = 0;
                do
                {
                  aL100_0[0] = *(_BYTE *)(v4 + 536871013);
                  intToString(*(_BYTE *)(v3 + v4), &aL100_0[2], 3u);
                  displayTextAt(aL100_0, 0, 8 * v4++ + 20, 0);
                }
                while ( v4 < 5 );
                displayGFX((int)&arrow_gfx, 8, 8 * v15 + 20);
                drawLine(55, 8, 123, 52, 0);
                sub_4E8C(53, 8, 54, 8, 0);
                getGFX(54, 19, 0);
                sub_4E8C(53, 30, 123, 30, 0);
                getGFX(54, 41, 0);
                sub_4E8C(53, 52, 54, 52, 0);
                sub_4E8C(55, 53, 55, 54, 0);
                getGFX(72, 53, 0);
                sub_4E8C(89, 53, 89, 54, 0);
                getGFX(106, 53, 0);
                sub_4E8C(123, 53, 123, 54, 0);
                v5 = 0;
                do
                {
                  v17 = 52 - div__0(44 * *(_BYTE *)(v3 + v5 + 1), 100);
                  v6 = 52 - div__0(44 * *(_BYTE *)(v3 + v5), 100);
                  sub_4E8C(*((_DWORD *)&unk_200000E0 + v5), v6, *((_DWORD *)&unk_200000E0 + v5 + 1), v17, 0);
                  ++v5;
                }
                while ( v5 < 4 );
                v7 = 0;
                do
                {
                  text = *(_BYTE *)(v7 + 536871013);
                  v14 = 0;
                  displayTextAt(&text, *((_DWORD *)&unk_200000E0 + v7++) - 3, 56, 0);
                }
                while ( v7 < 5 );
                sub_4E8C(v16 + 55, 8, v16 + 55, 52, 0);
                LCD_updateCALL();
                v8 = div__0(68 * ((_DWORD)dword_2710 + dword_1FFFFD7C[4]), 20000);
                if ( v8 >= 0 )
                {
                  if ( v8 > 68 )
                    v8 = 68;
                }
                else
                {
                  v8 = 0;
                }
                if ( v16 == v8 )
                  break;
                v16 = v8;
              }
            }
            while ( sub_2574() == 255 );
            v9 = getKeyCode();
            if ( v9 != 10 )
              break;
            if ( v15 < 4 )
              v11 = v15 + 1;
            else
              v11 = 0;
            v15 = v11;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_41:
              beep(784, 15);
              beep(0, 15);
            }
          }
          if ( v9 != 8 && v9 != 24 )
            break;
          if ( *(_BYTE *)(v3 + v15) )
          {
            --*(_BYTE *)(v3 + v15);
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_41;
          }
        }
        if ( v9 != 9 && v9 != 23 )
          break;
        v12 = *(_BYTE *)(v3 + v15);
        if ( v12 < 0x64 )
        {
          *(_BYTE *)(v3 + v15) = v12 + 1;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_41;
        }
      }
      if ( v9 != 22 )
        break;
      *(_BYTE *)(v3 + v15) = *(_BYTE *)(v20 + v15);
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_41;
    }
    if ( v9 == 25 )
      return 1;
    if ( v9 == 11 )
      return 0;
  }
}
// 4: using guessed type int Reset;
// 2710: using guessed type int dword_2710[28];
// 2000002C: using guessed type int usedModelPtr;

//----- (00004BA0) --------------------------------------------------------
unsigned int __fastcall displayGFX(int a1, int a2, signed int a3)
{
  unsigned int v3; // r5@1
  _BYTE *v4; // r7@1
  unsigned int result; // r0@1
  int v6; // r0@3
  unsigned int v7; // r6@5
  char *v8; // r4@5
  int v9; // [sp+0h] [bp-48h]@1
  unsigned int v10; // [sp+4h] [bp-44h]@1
  unsigned int v11; // [sp+10h] [bp-38h]@1
  unsigned int v12; // [sp+1Ch] [bp-2Ch]@1
  int v13; // [sp+28h] [bp-20h]@1
  int v14; // [sp+2Ch] [bp-1Ch]@1

  v13 = a1;
  v14 = a2;
  v3 = a3 - 8 * ((((unsigned int)(a3 >> 31) >> 29) + a3) >> 3);
  v11 = (1 << a3 % 8) - 1;
  LOBYTE(v12) = ~(_BYTE)v11;
  v4 = *(_BYTE **)(a1 + 8);
  result = a3 / 8;
  v10 = a3 / 8 + ((unsigned int)(*(_DWORD *)(v13 + 4) + 7) >> 3) - 1;
  v9 = a3 / 8;
  if ( a3 / 8 <= v10 )
  {
    do
    {
      if ( v9 == v10 )
      {
        v6 = *(_DWORD *)(v13 + 4);
        if ( v6 << 29 )
        {
          v11 = ~(((1 << ((v6 & 7) + v3)) - 1) ^ v11);
          v12 = v11 >> 8;
        }
      }
      v7 = 0;
      v8 = &GFX_ARRAY[128 * v9] + v14;
      if ( *(_DWORD *)v13 )
      {
        do
        {
          *v8 = *v8 & v11 | (*v4 << v3);
          if ( v3 )
            v8[128] = ((unsigned int)*v4 >> (8 - v3)) | v8[128] & v12;
          ++v4;
          ++v8;
          if ( !(v7 << 29) )
            sendPacketWithTimer();
          ++v7;
        }
        while ( *(_DWORD *)v13 > v7 );
      }
      sendPacketWithTimer();
      result = v9 + 1;
      v9 = result;
    }
    while ( result <= v10 );
  }
  return result;
}

//----- (00004C70) --------------------------------------------------------
signed int __fastcall fillRegion(int a1, signed int a2, int a3, signed int a4, int a5)
{
  signed int v5; // r5@1
  int v6; // r0@1
  int v7; // r7@1
  char *v8; // r6@1
  signed int v9; // r3@1
  int v10; // r1@2
  int v11; // r5@2
  signed int v12; // r12@2
  signed int i; // r7@5
  int v14; // r5@6
  int v15; // r0@6
  unsigned int v16; // r0@7
  int v17; // r6@11
  signed int k; // r0@13
  char v19; // r1@16
  int v20; // r6@17
  signed int j; // r0@19
  char v22; // r0@23
  int v23; // r1@26
  char v24; // r2@28
  char v25; // r2@29
  int v26; // lr@32
  int v27; // r12@32
  int v28; // r3@32
  int v29; // r0@32
  int v30; // r0@36
  int v31; // r1@36
  int v32; // r3@36
  char *v33; // r0@46
  char v34; // r1@46
  int v35; // r2@52
  char v36; // r3@54
  char v37; // r3@55
  signed int v39; // [sp+0h] [bp-38h]@1
  int v40; // [sp+4h] [bp-34h]@1
  int v41; // [sp+8h] [bp-30h]@32
  int v42; // [sp+Ch] [bp-2Ch]@32
  int v43; // [sp+14h] [bp-24h]@1
  signed int v44; // [sp+20h] [bp-18h]@1

  v43 = a1;
  v44 = a4;
  v5 = a2;
  v6 = a2 - 8 * ((((unsigned int)(a2 >> 31) >> 29) + a2) >> 3);
  v7 = v6 + a4 - a2;
  v8 = &GFX_ARRAY[128 * (a2 / 8)] + v43;
  v9 = 1 << a2 % 8;
  v40 = a3 - v43;
  v39 = a3 - v43 + 1;
  if ( v7 >= 8 )
  {
    if ( a2 << 29 )
    {
      v22 = ~(v9 - 1);
      if ( a5 == 1 )
        v22 = v9 - 1;
      if ( a3 - v43 + 1 > 0 )
      {
        v23 = v40 + 1;
        do
        {
          if ( a5 )
          {
            v24 = *v8;
            if ( a5 == 1 )
              v25 = v24 & v22;
            else
              v25 = v24 ^ v22;
            *v8 = v25;
          }
          else
          {
            *v8 |= v22;
          }
          ++v8;
          --v23;
        }
        while ( v23 );
      }
    }
    sendPacketWithTimer();
    v26 = 0;
    v27 = 0;
    v28 = (v5 + 7) / 8;
    v42 = (v28 << 7) + v43;
    v29 = (v44 + 1) / 8 - v28;
    v41 = (v44 + 1) / 8 - v28;
    while ( v29 > v27 )
    {
      if ( v39 > 0 )
      {
        v30 = 0;
        v31 = v40 + 1;
        v32 = v42 + v26;
        do
        {
          if ( a5 == 1 )
          {
            *(&GFX_ARRAY[v32] + v30) = 0;
          }
          else if ( a5 )
          {
            *(&GFX_ARRAY[v32] + v30) = ~*(&GFX_ARRAY[v32] + v30);
          }
          else
          {
            *(&GFX_ARRAY[v32] + v30) = -1;
          }
          ++v30;
          --v31;
        }
        while ( v31 );
      }
      v26 += 128;
      ++v27;
      v29 = v41;
    }
    sendPacketWithTimer();
    if ( (v44 & 0x80000007) != 7 )
    {
      v33 = &GFX_ARRAY[128 * (v44 / 8)] + v43;
      v34 = (1 << (v44 % 8 + 1)) - 1;
      if ( a5 == 1 )
        v34 = ~v34;
      if ( v39 > 0 )
      {
        v35 = v40 + 1;
        do
        {
          if ( a5 )
          {
            v36 = *v33;
            if ( a5 == 1 )
              v37 = v36 & v34;
            else
              v37 = v36 ^ v34;
            *v33 = v37;
          }
          else
          {
            *v33 |= v34;
          }
          ++v33;
          --v35;
        }
        while ( v35 );
      }
    }
  }
  else
  {
    v10 = 0;
    v11 = v44 - v5;
    v12 = v11 + 1;
    if ( v11 + 1 > 0 )
    {
      if ( v11 << 31 != 0x80000000 )
      {
        v10 = (unsigned __int8)v9;
        ++v6;
      }
      for ( i = v12 >> 1; i; --i )
      {
        v14 = (1 << v6) | v10;
        v15 = v6 + 1;
        LOBYTE(v10) = (1 << v15) | v14;
        v6 = v15 + 1;
        v10 = (unsigned __int8)v10;
      }
    }
    v16 = ((a3 - v43) << 31) + 2147483648;
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        v19 = ~(_BYTE)v10;
        if ( v39 > 0 )
        {
          v20 = (int)(v8 - 1);
          if ( v16 )
            *(_BYTE *)(v20++ + 1) &= v19;
          for ( j = v39 >> 1; j; --j )
          {
            *(_BYTE *)(v20 + 1) &= v19;
            *(_BYTE *)(v20 + 2) &= v19;
            v20 += 2;
          }
        }
      }
    }
    else if ( v39 > 0 )
    {
      v17 = (int)(v8 - 1);
      if ( v16 )
        *(_BYTE *)(v17++ + 1) |= v10;
      for ( k = v39 >> 1; k; --k )
      {
        *(_BYTE *)(v17 + 1) |= v10;
        *(_BYTE *)(v17 + 2) |= v10;
        v17 += 2;
      }
    }
  }
  return sendPacketWithTimer();
}

//----- (00004E8C) --------------------------------------------------------
signed int __fastcall sub_4E8C(int a1, signed int a2, int a3, signed int a4, int a5)
{
  int v5; // r5@1
  signed int v6; // r4@1
  int i; // r4@4
  signed int v8; // r5@9
  signed int result; // r0@13
  signed int v10; // r7@15
  signed int v11; // r6@15
  unsigned int v12; // r1@15
  int v13; // r0@16
  signed int v14; // r7@22
  signed int v15; // r6@22
  unsigned int v16; // r1@22
  int v17; // r0@23
  int v18; // [sp+0h] [bp-30h]@18
  int v19; // [sp+0h] [bp-30h]@25
  int v20; // [sp+4h] [bp-2Ch]@16
  int v21; // [sp+4h] [bp-2Ch]@23
  int v22; // [sp+Ch] [bp-24h]@1
  signed int v23; // [sp+10h] [bp-20h]@1

  v22 = a1;
  v23 = a2;
  v5 = a3;
  v6 = a4;
  if ( a1 > a3 )
  {
    v6 = a2;
    v5 = a1;
    v22 = a3;
    v23 = a4;
  }
  if ( v23 == v6 )
  {
    for ( i = v22; i <= v5; ++i )
      getGFX(i, v23, a5);
    return sendPacketWithTimer();
  }
  if ( v22 == v5 )
  {
    if ( v23 >= v6 )
    {
      v8 = v6;
      v6 = v23;
    }
    else
    {
      v8 = v23;
    }
    for ( ; v8 <= v6; ++v8 )
      getGFX(v22, v8, a5);
    return sendPacketWithTimer();
  }
  if ( v23 >= v6 )
  {
    v14 = v22 << 16;
    v15 = (v23 << 16) + 0xFFFF;
    v16 = v23 - v6;
    if ( v5 - v22 >= v23 - v6 )
    {
      v21 = 0x10000;
      v17 = div_(v16 << 16, v5 - v22) + 1;
    }
    else
    {
      v21 = div_((v5 - v22) << 16, v16) + 1;
      v17 = 0x10000;
    }
    v19 = v17;
    getGFX((signed __int16)v22, v15 >> 16, a5);
    do
    {
      do
      {
        v14 += v21;
        v15 -= v19;
        getGFX((v14 + 0x8000) >> 16, (v15 - 0x8000) >> 16, a5);
        sendPacketWithTimer();
      }
      while ( v14 >> 16 < v5 );
      result = v15 >> 16;
    }
    while ( v15 >> 16 > v6 );
  }
  else
  {
    v10 = v22 << 16;
    v11 = v23 << 16;
    v12 = v6 - v23;
    if ( v5 - v22 >= v6 - v23 )
    {
      v20 = 0x10000;
      v13 = div_(v12 << 16, v5 - v22) + 1;
    }
    else
    {
      v20 = div_((v5 - v22) << 16, v12) + 1;
      v13 = 0x10000;
    }
    v18 = v13;
    getGFX((signed __int16)v22, (signed __int16)v23, a5);
    do
    {
      do
      {
        v10 += v20;
        v11 += v18;
        getGFX((v10 + 0x8000) >> 16, (v11 + 0x8000) >> 16, a5);
        sendPacketWithTimer();
      }
      while ( v10 >> 16 < v5 );
      result = v11 >> 16;
    }
    while ( v11 >> 16 < v6 );
  }
  return result;
}

//----- (00004FD8) --------------------------------------------------------
int __fastcall getGFX(int a1, signed int a2, int a3)
{
  signed int a2_0; // kr00_4@1
  signed int v4; // r1@1
  char *v5; // r3@1
  int v6; // r0@1
  int result; // r0@3

  a2_0 = a2;
  v4 = 1 << a2 % 8;
  v5 = &GFX_ARRAY[128 * (a2_0 / 8)] + a1;
  v6 = (unsigned __int8)*v5;
  if ( !a3 )
  {
    result = v6 | v4;
    goto LABEL_4;
  }
  if ( a3 != 1 )
  {
    result = v6 ^ v4;
LABEL_4:
    *v5 = result;
    return result;
  }
  result = v6 & ~v4;
  *v5 = result;
  return result;
}

//----- (00005018) --------------------------------------------------------
int __fastcall drawLine(int a1, int a2, int a3, int a4, int a5)
{
  int a1_0; // ST04_4@1
  int a4_0; // r5@1
  int a3_0; // r6@1
  int a2_0; // r7@1

  a1_0 = a1;
  a4_0 = a4;
  a3_0 = a3;
  a2_0 = a2;
  sub_4E8C(a1, a2, a3, a2, a5);
  sub_4E8C(a3_0, a2_0, a3_0, a4_0, a5);
  sub_4E8C(a3_0, a4_0, a1_0, a4_0, a5);
  return sub_4E8C(a1_0, a4_0, a1_0, a2_0, a5);
}

//----- (0000505C) --------------------------------------------------------
int __fastcall displayTextAt(_BYTE *text, int x, signed int y, int a4)
{
  int v4; // r5@1
  unsigned int v5; // r4@1
  int result; // r0@1
  _BYTE *v7; // r1@3
  char *v8; // r0@3
  signed int v9; // r2@3
  char v10; // r3@5
  char v11; // [sp+0h] [bp-38h]@1
  char v12; // [sp+4h] [bp-34h]@2
  char *v13; // [sp+8h] [bp-30h]@1
  int v14; // [sp+Ch] [bp-2Ch]@1
  _BYTE *v15; // [sp+14h] [bp-24h]@1

  v15 = text;
  v4 = a4;
  v5 = y - 8 * ((((unsigned int)(y >> 31) >> 29) + y) >> 3);
  v11 = (1 << y % 8) - 1;
  v14 = ~((1 << y % 8) - 1);
  v13 = &GFX_ARRAY[128 * (y / 8)] + x;
  result = *text;
  if ( *v15 )
  {
    v12 = 8 - y % 8;
    do
    {
      v7 = (_BYTE *)(8 * *v15 + 56625);
      v8 = v13;
      v9 = 8;
      do
      {
        if ( v4 )
        {
          v10 = *v8;
          if ( v4 == 1 )
          {
            *v8 = v10 & v11 | (~*v7 << v5);
            if ( v5 )
              v8[128] = (~*v7 >> v12) & v11 | v8[128] & v14;
          }
          else
          {
            *v8 = v10 ^ (*v7 << v5);
            if ( v5 )
              v8[128] ^= (unsigned int)*v7 >> v12;
          }
        }
        else
        {
          *v8 = *v8 & v11 | (*v7 << v5);
          if ( v5 )
            v8[128] = ((unsigned int)*v7 >> v12) | v8[128] & v14;
        }
        ++v8;
        ++v7;
        --v9;
      }
      while ( v9 );
      v13 += 8;
      ++v15;
      sendPacketWithTimer();
      result = *v15;
    }
    while ( *v15 );
  }
  return result;
}

//----- (00005154) --------------------------------------------------------
int __fastcall displayTextAt2(_BYTE *text, int a2, signed int a3, int a4)
{
  int v4; // r5@1
  signed int v5; // r6@1
  int v6; // r4@1
  _BYTE *textPTR; // r7@1
  char *v8; // r0@1

  v4 = a4;
  v5 = a3;
  v6 = a2;
  textPTR = text;
  v8 = strLength(text);
  return displayTextAt(textPTR, v6 - 4 * (_DWORD)v8, v5, v4);
}

//----- (00005174) --------------------------------------------------------
int __fastcall displaySmallTextAt(_BYTE *a1, int a2, signed int a3)
{
  int result; // r0@1
  int v4; // r0@3
  _BYTE *v5; // r3@3
  int v6; // r2@3
  unsigned int v7; // r1@3
  signed int v8; // r5@5
  _BYTE *v9; // r0@9
  _BYTE *v10; // r0@12
  _BYTE *v11; // r0@15
  _BYTE *v12; // r0@18
  int v13; // r6@21
  int v14; // r6@22
  int v15; // r0@31
  unsigned int v16; // [sp+0h] [bp-30h]@2
  char v17; // [sp+4h] [bp-2Ch]@2
  char *v18; // [sp+8h] [bp-28h]@2
  _BYTE *v19; // [sp+10h] [bp-20h]@1
  int v20; // [sp+14h] [bp-1Ch]@1

  v19 = a1;
  v20 = a2;
  result = *a1;
  if ( result )
  {
    v16 = a3 - 8 * ((((unsigned int)(a3 >> 31) >> 29) + a3) >> 3);
    v18 = &GFX_ARRAY[128 * (a3 / 8)];
    v17 = a3 % 8 + 1;
    do
    {
      v4 = *v19;
      v5 = (_BYTE *)(6 * v4 + 58481);
      v6 = (int)&v18[v20];
      LOBYTE(v7) = v16;
      if ( v4 == 121 )
        LOBYTE(v7) = v17;
      v8 = 0;
      do
      {
        if ( *v5 & 0x20 )
          *(_BYTE *)v6 |= 1 << v7;
        else
          *(_BYTE *)v6 &= ~(1 << v7);
        v9 = (_BYTE *)(v6 + 1);
        if ( *v5 & 0x10 )
          *v9 |= 1 << v7;
        else
          *v9 &= ~(1 << v7);
        v10 = (_BYTE *)(v6 + 2);
        if ( *v5 & 8 )
          *v10 |= 1 << v7;
        else
          *v10 &= ~(1 << v7);
        v11 = (_BYTE *)(v6 + 3);
        if ( *v5 & 4 )
          *v11 |= 1 << v7;
        else
          *v11 &= ~(1 << v7);
        v12 = (_BYTE *)(v6 + 4);
        if ( *v5 & 2 )
          *v12 |= 1 << v7;
        else
          *v12 &= ~(1 << v7);
        v13 = *(_BYTE *)(v6 + 5);
        if ( *v5 & 1 )
          v14 = v13 | (1 << v7);
        else
          v14 = v13 & ~(1 << v7);
        ++v5;
        v7 = (unsigned __int8)(v7 + 1);
        *(_BYTE *)(v6 + 5) = v14;
        if ( v7 >= 8 )
        {
          LOBYTE(v7) = 0;
          v6 += 128;
        }
        ++v8;
      }
      while ( v8 < 6 );
      if ( (unsigned int)*v19 - 65 <= 0x19 && (unsigned int)v19[1] - 65 <= 0x19 || v19[1] == 37 )
        v15 = v20 + 7;
      else
        v15 = v20 + 6;
      v20 = v15;
      ++v19;
      sendPacketWithTimer();
      result = *v19;
    }
    while ( *v19 );
  }
  return result;
}

//----- (000052DC) --------------------------------------------------------
int __fastcall displayTextFromRight(_DWORD *a1, int a2, signed int a3, int a4)
{
  int a4_0; // r5@1
  signed int a3_0; // r6@1
  int a2_0; // r4@1
  _BYTE *a1_0; // r7@1
  char *v8; // r0@1

  a4_0 = a4;
  a3_0 = a3;
  a2_0 = a2;
  a1_0 = a1;
  v8 = strLength(a1);
  return displayTextAt(a1_0, a2_0 - 8 * (_DWORD)v8, a3_0, a4_0);
}

//----- (000052FC) --------------------------------------------------------
const char *__fastcall getSensorNameObsolet(signed int a1)
{
  const char *result; // r0@7

  if ( a1 == 124 )
  {
    result = "Odo1";
  }
  else if ( a1 > 124 )
  {
    switch ( a1 )
    {
      case 125:
        result = "Odo2";
        break;
      case 126:
        result = " Spe";
        break;
      case 127:
        result = "Tx.V";
        break;
      default:
        if ( a1 != 254 )
          return (const char *)dword_D554;
        result = " Err";
        break;
    }
  }
  else if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = " Tem";
    }
    else
    {
      if ( a1 != 2 )
      {
        if ( a1 == 3 )
          return "ExtV";
        return (const char *)dword_D554;
      }
      result = " Mot";
    }
  }
  else
  {
    result = "IntV";
  }
  return result;
}
// D554: using guessed type int dword_D554[41];

//----- (00005374) --------------------------------------------------------
signed int __fastcall sensorsFunction(int sensorID, int index, _DWORD *a3)
{
  int sensorIDLocal; // r6@1
  unsigned int currentSensor; // r4@1

  sensorIDLocal = sensorID;
  sub_A158();
  currentSensor = 0;
  if ( activeSensors )
  {
    do
      JUMPOUT((unsigned __int8)sensorsArrayInRam[8 * currentSensor++], sensorIDLocal, &unk_5392);
    while ( currentSensor < activeSensors );
  }
  sub_A190();
  return 0x8000;
}
// 20000024: using guessed type int activeSensors;

//----- (000053CC) --------------------------------------------------------
int __fastcall formatSensorData(int a1, int a2, _BYTE *a3)
{
  _BYTE *strPtr; // r5@1
  int v4; // r6@1
  int v5; // r3@1
  unsigned int v6; // r4@1
  int result; // r0@2
  int v8; // r1@17
  int v9; // r1@18
  int v10; // r6@18
  int v11; // r1@20
  int v12; // r1@21
  int v13; // r0@22
  unsigned int v14; // r1@23
  int v15; // r0@23
  int v16; // r3@24

  strPtr = a3;
  v4 = a1;
  v6 = sensorsFunction(a1, a2, 0);
  if ( v6 == 0x8000 )
  {
    result = 0;
    *strPtr = 0;
    return result;
  }
  if ( v4 == 0x7C )
  {
    v13 = *(_BYTE *)(usedModelPtr + 138) | (*(_BYTE *)(usedModelPtr + 139) << 8) | (*(_BYTE *)(usedModelPtr + 140) << 16);
    goto LABEL_23;
  }                                             // 124 0x7c - Odometer 1
                                                // 125 0x7d - Odometer 2
                                                // 126 0x7e - Speed
                                                // 127 0x7f - TX Voltage 
  if ( v4 > 0x7C )
  {
    if ( v4 != 0x7D )
    {
      if ( v4 == 0x7E )
      {
        div_Other(v6, 0xAu);
        return sprintf((int)strPtr, "%uKm/h", v16);
      }
      if ( v4 == 127 )
        goto LABEL_19;
      if ( v4 == 254 )
        return sprintf((int)strPtr, "%u%%", v5);
      return formatSensorValue((int)strPtr, v4, v6);
    }
    v13 = *(_BYTE *)(usedModelPtr + 142) | (*(_BYTE *)(usedModelPtr + 143) << 8) | (*(_BYTE *)(usedModelPtr + 144) << 16);
LABEL_23:
    div_Other(v13, (unsigned int)dword_2710);
    div_Other(v14, 0x3E8u);
    return sprintf((int)strPtr, "%u.%uKm", v15);
  }
  if ( !v4 )
  {
LABEL_19:
    if ( (v6 & 0x8000u) == 0 )
    {
      div_((signed __int16)v6, 0x64u);
      result = sprintf((int)strPtr, "%u.%02uV", v12);
    }
    else
    {
      div_((signed __int16)-(signed __int16)v6, 0x64u);
      result = sprintf((int)strPtr, "-%u.%02uV", v11);
    }
    return result;
  }
  if ( v4 != 1 )
  {
    if ( v4 == 2 )
      return sprintf((int)strPtr, "%uRPM", v5);
    if ( v4 == 3 )
      goto LABEL_19;
    return formatSensorValue((int)strPtr, v4, v6);
  }
  if ( v6 >= 0x190 )
  {
    div_Other(v6, 0xAu);
    v10 = v9;
    div_(v6 - 400, 0xAu);
    result = sprintf((int)strPtr, "%d.%u C", v10);
  }
  else
  {
    div_Other(v6 + 9, 0xAu);
    result = sprintf((int)strPtr, "%d.%u C", 9 - v8);
  }
  return result;
}
// 2710: using guessed type int dword_2710[28];
// 2000002C: using guessed type int usedModelPtr;

//----- (0000556C) --------------------------------------------------------
signed int GyroscopePAge()
{
  int v0; // r6@1
  signed int v1; // r5@2
  _BYTE *v2; // r0@5
  char *v3; // r0@8
  int v4; // r0@10
  unsigned int v6; // r0@27

  v0 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            callSetupDMAandSend();
            v1 = 0;
            if ( getInputStates() & (1 << *(_BYTE *)(usedModelPtr + 44)) )
              v1 = 1;
            displayPageHeader("Gyroscope");
            displayTextAt("Gyro", 16, 24, 0);
            v2 = (_BYTE *)(*(_BYTE *)(usedModelPtr + 55) & 8 ? 51831 : "Off");
            displayTextAt(v2, 64, 24, 0);
            displayTextAt("Mode", 16, 32, 0);
            v3 = v1 ? "Idle up" : "Normal";
            displayTextAt(v3, 64, 32, 0);
            displayTextAt("Value", 16, 40, 0);
            intToString(*(_BYTE *)(usedModelPtr + v1 + 58), a100_0, 3u);
            displayTextAt(a100_0, 64, 40, 0);
            displayGFX((int)&arrow_gfx, 8, 16 * v0 + 24);
            LCD_updateCALL();
            v4 = getKeyCode();
            if ( v4 != 8 && v4 != 24 )
              break;
            if ( v0 )
            {
              if ( *(_BYTE *)(usedModelPtr + v1 + 58) )
              {
                --*(_BYTE *)(usedModelPtr + v1 + 58);
                if ( (unsigned int)sub_9BC0() >= 2 )
                {
LABEL_24:
                  beep(784, 15);
                  beep(0, 15);
                }
              }
            }
            else
            {
              *(_BYTE *)(usedModelPtr + 55) ^= 8u;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_24;
            }
          }
          if ( v4 != 9 && v4 != 23 )
            break;
          if ( v0 )
          {
            v6 = *(_BYTE *)(usedModelPtr + v1 + 58);
            if ( v6 < 0x64 )
            {
              *(_BYTE *)(usedModelPtr + v1 + 58) = v6 + 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_24;
            }
          }
          else
          {
            *(_BYTE *)(usedModelPtr + 55) ^= 8u;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_24;
          }
        }
        if ( v4 != 22 )
          break;
        if ( v0 == 1 )
        {
          *(_BYTE *)(usedModelPtr + v1 + 58) = *(_BYTE *)(v1 + 53683);
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_24;
        }
      }
      if ( v4 != 10 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_24;
    }
    if ( v4 == 25 )
      return 1;
    if ( v4 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00005710) --------------------------------------------------------
int i2cInterrupt()
{
  int v0; // r4@1
  char v1; // r3@4
  int result; // r0@15

  v40066003 |= 2u;
  v0 = dword_20000124 - 1;
  if ( byte_20000114 == 1 )
  {
    if ( v40066003 << 31 )
    {
      v40066002 &= 0xDFu;
      byte_20000116 = 0;
      byte_20000114 = 0;
    }
    else if ( dword_20000128 >= (unsigned int)dword_20000124 )
    {
      if ( dword_20000128 == dword_20000124 )
      {
        byte_20000114 = 0;
        if ( !byte_20000115 )
          v40066002 &= 0xDFu;
      }
    }
    else
    {
      if ( dword_20000128 == v0 )
        v40066002 |= 8u;
      v40066004 = *(_BYTE *)(dword_20000120 + dword_20000128);
    }
    ++dword_20000128;
    goto LABEL_22;
  }
  if ( byte_20000114 == 2 )
  {
    v40066002 &= 0xEFu;
    result = 3;
    byte_20000114 = 3;
    return result;
  }
  if ( dword_20000128 == dword_20000124 - 2 )
  {
    v1 = v40066002 | 8;
  }
  else
  {
    if ( dword_20000128 != v0 )
      goto LABEL_21;
    byte_20000114 = 0;
    if ( byte_20000115 )
      goto LABEL_21;
    v1 = v40066002 & 0xDF;
  }
  v40066002 = v1;
LABEL_21:
  *(_BYTE *)(dword_20000120 + dword_20000128++) = v40066004;
LABEL_22:
  result = (unsigned __int8)byte_20000114;
  if ( !byte_20000114 )
  {
    if ( dword_2000011C )
      result = ((int (__fastcall *)(_DWORD))dword_2000011C)((unsigned __int8)byte_20000116);
  }
  return result;
}
// 20000114: using guessed type char byte_20000114;
// 20000115: using guessed type char byte_20000115;
// 20000116: using guessed type char byte_20000116;
// 2000011C: using guessed type int dword_2000011C;
// 20000120: using guessed type int dword_20000120;
// 20000124: using guessed type int dword_20000124;
// 20000128: using guessed type int dword_20000128;

//----- (000057D4) --------------------------------------------------------
void __fastcall setSensorValue(char *a1)
{
  char *v1; // r4@1
  signed int v2; // r0@1
  unsigned int v3; // r6@4
  int v4; // r0@4
  int v5; // r1@4
  int v6; // r0@4
  unsigned int v7; // r2@4
  unsigned int v8; // r1@4
  unsigned int v9; // r0@5
  unsigned int v10; // r7@6
  unsigned int v11; // r3@7
  unsigned int v12; // r5@8
  unsigned int v13; // r3@13
  int v14; // r5@14
  unsigned int v15; // r6@14
  char *v16; // r6@17
  unsigned int v17; // r5@17
  char *v18; // r5@23

  v1 = a1;
  v2 = (unsigned __int8)*a1;
  if ( v2 > 254 )
    return;
  if ( (unsigned __int8)v1[1] == *(_BYTE *)(usedModelPtr + 135) && v2 == 2 )
  {
    v3 = timer - dword_20000028;
    v4 = div_(
           (((unsigned __int8)v1[3] << 8) | (unsigned __int8)v1[2])
         * ((*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136)),
           0x64u);
    v5 = div__0(v4 * v3, (signed int)&unk_EA60);
    v6 = usedModelPtr + 130;
    v7 = (*(_BYTE *)(usedModelPtr + 138) | (*(_BYTE *)(usedModelPtr + 139) << 8) | *(_BYTE *)(usedModelPtr + 140)) + v5;
    *(_BYTE *)(v6 + 8) = (*(_BYTE *)(usedModelPtr + 138) | *(_BYTE *)(usedModelPtr + 140)) + v5;
    *(_BYTE *)(v6 + 9) = BYTE1(v7);
    *(_BYTE *)(v6 + 10) = v7 >> 16;
    v8 = (*(_BYTE *)(v6 + 12) | (*(_BYTE *)(v6 + 13) << 8) | (*(_BYTE *)(v6 + 14) << 16)) + v5;
    *(_BYTE *)(v6 + 12) = v8;
    *(_BYTE *)(v6 + 13) = BYTE1(v8);
    *(_BYTE *)(v6 + 14) = v8 >> 16;
    dword_20000028 = timer;
  }
  v9 = 0;
  if ( activeSensors )
  {
    v10 = activeSensors & 1;
    if ( activeSensors & 1 )
    {
      v11 = (unsigned __int8)*v1;
      do
      {
        v12 = (unsigned __int8)sensorsArrayInRam[8 * v9];
        if ( v11 < v12
          || v11 == v12 && (unsigned __int8)v1[1] <= (unsigned int)*(&sensorsArrayInRam[8 * v9] + (_DWORD)byte_1) )
        {
          goto LABEL_23;
        }
      }
      while ( ++v9 < v10 );
    }
  }
  else
  {
    v10 = 0;
  }
  v9 = v10;
  if ( v10 < activeSensors )
  {
    v13 = (unsigned __int8)*v1;
    do
    {
      v14 = 8 * v9;
      v15 = (unsigned __int8)sensorsArrayInRam[8 * v9];
      if ( v13 < v15
        || v13 == v15 && (unsigned __int8)v1[1] <= (unsigned int)(unsigned __int8)sensorsArrayInRam[v14 + 1] )
      {
        break;
      }
      v16 = &sensorsArrayInRam[v14];
      v17 = (unsigned __int8)sensorsArrayInRam[v14 + 8];
      if ( v13 < v17 || v13 == v17 && (unsigned __int8)v1[1] <= (unsigned int)(unsigned __int8)v16[9] )
      {
        ++v9;
        break;
      }
      v9 += 2;
    }
    while ( v9 < activeSensors );
  }
LABEL_23:
  v18 = &sensorsArrayInRam[8 * v9];
  if ( v9 >= 32 )
    return;
  if ( v9 < activeSensors )
  {
    if ( (unsigned __int8)*v1 != (unsigned __int8)*v18 || (unsigned __int8)v1[1] != (unsigned __int8)v18[1] )
    {
      if ( (unsigned int)activeSensors >= 32 )
        return;
      sub_1D76(v18 + 8, &sensorsArrayInRam[8 * v9], 8 * (activeSensors - v9));
      ++activeSensors;
    }
  }
  else
  {
    ++activeSensors;
  }
  v18[1] = v1[1];
  *v18 = *v1;
  *((_WORD *)v18 + 1) = ((unsigned __int8)v1[3] << 8) | (unsigned __int8)v1[2];
  *((_DWORD *)v18 + 1) = timer;
}
// 20000024: using guessed type int activeSensors;
// 20000028: using guessed type int dword_20000028;
// 2000002C: using guessed type int usedModelPtr;

//----- (0000595C) --------------------------------------------------------
signed int keyTestPage()
{
  int v0; // r4@1

  v0 = 0;
  byte_20000002 = 1;
  while ( 1 )
  {
    callSetupDMAandSend();
    displayPageHeader("Key test");
    displayTextAt("SWA", 4, 12, (unsigned int)(v0 << 15) >> 31);
    displayTextAt("SWB", 36, 12, (unsigned int)(v0 << 14) >> 31);
    displayTextAt("SWC", 68, 12, (unsigned int)(v0 << 13) >> 31);
    displayTextAt("SWD", 100, 12, (unsigned int)(v0 << 12) >> 31);
    displayTextAt("TR5", 4, 23, (unsigned int)(v0 << 26) >> 31);
    displayTextAt("TR6", 36, 23, (unsigned int)(v0 << 27) >> 31);
    displayTextAt("TR3", 68, 23, (unsigned int)(v0 << 28) >> 31);
    displayTextAt("TR4", 100, 23, (unsigned int)(v0 << 29) >> 31);
    displayTextAt("TR7", 4, 34, (unsigned int)(v0 << 24) >> 31);
    displayTextAt("TR8", 36, 34, (unsigned int)(v0 << 25) >> 31);
    displayTextAt("TR1", 68, 34, (unsigned int)(v0 << 30) >> 31);
    displayTextAt("TR2", 100, 34, v0 & 1);
    displayTextAt("UP", 4, 45, (unsigned int)(v0 << 22) >> 31);
    displayTextAt("DOWN", 28, 45, (unsigned int)(v0 << 23) >> 31);
    displayTextAt("OK", 68, 45, (unsigned int)(v0 << 21) >> 31);
    displayTextAt("MENU", 92, 45, (unsigned int)(v0 << 9) >> 31);
    displayTextAt("BIND", 2, 56, (unsigned int)(v0 << 19) >> 31);
    displayTextAt("CANCEL", 37, 56, (unsigned int)(v0 << 20) >> 31);
    displayTextAt("ENTER", 87, 56, (unsigned int)(v0 << 6) >> 31);
    LCD_updateCALL();
    v0 |= 1 << (getKeyCode() & 0x7F);
    if ( !(~v0 & 0x24F1FFF) )
      break;
    if ( (unsigned int)sub_9BC0() >= 2 )
    {
      beep(784, 15);
      beep(0, 15);
    }
  }
  byte_20000002 = 0;
  return 1;
}
// 20000002: using guessed type char byte_20000002;

//----- (00005B28) --------------------------------------------------------
signed int LCDBrightM()
{
  unsigned int v0; // r7@1
  int v1; // r0@4
  char text; // [sp+4h] [bp-1Ch]@2
  char v4; // [sp+6h] [bp-1Ah]@2

  v0 = (unsigned __int8)lcdBrightnes;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("LCD brightness");
          drawLine(43, 25, 84, 30, 0);
          displayGFX((int)&plain_img, 4, 48);
          displayGFX((int)&heli_img, 68, 48);
          setLCDBrightnes((unsigned __int8)lcdBrightnes);
          intToString((unsigned __int8)lcdBrightnes - 30, &text, 2u);
          v4 = 0;
          displayTextAt(&text, 56, 16, 0);
          fillRegion(44, 26, 83, 29, 1);
          if ( (unsigned __int8)lcdBrightnes > 0x1Eu )
            fillRegion(44, 26, 2 * (unsigned __int8)lcdBrightnes - 17, 29, 0);
          LCD_updateCALL();
          v1 = getKeyCode();
          if ( v1 != 8 && v1 != 24 )
            break;
          if ( (unsigned __int8)lcdBrightnes > 0x1Eu )
          {
            --lcdBrightnes;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_15:
              beep(784, 15);
              beep(0, 15);
            }
          }
        }
        if ( v1 != 9 && v1 != 23 )
          break;
        if ( (unsigned __int8)lcdBrightnes < 0x32u )
        {
          ++lcdBrightnes;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_15;
        }
      }
      if ( v1 != 22 )
        break;
      lcdBrightnes = 40;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_15;
    }
    if ( v1 == 10 || v1 == 25 )
      return 1;
    if ( v1 == 11 )
    {
      lcdBrightnes = v0;
      setLCDBrightnes(v0);
      return 0;
    }
  }
}
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// 200002AC: using guessed type char lcdBrightnes;

//----- (00005C3C) --------------------------------------------------------
signed int sub_5C3C()
{
  int v0; // r0@2
  int v1; // r0@6

  fillRegion(0, 0, 127, 63, 0);
  LCD_updateCALL();
  do
    v0 = getKeyCode();
  while ( v0 != 10 && v0 != 25 && v0 != 11 );
  beep(1047, 100);
  fillRegion(0, 0, 127, 63, 1);
  LCD_updateCALL();
  do
    v1 = getKeyCode();
  while ( v1 != 10 && v1 != 25 && v1 != 11 );
  return 1;
}

//----- (00005C94) --------------------------------------------------------
void __fastcall controlBackLight(int a1)
{
  int v1; // r4@1
  unsigned int v2; // r0@1

  v1 = a1;
  div_Other(voltageADC * (_DWORD)dword_2710, (HIBYTE(stickAdjustData[19]) << 8) | LOBYTE(stickAdjustData[19]));
  if ( v2 >= (unsigned int)&byte_BB8 && v1 )
  {
    v400FF044 = 1;                              // SET B0
    byte_1FFFF880 = 1;
  }
  else
  {
    v400FF048 = 1;
    byte_1FFFF880 = 0;
  }
}
// BB8: using guessed type char byte_BB8;
// 2710: using guessed type int dword_2710[28];
// 1FFFF880: using guessed type char byte_1FFFF880;
// 20000F18: using guessed type int voltageADC;

//----- (00005CE4) --------------------------------------------------------
signed int setupDMAandSend()
{
  callSetupDMA();
  return sendPacketWithTimer();
}

//----- (00005CFC) --------------------------------------------------------
signed int LCD_clear()
{
  unsigned int v0; // r0@1
  char v1; // r0@2
  signed int v2; // r6@4
  char *v3; // r5@5
  signed int v4; // r4@5

  v40049010 = (v40049010 & 0xFFFFF8F8) + 256;
  v4004C01C = (v4004C01C & 0xFFFFF8F8) + 256;
  v40049034 = (v40049034 & 0xFFFFF8F8) + 256;
  v4004D07C = (v4004D07C & 0xFFFFF8F8) + 256;
  v4004D078 = (v4004D078 & 0xFFFFF8F8) + 256;
  v4004D048 = (v4004D048 & 0xFFFFF8F8) + 256;
  v4004D04C = (v4004D04C & 0xFFFFF8F8) + 256;
  v4004D050 = (v4004D050 & 0xFFFFF8F8) + 256;
  v4004D054 = (v4004D054 & 0xFFFFF8F8) + 256;
  v4004B020 = (v4004B020 & 0xFFFFF8F8) + 256;
  v4004B024 = (v4004B024 & 0xFFFFF8F8) + 256;
  v4004B028 = (v4004B028 & 0xFFFFF8F8) + 256;
  v4004B02C = (v4004B02C & 0xFFFFF8F8) + 256;
  v400FF014 |= 0x2010u;
  v400FF0D4 |= 0x80u;
  v400FF114 |= 0xC0000000;
  v400FF094 |= 0xF00u;
  v400FF114 |= 0x3C0000u;
  div_Other(voltageADC * (_DWORD)dword_2710, (HIBYTE(stickAdjustData[19]) << 8) | LOBYTE(stickAdjustData[19]));
  if ( v0 >= (unsigned int)&byte_BB8 )
  {
    v1 = 1;
    v400FF044 = 1;
  }
  else
  {
    v400FF048 = 1;
    v1 = 0;
  }
  byte_1FFFF880 = v1;
  v400FF008 = 8208;
  v400FF0C8 = 128;
  v400FF108 = -1073741824;
  timerSendPacket(5);
  v400FF0C4 = 128;
  timerSendPacket(5);
  send_to_lcd(0xE2u, 0);
  send_to_lcd(0xAEu, 0);
  send_to_lcd(0xA1u, 0);
  send_to_lcd(0xA6u, 0);
  send_to_lcd(0xA4u, 0);
  send_to_lcd(0xA2u, 0);
  send_to_lcd(0xC0u, 0);
  send_to_lcd(0x2Fu, 0);
  send_to_lcd(0x24u, 0);
  send_to_lcd(0x81u, 0);
  send_to_lcd(0x28u, 0);
  send_to_lcd(0xAFu, 0);
  callSetupDMA();
  sendPacketWithTimer();
  v2 = 0;
  do
  {
    send_to_lcd((unsigned __int8)v2 | 0xB0, 0);
    v3 = &GFX_ARRAY[128 * v2];
    send_to_lcd(4u, 0);
    send_to_lcd(0x10u, 0);
    v4 = 4;
    do
    {
      send_to_lcd((unsigned __int8)*v3++, 1);
      if ( !(v4 << 28) )
        sendPacketWithTimer();
      ++v4;
    }
    while ( v4 < 132 );
    ++v2;
  }
  while ( v2 < 8 );
  sendPacketWithTimer();
  v4004A000 = (v4004A000 & 0xFFFFF8FF) + 256;
  v400FF054 |= 1u;
  return 1;
}
// BB8: using guessed type char byte_BB8;
// 2710: using guessed type int dword_2710[28];
// 1FFFF880: using guessed type char byte_1FFFF880;
// 20000F18: using guessed type int voltageADC;

//----- (00005F24) --------------------------------------------------------
int __fastcall setLCDBrightnes(unsigned int a1)
{
  unsigned int v1; // r4@1

  v1 = a1;
  send_to_lcd(0x81u, 0);
  return send_to_lcd(v1, 0);
}

//----- (00005F3C) --------------------------------------------------------
signed int LCD_update()
{
  signed int v0; // r6@1
  char *v1; // r5@2
  signed int v2; // r4@2

  v0 = 0;
  do
  {
    send_to_lcd((unsigned __int8)v0 | 0xB0, 0);
    v1 = &GFX_ARRAY[128 * v0];
    send_to_lcd(4u, 0);
    send_to_lcd(0x10u, 0);
    v2 = 4;
    do
    {
      send_to_lcd((unsigned __int8)*v1++, 1);
      if ( !(v2 << 28) )
        sendPacketWithTimer();
      ++v2;
    }
    while ( v2 < 132 );
    ++v0;
  }
  while ( v0 < 8 );
  return sendPacketWithTimer();
}

//----- (00005F90) --------------------------------------------------------
int __fastcall send_to_lcd(unsigned int a1, int a2)
{
  unsigned int v2; // r7@1
  int result; // r0@4

  v2 = a1;
  if ( a2 )
    v400FF004 = 0x2000;
  else
    v400FF008 = 0x2000;
  v400FF108 = 2147483648;
  v400FF008 = 16;
  sub_A158();
  v400FF100 = v400FF100 & 0xFFC3FFFF | (v2 << 18) & 0x3FFFFF;
  sub_A190();
  sub_A158();
  v400FF080 = v400FF080 & 0xFFFFF0FF | (v2 >> 4 << 8);
  sub_A190();
  v400FF104 = 0x40000000;
  result = 0;
  do
    ++result;
  while ( !result );
  v400FF108 = 0x40000000;
  v400FF004 = 16;
  return result;
}

//----- (00006004) --------------------------------------------------------
int settingsValidation()
{
  unsigned int v0; // r5@1
  unsigned int v1; // r4@1
  unsigned int v2; // r0@4
  __int16 v4; // [sp+0h] [bp-18h]@1

  v0 = 0;
  v1 = 0;
  v4 = 0;
  do
  {
    if ( readEeprom((int)rxsettings, ((_WORD)v1 << 12) + 64, (int)&dword_B74)
      && crcCheck(rxsettings, 0xB72) == (unsigned __int16)settingsCRC
      && (v2 = *(_DWORD *)rxsettings, *(_DWORD *)rxsettings < 0x80000000) )
    {
      settingRelatedValue[v1] = *(_DWORD *)rxsettings;
      if ( v2 > v0 )
      {
        v0 = v2;
        v4 = v1;
      }
    }
    else
    {
      settingRelatedValue[v1] = -1;
    }
    someSPImethod();
    ++v1;
  }
  while ( v1 < 4 );
  if ( !v0
    || !readEeprom((int)rxsettings, (v4 << 12) + 64, (int)&dword_B74)
    || crcCheck(rxsettings, 0xB72) != (unsigned __int16)settingsCRC
    || *(_DWORD *)rxsettings >= 0x80000000 )
  {
    setFactVal();
  }
  usedModelPtr = (int)&rxsettings[146 * (unsigned __int8)currentModel + 10];
  return someSPImethod();
}
// B74: using guessed type int dword_B74;
// 2000002C: using guessed type int usedModelPtr;
// 200002AD: using guessed type char currentModel;
// 20000E16: using guessed type __int16 settingsCRC;

//----- (000060BC) --------------------------------------------------------
char *afhd2Init()
{
  char *result; // r0@1
  unsigned int v1; // r0@2
  int v2; // r1@3
  char v3; // [sp+0h] [bp-38h]@2
  char v4; // [sp+1h] [bp-37h]@2
  char v5; // [sp+2h] [bp-36h]@2
  char v6; // [sp+3h] [bp-35h]@2
  char v7; // [sp+4h] [bp-34h]@2

  dword_20000140 = 0;
  dword_1FFFF884 = 0xFFFFFFFF;
  result = (char *)(unsigned __int8)byte_2000013C;
  if ( byte_2000013C )
  {
    sendingPacket = 1;
    v3 = -101;
    v1 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 109] | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 110] << 8) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 111] << 16) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 112] << 24);
    v4 = rxsettings[146 * (unsigned __int8)currentModel + 109];
    v5 = BYTE1(v1);
    v6 = v1 >> 16;
    v7 = BYTE3(v1);
    sendPacketToRadio(&v3, &v3, v1 >> 16);
    addPacketToResend1FFFFCF5When2000013C(154);
    sendingPacket = 0;
    result = (char *)(unsigned __int8)byte_2000013F;
    if ( byte_2000013F == 1 )
    {
      result = &byte_20000000;
      dword_20000054 = 0;
      v2 = 0;
      while ( 1 )
      {
        byte_2000013F = 1;
        if ( timer - timer < 0x32 )
          break;
LABEL_7:
        if ( (unsigned int)++v2 >= 5 )
          return result;
      }
      while ( (((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 114] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 113]) != dword_20000054 )
      {
        if ( timer - timer >= 0x32 )
          goto LABEL_7;
      }
    }
  }
  return result;
}
// 8: using guessed type int NMI;
// 1FFFF884: using guessed type int dword_1FFFF884;
// 20000000: using guessed type char byte_20000000;
// 20000054: using guessed type int dword_20000054;
// 2000013C: using guessed type char byte_2000013C;
// 2000013E: using guessed type char sendingPacket;
// 2000013F: using guessed type char byte_2000013F;
// 20000140: using guessed type int dword_20000140;
// 200002AD: using guessed type char currentModel;

//----- (0000618C) --------------------------------------------------------
void sub_618C()
{
  int v0; // r0@3
  char v1; // [sp+0h] [bp-8h]@3
  char v2; // [sp+1h] [bp-7h]@3
  __int16 v3; // [sp+2h] [bp-6h]@3

  if ( timer <= 0x14 || timer - dword_20000040 >= 0x7D0 )
  {
    dword_20000040 = timer;
    v0 = div__0(voltageADC * (_DWORD)dword_2710, (unsigned __int16)stickAdjustData[19]);
    v1 = 127;
    v2 = 0;
    v3 = div__0(v0, 10);
    setSensorValue(&v1);
  }
}
// 2710: using guessed type int dword_2710[28];
// 20000040: using guessed type int dword_20000040;
// 20000F18: using guessed type int voltageADC;

//----- (000061EC) --------------------------------------------------------
unsigned int sub_61EC()
{
  unsigned int result; // r0@1
  unsigned int v1; // r0@2
  int v2; // r0@6
  int v3; // r6@11
  int v4; // r1@14
  int v5; // r0@14
  int v6; // r0@16
  int v7; // r0@21
  int v8; // r1@24
  int v9; // r0@24

  result = timer;
  if ( timer < 0x64 )
    return result;
  v1 = div__0(voltageADC * (_DWORD)dword_2710, (unsigned __int16)stickAdjustData[19]);
  if ( v1 >= 0xFA0 )
  {
    if ( v1 < (unsigned int)&byte_DA0[712] && timer - dword_20000038 >= 0x7D0 )
    {
      dword_20000038 = timer;
      beep(523, 100);
      v2 = 370;
      goto LABEL_10;
    }
  }
  else if ( sub_9BC0() == 15 && timer - dword_20000038 >= 0x1F4 )
  {
    dword_20000038 = timer;
    if ( (unsigned int)sub_9BC0() >= 2 )
    {
      beep(1047, 250);
      v2 = 1568;
LABEL_10:
      beep(v2, 250);
      goto LABEL_11;
    }
  }
LABEL_11:
  v3 = usedModelPtr + 96;
  result = *(_BYTE *)(usedModelPtr + 96);
  if ( *(_BYTE *)(usedModelPtr + 96) )
  {
    result = timer - dword_2000001C;
    if ( timer - dword_2000001C < 0x3E8 )
    {
      if ( (unsigned int)*(_BYTE *)(usedModelPtr + 98) << 30 >> 31 )
      {
        v4 = 1;
        v5 = 3;
      }
      else
      {
        v4 = 0;
        v5 = 0;
      }
      v6 = (signed __int16)sensorsFunction(v5, v4, 0);
      if ( (signed __int16)v6 < (unsigned int)*(_WORD *)(v3 + 22) && v6 )
      {
        result = sub_9BC0();
        if ( result == 15 )
        {
          result = timer - dword_2000003C;
          if ( timer - dword_2000003C >= 0x1F4 )
          {
            dword_2000003C = timer;
            result = sub_9BC0();
            if ( result >= 2 )
            {
              beep(1047, 250);
              v7 = 1568;
              return beep(v7, 250);
            }
          }
        }
      }
      else
      {
        if ( (unsigned int)*(_BYTE *)(v3 + 2) << 30 >> 31 )
        {
          v8 = 1;
          v9 = 3;
        }
        else
        {
          v8 = 0;
          v9 = 0;
        }
        result = (signed __int16)sensorsFunction(v9, v8, 0);
        if ( (signed __int16)result < (unsigned int)*(_WORD *)(v3 + 24) )
        {
          if ( result )
          {
            result = 2000;
            if ( timer - dword_2000003C >= 0x7D0 )
            {
              dword_2000003C = timer;
              beep(523, 100);
              v7 = 370;
              return beep(v7, 250);
            }
          }
        }
      }
    }
  }
  return result;
}
// 2710: using guessed type int dword_2710[28];
// 2000001C: using guessed type int dword_2000001C;
// 2000002C: using guessed type int usedModelPtr;
// 20000038: using guessed type int dword_20000038;
// 2000003C: using guessed type int dword_2000003C;
// 20000F18: using guessed type int voltageADC;

//----- (00006350) --------------------------------------------------------
int sensorsFunction4()
{
  unsigned int v0; // r4@1
  int result; // r0@1
  char *v2; // r0@2

  v0 = 0;
  result = activeSensors;
  if ( activeSensors )
  {
    do
    {
      v2 = &sensorsArrayInRam[8 * v0];
      if ( timer - *((_DWORD *)v2 + 1) > 2000 )
      {
        sub_1D76(v2, v2 + 8, 8 * (activeSensors - v0) - 8);
        --activeSensors;
      }
      result = activeSensors;
      ++v0;
    }
    while ( v0 < activeSensors );
  }
  return result;
}
// 4: using guessed type int Reset;
// 20000024: using guessed type int activeSensors;

//----- (000063A0) --------------------------------------------------------
unsigned int __fastcall rxpacketHandle(_BYTE *a1)
{
  _BYTE *buffer; // r4@1
  int packetID; // r1@1
  _BYTE *buffer_plus1; // r0@1
  int *v4; // r1@5
  int ptr; // r1@11
  char *EE4; // r0@13
  signed int v7; // r2@13
  unsigned int sensorIndexInRx; // r5@13
  int v9; // r3@15
  int v10; // r3@17
  int odometerIndex; // r2@23
  int v12; // r3@25
  char fakebyte3; // zf@26
  unsigned int result; // r0@29
  char *sensorIdPRT; // [sp+0h] [bp-28h]@23
  char fakeByte1; // [sp+4h] [bp-24h]@26
  char fakebyte2; // [sp+5h] [bp-23h]@26
  __int16 fakebate4; // [sp+6h] [bp-22h]@26

  buffer = a1;
  dword_20000014 = timer;
  packetID = *a1;
  buffer_plus1 = a1 + 1;
  if ( packetID == 0xA5 )
  {
    byte_20000003 = 1;
    dword_1FFFF884 = buffer_plus1[4] | (buffer_plus1[5] << 8) | (buffer_plus1[6] << 16) | (buffer_plus1[7] << 24);
    goto LABEL_29;
  }
  if ( packetID == 0xAA )
  {
    v4 = (int *)((buffer_plus1[1] << 8) | *buffer_plus1);
    if ( v4 == &dword_FFFC )
    {
      byte_2000013F = 1;
    }
    else if ( v4 == (int *)((char *)&dword_FFFC + 1) )
    {
      dword_20000054 = (buffer_plus1[3] << 8) | buffer_plus1[2];
    }
    else if ( v4 == (int *)((char *)&dword_FFFC + 2) )
    {
      dword_20000030 = (buffer_plus1[3] << 8) | buffer_plus1[2];
      dword_20000034 = (buffer_plus1[5] << 8) | buffer_plus1[4];
    }
    else
    {
      ptr = (int)(buffer + 2);
      if ( buffer[2] != 0xFF )
      {
        RX_BUFFER[0] = buffer[1];
        byte_20000EE5 = buffer[2];
        byte_20000EE6 = buffer[3];
        byte_20000EE7 = buffer[4];
      }
      EE4 = RX_BUFFER;
      v7 = 1;
      sensorIndexInRx = 3;
      do
      {
        if ( *(_BYTE *)(ptr + 4) != 255 )
        {
          v9 = (int)&buffer[4 * v7];
          EE4[4] = *(_BYTE *)(v9 + 1);
          *((_BYTE *)&Reset + (_DWORD)EE4 + 1) = *(_BYTE *)(v9 + 2);
          *((_BYTE *)&Reset + (_DWORD)EE4 + 2) = *(_BYTE *)(v9 + 3);
          *((_BYTE *)&Reset + (_DWORD)EE4 + 3) = *(_BYTE *)(v9 + 4);
        }
        ptr += 8;
        if ( *(_BYTE *)ptr != 255 )
        {
          v10 = (int)&buffer[4 * v7];
          EE4[8] = *(_BYTE *)(v10 + 5);
          *((_BYTE *)&NMI + (_DWORD)EE4 + 1) = *(_BYTE *)(v10 + 6);
          *((_BYTE *)&NMI + (_DWORD)EE4 + 2) = *(_BYTE *)(v10 + 7);
          *((_BYTE *)&NMI + (_DWORD)EE4 + 3) = *(_BYTE *)(v10 + 8);
        }
        EE4 += 8;
        v7 += 2;
        --sensorIndexInRx;
      }
      while ( sensorIndexInRx );
      if ( !dword_20000020 || timer - dword_20000020 > (unsigned int)&unk_5DC )
      {
        if ( (unsigned int)++dword_20000050 >= 8 )
        {
          dword_20000050 = 0;
          dword_20000020 = timer;
        }
        do
        {
          sensorIdPRT = &RX_BUFFER[4 * sensorIndexInRx];
          setSensorValue(sensorIdPRT);
          odometerIndex = *(_BYTE *)(usedModelPtr + 135);
          if ( odometerIndex != 255 && RX_BUFFER[4 * sensorIndexInRx] == 2 )
          {
            v12 = (unsigned __int8)sensorIdPRT[1];
            if ( v12 == odometerIndex )
            {
              fakeByte1 = 0x7C;
              fakebyte2 = v12;
              fakebyte3 = (*(_BYTE *)(usedModelPtr + 138) | (*(_BYTE *)(usedModelPtr + 139) << 8) | (*(_BYTE *)(usedModelPtr + 140) << 16) | (*(_BYTE *)(usedModelPtr + 141) << 24)) == 0;
              fakebate4 = *(_BYTE *)(usedModelPtr + 138) | (unsigned __int16)(*(_BYTE *)(usedModelPtr + 139) << 8);
              setSensorValue(&fakeByte1);
              fakeByte1 = 125;
              fakebyte3 = (*(_BYTE *)(usedModelPtr + 142) | (*(_BYTE *)(usedModelPtr + 143) << 8) | (*(_BYTE *)(usedModelPtr + 144) << 16) | (*(_BYTE *)(usedModelPtr + 145) << 24)) == 0;
              fakebate4 = *(_BYTE *)(usedModelPtr + 142) | (unsigned __int16)(*(_BYTE *)(usedModelPtr + 143) << 8);
              setSensorValue(&fakeByte1);
              fakeByte1 = 126;
              fakebate4 = div__0(
                            6
                          * *((_WORD *)sensorIdPRT + 1)
                          * ((*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136)),
                            (signed int)dword_2710);
              setSensorValue(&fakeByte1);
            }
          }
          ++sensorIndexInRx;
        }
        while ( sensorIndexInRx < 7 );
        setupDMA((_WORD *)RX_BUFFER, 28u, 0xFFu);
      }
    }
LABEL_29:
    result = *buffer;
    if ( result == 0xA5 )
      return result;
  }
  result = timer - 1;
  dword_2000001C = timer - 1;
  return result;
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// 2710: using guessed type int dword_2710[28];
// FFFC: using guessed type int dword_FFFC;
// 1FFFF884: using guessed type int dword_1FFFF884;
// 20000003: using guessed type char byte_20000003;
// 20000014: using guessed type int dword_20000014;
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 2000002C: using guessed type int usedModelPtr;
// 20000030: using guessed type int dword_20000030;
// 20000034: using guessed type int dword_20000034;
// 20000050: using guessed type int dword_20000050;
// 20000054: using guessed type int dword_20000054;
// 2000013F: using guessed type char byte_2000013F;
// 20000EE5: using guessed type char byte_20000EE5;
// 20000EE6: using guessed type char byte_20000EE6;
// 20000EE7: using guessed type char byte_20000EE7;

//----- (000065A8) --------------------------------------------------------
int sensorsListMainScreen()
{
  int result; // r0@1
  signed int v1; // r0@6
  unsigned int v2; // r4@12
  int v3; // r5@14
  char *v4; // r7@14
  int v5; // r0@14
  signed int v6; // r2@17
  char *v7; // r0@17
  char v8; // [sp+10h] [bp-E0h]@14
  __int16 v9; // [sp+42h] [bp-AEh]@14
  char v10; // [sp+74h] [bp-7Ch]@14
  _BYTE v11[3]; // [sp+75h] [bp-7Bh]@17

  result = *(_BYTE *)(usedModelPtr + 96);
  if ( *(_BYTE *)(usedModelPtr + 96) )
  {
    if ( timer - dword_2000001C < 0x3E8 )
    {
      JUMPOUT((unsigned int)*(_BYTE *)(usedModelPtr + 98) << 30 >> 31, 0, &unk_65D6);
      JUMPOUT(&unk_6614);
    }
    v1 = 1;
    if ( *(_BYTE *)(usedModelPtr + 129) != 255 )
      v1 = 0;
    if ( *(_BYTE *)(usedModelPtr + 131) != 255 )
      v1 = 0;
    if ( *(_BYTE *)(usedModelPtr + 133) != 255 || !v1 )
      JUMPOUT(unk_6792);
    v2 = 0;
    do
    {
      result = activeSensors;
      if ( v2 < activeSensors )
      {
        v3 = 8 * v2;
        v4 = &sensorsArrayInRam[8 * v2];
        formatSensorData((unsigned __int8)*v4, v4[(_DWORD)byte_1], &v9);
        GetSensorName((unsigned __int8)*v4);
        sub_1C64(&v8, v5);
        sprintf((int)&v10, "%s:%s", v4[(_DWORD)byte_1] + 1, &v9);
        if ( (unsigned int)strLength(&v10) <= 0xD )
        {
          v6 = v3 + 35;
          v7 = &v10;
          goto LABEL_18;
        }
        if ( sensorsArrayInRam[v3] == 2 )
        {
          v6 = v3 + 35;
          v7 = v11;
LABEL_18:
          result = displayTextAt(v7, 16, v6, 0);
          goto LABEL_19;
        }
        displayTextAt(&v10, 12, v3 + 35, 0);
        result = drawLine(122, 33, 122, 57, 0);
      }
LABEL_19:
      ++v2;
    }
    while ( v2 < 3 );
  }
  return result;
}
// 2000001C: using guessed type int dword_2000001C;
// 20000024: using guessed type int activeSensors;
// 2000002C: using guessed type int usedModelPtr;

//----- (000068A8) --------------------------------------------------------
int sub_68A8()
{
  int v0; // r4@1
  char *v1; // r0@3
  int v2; // r0@4
  unsigned int v3; // r0@12
  char **v5; // r2@19
  unsigned int v6; // r1@19
  int **v7; // r0@19

  v0 = 0;
  while ( 1 )
  {
    callSetupDMAandSend();
    callSetupDMAandSend();
    fillRegion(0, 1, 38, 2, 0);
    fillRegion(0, 5, 38, 6, 0);
    fillRegion(0, 9, 38, 10, 0);
    displayGFX((int)&dword_CBBC, 41, 0);
    fillRegion(89, 1, 127, 2, 0);
    fillRegion(89, 5, 127, 6, 0);
    fillRegion(89, 9, 127, 10, 0);
    displayGFX((int)&unk_CBD4, 26, 18);
    displayGFX((int)&unk_CBEC, 72, 18);
    drawLine(22, 14, 59, 53, v0 != 0);
    drawLine(23, 15, 58, 52, v0 != 0);
    drawLine(68, 14, 105, 53, v0 != 1);
    drawLine(69, 15, 104, 52, v0 != 1);
    v1 = v0 ? "Functions setup" : 52775;
    displayTextAt2(v1, 64, 56, 0);
    LCD_updateCALL();
    v2 = getKeyCode();
    if ( v2 == 11 )
      break;
    if ( v2 == 9 || v2 == 8 )
    {
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
    }
    else if ( v2 == 10 )
    {
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
      if ( !v0 )
      {
        v5 = (char **)&unk_D488;
        v6 = 14;
        v7 = off_CBC8;
        goto LABEL_21;
      }
      v3 = *(_BYTE *)(usedModelPtr + 9);
      if ( *(_BYTE *)(usedModelPtr + 9) )
      {
        if ( v3 > 1 )
        {
          if ( v3 > 2 )
            factoryModeMenu(&unk_CBE0, 0xDu, (char **)&unk_D420);
          else
            factoryModeMenu(&unk_CBE0, 0xCu, (char **)&unk_D3C0);
        }
        else
        {
          factoryModeMenu(&unk_CBE0, 0xBu, (char **)&unk_D368);
        }
      }
      else
      {
        v5 = (char **)&unk_D308;
        v6 = 12;
        v7 = (int **)&unk_CBE0;
LABEL_21:
        factoryModeMenu(v7, v6, v5);
      }
    }
  }
  beep(784, 75);
  return beep(523, 75);
}
// CBBC: using guessed type int dword_CBBC;
// CBC8: using guessed type int *off_CBC8[2];
// 2000002C: using guessed type int usedModelPtr;

//----- (00006AA8) --------------------------------------------------------
int __fastcall factoryModeMenu(_DWORD *a1, unsigned int a2, char **a3)
{
  char **v3; // r6@1
  unsigned int v4; // r4@2
  int v5; // r4@2
  int v6; // r0@2
  int v7; // r0@2
  unsigned int v8; // r4@2
  unsigned int v9; // r5@4
  signed int i; // r7@4
  int v11; // r0@6
  __int16 v13; // r1@16
  int v14; // r0@16
  int v15; // r0@26
  int v16; // r5@29
  unsigned int v17; // r4@31
  unsigned int v18; // [sp+4h] [bp-2Ch]@1
  int v19; // [sp+8h] [bp-28h]@2
  unsigned int v20; // [sp+Ch] [bp-24h]@1
  _DWORD *v21; // [sp+10h] [bp-20h]@1
  unsigned int v22; // [sp+14h] [bp-1Ch]@1

  v21 = a1;
  v22 = a2;
  v18 = 0;
  v3 = a3;
  v20 = a2 - 1;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          byte_20000002 = 0;
          callSetupDMAandSend();
          v4 = (unsigned int)(124 - *v21) >> 1;
          fillRegion(0, 1, v4 - 1, 2, 0);
          fillRegion(0, 5, v4 - 1, 6, 0);
          fillRegion(0, 9, v4 - 1, 10, 0);
          displayGFX((int)v21, v4 + 2, 0);
          v5 = *v21 + v4 + 4;
          fillRegion(v5, 1, 127, 2, 0);
          fillRegion(v5, 5, 127, 6, 0);
          fillRegion(v5, 9, 127, 10, 0);
          div_Other(v18, 6u);
          v7 = 6 * v6;
          v8 = v7 + 5;
          v19 = v7;
          if ( v7 + 5 >= v22 )
            v8 = v22 - 1;
          v9 = v7;
          for ( i = 16; v9 <= v8; ++v9 )
          {
            displayTextAt(v3[2 * v9], 8, i, 0);
            i += 8;
          }
          fillRegion(0, 16, 7, 63, 1);
          displayGFX((int)&arrow_gfx, 0, 8 * (v18 - v19) + 16);
          LCD_updateCALL();
          v11 = getKeyCode();
          if ( v11 != 8 && v11 != 24 )
            break;
          if ( v18 < v20 )
          {
            ++v18;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_16:
              beep(784, 15);
              v13 = 15;
              v14 = 0;
              goto LABEL_34;
            }
          }
        }
        if ( v11 != 9 && v11 != 23 )
          break;
        if ( v18 )
        {
          --v18;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_16;
        }
      }
      if ( v11 != 10 )
        break;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
      if ( !v18
        && (_UNKNOWN *)v3 == &unk_D488
        && rxsettings[146 * (unsigned __int8)currentModel + 106]
        && timer - dword_2000001C < 0x3E8 )
      {
        do
        {
          callSetupDMAandSend();
          displayTextAt2("For you safety", 64, 8, 0);
          displayTextAt2("Please turn off", 64, 16, 0);
          displayTextAt2("the receiver", 64, 24, 0);
          displayTextAt2("first", 64, 32, 0);
          displayTextAt2("OK", 64, 48, 0);
          drawLine(48, 44, 80, 58, 0);
          LCD_updateCALL();
          v15 = getKeyCode();
        }
        while ( v15 != 10 && v15 != 11 );
        v13 = 100;
        v14 = 523;
        goto LABEL_34;
      }
      memcpy(tmpModelData, (int)&rxsettings[146 * (unsigned __int8)currentModel + 10], 146u);
      v16 = (int)&v3[2 * v18];
      if ( (*(int (**)(void))(v16 + 4))() )
      {
        saveModelSettings();
        if ( v3 == &off_D248 )
        {
          v17 = 0;
          CRC_STICKDATA = crcCheck((_BYTE *)stickAdjustData, 40);
          do
          {
            saveEepromData((_BYTE *)stickAdjustData, v17 << 12, 42u);
            someSPImethod();
            ++v17;
          }
          while ( v17 < 4 );
        }
        v13 = 100;
        v14 = 1047;
LABEL_34:
        beep(v14, v13);
      }
      else if ( *(int (**)())(v16 + 4) != RxSetupPage )
      {
        memcpy(&rxsettings[146 * (unsigned __int8)currentModel + 10], (int)tmpModelData, 0x92u);
        v13 = 100;
        v14 = 523;
        goto LABEL_34;
      }
    }
  }
  while ( v11 != 11 );
  byte_20000002 = 1;
  return beep(523, 100);
}
// 8: using guessed type int NMI;
// D248: using guessed type char *off_D248;
// 20000002: using guessed type char byte_20000002;
// 2000001C: using guessed type int dword_2000001C;
// 200002AD: using guessed type char currentModel;
// 20000E40: using guessed type __int16 CRC_STICKDATA;

//----- (00006D5C) --------------------------------------------------------
int __fastcall displayPageHeader(_BYTE *a1)
{
  _BYTE *v1; // r6@1
  char *v2; // r0@1
  unsigned int v3; // r4@2
  int v4; // r4@2
  int result; // r0@2

  v1 = a1;
  v2 = strLength(a1);
  if ( (unsigned int)v2 >= 0x10 )
  {
    result = displayTextAt(v1, 0, 0, 0);
  }
  else
  {
    v3 = (unsigned int)(124 - 8 * (_DWORD)v2) >> 1;
    fillRegion(0, 1, v3 - 1, 2, 0);
    fillRegion(0, 5, v3 - 1, 6, 0);
    displayTextAt(v1, v3 + 2, 0, 0);
    v4 = 8 * (_DWORD)strLength(v1) + v3 + 4;
    fillRegion(v4, 1, 127, 2, 0);
    result = fillRegion(v4, 5, 127, 6, 0);
  }
  return result;
}

//----- (00006DD4) --------------------------------------------------------
signed int __fastcall showNavigationPage(_BYTE *namePtr, unsigned int numberOfItems, char **pageName)
{
  char **pageNAme; // r6@1
  int v4; // r0@2
  unsigned int v5; // r4@3
  unsigned int v6; // r5@6
  signed int v7; // r7@6
  int v8; // r0@12
  signed int result; // r0@18
  unsigned int v10; // r0@19
  char v11; // zf@19
  __int16 v12; // r1@22
  int v13; // r0@22
  int v14; // r5@28
  signed int (*v15)(); // r0@28
  unsigned int v16; // r4@34
  signed int (*v17)(); // r0@38
  unsigned int v18; // [sp+4h] [bp-2Ch]@1
  unsigned int v19; // [sp+8h] [bp-28h]@2
  unsigned int v20; // [sp+Ch] [bp-24h]@1
  _BYTE *v21; // [sp+10h] [bp-20h]@1
  unsigned int v22; // [sp+14h] [bp-1Ch]@1

  v21 = namePtr;
  v22 = numberOfItems;
  v18 = 0;
  pageNAme = pageName;
  v20 = numberOfItems - 1;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        byte_20000002 = 0;
        callSetupDMAandSend();
        displayPageHeader(v21);
        div_Other(v18, 6u);
        v19 = 6 * v4;
        if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
          v5 = v19 + 5;
        else
          v5 = 0;
        if ( v5 >= v22 )
          v5 = v22 - 1;
        v6 = 6 * v4;
        v7 = 13;
        if ( v19 <= v5 )
        {
          do
          {
            displayTextAt(pageNAme[2 * v6], 8, v7, 0);
            v7 += 8;
            ++v6;
          }
          while ( v6 <= v5 );
        }
        if ( !rxsettings[146 * (unsigned __int8)currentModel + 106] )
          fillRegion(56, 13, 72, 21, 1);
        fillRegion(0, 13, 7, 63, 1);
        displayGFX((int)&arrow_gfx, 0, 8 * (v18 - v19) + 13);
        LCD_updateCALL();
        v8 = getKeyCode();
        if ( v8 == 9 || v8 == 23 )
        {
          v10 = v18;
          v11 = v18 == 0;
          goto LABEL_20;
        }
        if ( v8 != 8 && v8 != 24 )
          break;
        v10 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 106];
        v11 = v10 == 0;
        if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
        {
          if ( v18 < v20 )
          {
            ++v18;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_22;
          }
        }
        else
        {
LABEL_20:
          if ( !v11 )
          {
            v18 = v10 - 1;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_22:
              beep(784, 15);
              v12 = 15;
              v13 = 0;
              goto LABEL_41;
            }
          }
        }
      }
      if ( v8 != 10 )
        break;
      v14 = (int)&pageNAme[2 * v18];
      v15 = *(signed int (**)())(v14 + 4);
      if ( v15 != ResetOdo1Menu && v15 != ResetOdo2Menu && (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
      memcpy(tmpModelData, (int)&rxsettings[146 * (unsigned __int8)currentModel + 10], 146u);
      if ( (*(int (**)(void))(v14 + 4))() )
      {
        saveModelSettings();
        if ( pageNAme == &off_D248 )            // stick adjust
        {
          v16 = 0;
          CRC_STICKDATA = crcCheck((_BYTE *)stickAdjustData, 40);
          do
          {
            saveEepromData((_BYTE *)stickAdjustData, v16 << 12, 0x2Au);
            someSPImethod();
            ++v16;
          }
          while ( v16 < 4 );
        }
        beep(1047, 100);
      }
      else if ( *(int (**)())(v14 + 4) != SpeedDistancePage )
      {
        memcpy(&rxsettings[146 * (unsigned __int8)currentModel + 10], (int)tmpModelData, 0x92u);
        v17 = *(signed int (**)())(v14 + 4);
        if ( v17 != ResetOdo1Menu && v17 != ResetOdo2Menu )
        {
          v12 = 100;
          v13 = 523;
LABEL_41:
          beep(v13, v12);
        }
      }
    }
  }
  while ( v8 != 11 );
  beep(523, 100);
  result = 1;
  byte_20000002 = 1;
  return result;
}
// 8: using guessed type int NMI;
// D248: using guessed type char *off_D248;
// 20000002: using guessed type char byte_20000002;
// 200002AD: using guessed type char currentModel;
// 20000E40: using guessed type __int16 CRC_STICKDATA;

//----- (00006FE0) --------------------------------------------------------
signed int sub_6FE0()
{
  unsigned int v0; // r5@1
  unsigned int v1; // r6@1
  int v2; // r4@2
  _BYTE *v3; // r0@3
  unsigned int v4; // r0@5
  int *v5; // r0@6
  signed int v6; // r0@8
  int v7; // r0@12
  char v9; // cf@25
  int v10; // r0@34
  int v11; // r0@37
  int v12; // r1@37
  unsigned __int8 v13; // zf@37
  char v14; // nf@37
  unsigned __int8 v15; // vf@37
  _BYTE *v16; // r0@41
  signed int v17; // r1@41
  unsigned int v18; // r0@49
  char v19; // r2@59
  int v20; // r0@62
  int v21; // r0@63
  int v22; // r0@63
  signed int v23; // r0@65
  _BYTE *v24; // r1@68
  signed int v25; // r0@68
  signed int v26; // r0@71
  int v27; // [sp+0h] [bp-20h]@2
  int v28; // [sp+4h] [bp-1Ch]@2

  v0 = 0;
  v1 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v28 = 0;
            v27 = 3237955;
            callSetupDMAandSend();
            displayPageHeader("Mix");
            aMix1[5] = v0 + 49;
            displayTextAt(aMix1, 12, 8, 0);
            displayTextAt("Mix is", 12, 16, 0);
            v2 = 4 * v0;
            v3 = (_BYTE *)((unsigned int)*(_BYTE *)(4 * v0 + usedModelPtr + 62) >> 7 ? 51831 : "Off");
            displayTextAt(v3, 92, 16, 0);
            displayTextAt("Master", 12, 24, 0);
            v4 = *(_BYTE *)(v2 + usedModelPtr + 62) & 0xF;
            if ( v4 >= 6 )
            {
              var_X_val = v4 + 59;
              v5 = (int *)&var_X;
            }
            else
            {
              BYTE2(v27) = v4 + 49;
              v5 = &v27;
            }
            displayTextAt(v5, 92, 24, 0);
            displayTextAt("Slave", 12, 32, 0);
            BYTE2(v27) = ((unsigned int)*(_BYTE *)(4 * v0 + usedModelPtr + 62) << 25 >> 29) + 49;
            displayTextAt(&v27, 92, 32, 0);
            displayTextAt("Pos. mix", 12, 40, 0);
            intToString(*(_BYTE *)(v2 + usedModelPtr + 63), a100_1, 4u);
            displayTextAt(a100_1, 84, 40, 0);
            displayTextAt("Neg. mix", 12, 48, 0);
            intToString(*(_BYTE *)(v2 + usedModelPtr + 64), a100_1, 4u);
            displayTextAt(a100_1, 84, 48, 0);
            displayTextAt("Offset", 12, 56, 0);
            intToString(*(_BYTE *)(v2 + usedModelPtr + 65), a100_0, 3u);
            v6 = *(_BYTE *)(v2 + usedModelPtr + 65);
            if ( v6 < 10 )
            {
              if ( v6 >= 1 )
                a100_0[1] = 43;
            }
            else
            {
              a100_0[0] = 43;
            }
            displayTextAt(a100_0, 92, 56, 0);
            displayGFX((int)&arrow_gfx, 4, 8 * v1 + 8);
            LCD_updateCALL();
            v7 = getKeyCode();
            if ( v7 != 8 && v7 != 24 )
              break;
            if ( v1 < 7 )
            {
              switch ( v1 )
              {
                case 0u:
                  if ( v0 )
                  {
                    v0 = (unsigned __int8)(v0 - 1);
                    v9 = (unsigned int)sub_9BC0() >= 2;
                    goto LABEL_26;
                  }
                  continue;
                case 1u:
                  *(_BYTE *)(4 * v0 + usedModelPtr + 62) = *(_BYTE *)(4 * v0 + usedModelPtr + 62) & 0x7F | (((unsigned __int8)(*(_BYTE *)(4 * v0 + usedModelPtr + 62) >> 7) ^ 1) << 7);
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    break;
                  continue;
                case 2u:
                  if ( *(_BYTE *)(v2 + usedModelPtr + 62) & 0xF )
                  {
                    *(_BYTE *)(v2 + usedModelPtr + 62) = 16 * (*(_BYTE *)(v2 + usedModelPtr + 62) >> 4) | ((*(_BYTE *)(v2 + usedModelPtr + 62) & 0xF) - 1) & 0xF;
                    if ( (unsigned int)sub_9BC0() >= 2 )
                      break;
                  }
                  continue;
                case 3u:
                  v10 = *(_BYTE *)(v2 + usedModelPtr + 62);
                  if ( (unsigned int)(v10 << 25) >> 29 )
                  {
                    *(_BYTE *)(v2 + usedModelPtr + 62) = (16
                                                        * ((unsigned int)*(_BYTE *)(v2 + usedModelPtr + 62) << 25 >> 29)
                                                        - 16) & 0x7F | *(_BYTE *)(v2 + usedModelPtr + 62) & 0x8F;
                    if ( (unsigned int)sub_9BC0() >= 2 )
                      break;
                  }
                  continue;
                case 4u:
                  v11 = v2 + usedModelPtr + 32;
                  v12 = *(_BYTE *)(v2 + usedModelPtr + 63);
                  v15 = __OFSUB__(v12, -100);
                  v13 = v12 == -100;
                  v14 = v12 + 100 < 0;
                  goto LABEL_38;
                case 5u:
                  v16 = (_BYTE *)(v2 + usedModelPtr + 64);
                  v17 = *v16;
                  if ( v17 > -100 )
                  {
                    *v16 = v17 - 1;
                    if ( (unsigned int)sub_9BC0() >= 2 )
                      break;
                  }
                  continue;
                case 6u:
                  v12 = v2 + usedModelPtr + 64;
                  v11 = *(_BYTE *)(v2 + usedModelPtr + 65);
                  v15 = __OFSUB__(v11, -50);
                  v13 = v11 == -50;
                  v14 = v11 + 50 < 0;
                  if ( v11 > -50 )
                  {
                    *(_BYTE *)(v2 + usedModelPtr + 65) = v11 - 1;
                    v18 = sub_9BC0();
                    v9 = v18 >= 2;
                    if ( v18 >= 2 )
                      break;
LABEL_26:
                    if ( v9 )
                      break;
                    continue;
                  }
LABEL_38:
                  if ( (unsigned __int8)(v14 ^ v15) | v13 )
                    continue;
                  *(_BYTE *)(v11 + 31) = v12 - 1;
                  if ( (unsigned int)sub_9BC0() < 2 )
                    continue;
                  break;
                default:
                  continue;
              }
LABEL_50:
              beep(784, 15);
              beep(0, 15);
            }
          }
          if ( v7 != 9 && v7 != 23 )
            break;
          if ( v1 < 7 )
          {
            switch ( v1 )
            {
              case 0u:
                if ( v0 < 2 )
                {
                  v0 = (unsigned __int8)(v0 + 1);
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              case 1u:
                *(_BYTE *)(4 * v0 + usedModelPtr + 62) = *(_BYTE *)(4 * v0 + usedModelPtr + 62) & 0x7F | (((unsigned __int8)(*(_BYTE *)(4 * v0 + usedModelPtr + 62) >> 7) ^ 1) << 7);
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_50;
                break;
              case 2u:
                v19 = *(_BYTE *)(v2 + usedModelPtr + 62);
                if ( (v19 & 0xFu) < 7 )
                {
                  *(_BYTE *)(v2 + usedModelPtr + 62) = 16 * (*(_BYTE *)(v2 + usedModelPtr + 62) >> 4) | ((v19 & 0xF) + 1) & 0xF;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              case 3u:
                v20 = *(_BYTE *)(v2 + usedModelPtr + 62);
                if ( (unsigned int)(v20 << 25) >> 29 < 5 )
                {
                  v21 = __ROR4__(v20, 7);
                  v22 = __ROR4__(v21 + 0x20000000, 25);
                  *(_BYTE *)(v2 + usedModelPtr + 62) = v22;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              case 4u:
                v23 = *(_BYTE *)(v2 + usedModelPtr + 63);
                if ( v23 < 100 )
                {
                  *(_BYTE *)(v2 + usedModelPtr + 63) = v23 + 1;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              case 5u:
                v24 = (_BYTE *)(v2 + usedModelPtr + 64);
                v25 = *v24;
                if ( v25 < 100 )
                {
                  *v24 = v25 + 1;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              case 6u:
                v26 = *(_BYTE *)(v2 + usedModelPtr + 65);
                if ( v26 < 50 )
                {
                  *(_BYTE *)(v2 + usedModelPtr + 65) = v26 + 1;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_50;
                }
                break;
              default:
                continue;
            }
          }
        }
        if ( v7 != 22 )
          break;
        switch ( v1 )
        {
          case 4u:
            *(_BYTE *)(v2 + usedModelPtr + 63) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_50;
            break;
          case 5u:
            *(_BYTE *)(v2 + usedModelPtr + 64) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_50;
            break;
          case 6u:
            *(_BYTE *)(v2 + usedModelPtr + 65) = 0;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_50;
            break;
        }
      }
      if ( v7 != 10 )
        break;
      if ( v1 < 6 )
        v1 = (unsigned __int8)(v1 + 1);
      else
        v1 = 0;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_50;
    }
    if ( v7 == 25 )
      return 1;
    if ( v7 == 11 )
      return 0;
  }
}
// 2000000D: using guessed type char var_X;
// 2000000F: using guessed type char var_X_val;
// 2000002C: using guessed type int usedModelPtr;

//----- (00007424) --------------------------------------------------------
signed int modelCopyPage()
{
  int v0; // r6@1
  unsigned int v1; // r4@1
  unsigned int v2; // r5@1
  char *v3; // r0@3
  char *v4; // r0@5
  int v5; // r0@6
  signed int result; // r0@13
  char v7; // cf@19
  unsigned int v8; // r0@24

  v0 = 0;
  v1 = (unsigned __int8)currentModel;
  v2 = (unsigned __int8)currentModel;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("Model copy");
          printNumberAsStringAt(v2 + 1, &aModel00[6], 2u);
          displayTextAt(aModel00, 8, 8, 0);
          displayTextAt(&rxsettings[146 * v2 + 10], 8, 16, 0);
          v3 = rxsettings[146 * v2 + 19] ? &heli_img : &plain_img;
          displayGFX((int)v3, 74, 8);
          displayTextAt2("Copy to", 64, 24, 0);
          printNumberAsStringAt(v1 + 1, &aModel00[6], 2u);
          displayTextAt(aModel00, 8, 32, 0);
          displayTextAt(&rxsettings[146 * v1 + 10], 8, 40, 0);
          v4 = rxsettings[146 * v1 + 19] ? &heli_img : &plain_img;
          displayGFX((int)v4, 74, 32);
          displayGFX((int)&arrow_gfx, 0, 24 * v0 + 8);
          displayTextAt2("\"MENU\" to copy", 64, 56, 0);
          LCD_updateCALL();
          v5 = getKeyCode();
          if ( v5 != 8 && v5 != 24 )
            break;
          if ( v0 )
          {
            if ( v1 )
            {
              --v1;
              v7 = (unsigned int)sub_9BC0() >= 2;
LABEL_20:
              if ( v7 )
                goto LABEL_25;
            }
          }
          else if ( v2 )
          {
            --v2;
            v8 = sub_9BC0();
            v7 = v8 >= 2;
            if ( v8 >= 2 )
              goto LABEL_25;
            goto LABEL_20;
          }
        }
        if ( v5 != 9 && v5 != 23 )
          break;
        if ( v0 )
        {
          if ( v1 < 0x13 )
          {
            ++v1;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_25;
          }
        }
        else if ( v2 < 0x13 )
        {
          ++v2;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_25:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v5 != 10 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_25;
    }
    if ( v5 == 22 )
      break;
    if ( v5 == 11 )
      return 0;
  }
  result = sub_23F4();
  if ( result )
  {
    memcpy(&rxsettings[146 * v1 + 10], (int)&rxsettings[146 * v2 + 10], 0x92u);
    result = 1;
  }
  return result;
}
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// 200002AD: using guessed type char currentModel;

//----- (000075BC) --------------------------------------------------------
signed int modelNamePAge()
{
  unsigned int v0; // r4@2
  int v1; // r0@4
  int v2; // r5@4
  unsigned int v3; // r6@4
  char v4; // r0@5
  signed int v5; // r3@5
  char *v6; // r2@5
  unsigned int v7; // r1@6
  int *v8; // r0@11
  int v9; // r0@12
  char v11; // r4@23
  char v12; // r4@29
  int v13; // r0@36
  char v14; // [sp+0h] [bp-50h]@4
  char v15; // [sp+1h] [bp-4Fh]@4
  char v16; // [sp+10h] [bp-40h]@9
  unsigned int v17; // [sp+30h] [bp-20h]@1

  v17 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            callSetupDMAandSend();
            displayPageHeader("Model name");
            printNumberAsStringAt((unsigned __int8)currentModel + 1, &aModel00[6], 2u);
            displayTextAt(aModel00, 32, 8, 0);
            displayTextAt((_BYTE *)usedModelPtr, 32, 16, 0);
            v0 = *(_BYTE *)(usedModelPtr + v17);
            if ( v0 - 32 >= 0x60 )
              v0 = 32;
            v14 = v0;
            v15 = 0;
            displayTextAt(&v14, 8 * v17 + 32, 16, 1);
            div_Other(v0 - 32, 0x30u);
            v2 = 48 * v1 + 32;
            v3 = 0;
            do
            {
              v4 = 0;
              v5 = 16;
              v6 = &v14;
              do
              {
                v7 = (unsigned __int8)(16 * v3 + v2 + v4);
                if ( v7 >= 0x80 )
                  LOBYTE(v7) = 32;
                *v6++ = v7;
                ++v4;
                --v5;
              }
              while ( v5 );
              v16 = 0;
              displayTextAt(&v14, 0, 8 * v3++ + 32, 0);
            }
            while ( v3 < 3 );
            v14 = v0;
            v15 = 0;
            displayTextAt(&v14, 8 * (v0 - v2) & 0x7F, 8 * ((v0 - v2) >> 4) + 32, 1);
            v8 = v2 == 32 ? &dword_7778 : &unk_7774;
            displayTextAt(v8, 96, 56, 0);
            LCD_updateCALL();
            v9 = getKeyCode();
            if ( v9 != 8 && v9 != 24 )
              break;
            if ( v0 > 0x20 )
              v11 = v0 - 1;
            else
              v11 = 127;
            *(_BYTE *)(usedModelPtr + v17) = v11;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_27:
              beep(784, 15);
              beep(0, 15);
            }
          }
          if ( v9 != 9 && v9 != 23 )
            break;
          if ( v0 < 0x7F )
            v12 = v0 + 1;
          else
            v12 = 32;
          *(_BYTE *)(usedModelPtr + v17) = v12;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_27;
        }
        if ( v9 != 22 )
          break;
        memcpy((_BYTE *)usedModelPtr, 53625, 9u);
        printNumberAsStringAt((unsigned __int8)currentModel + 1, (char *)(usedModelPtr + 6), 2u);
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_27;
      }
      if ( v9 != 10 )
        break;
      if ( v17 < 7 )
        v13 = v17 + 1;
      else
        v13 = 0;
      v17 = v13;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_27;
    }
    if ( v9 == 25 )
      return 1;
    if ( v9 == 11 )
      return 0;
  }
}
// 7778: using guessed type int dword_7778;
// 2000002C: using guessed type int usedModelPtr;
// 200002AD: using guessed type char currentModel;

//----- (00007780) --------------------------------------------------------
signed int modelResetPage()
{
  unsigned int v0; // r4@1
  char *v1; // r0@3
  int v2; // r0@4
  signed int result; // r0@10
  char *v4; // r5@20

  v0 = (unsigned __int8)currentModel;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Model reset");
        displayTextAt2("\"OK\" to reset", 64, 56, 0);
        printNumberAsStringAt(v0 + 1, &aModel00[6], 2u);
        displayTextAt(aModel00, 8, 24, 0);
        displayTextAt(&rxsettings[146 * v0 + 10], 8, 32, 0);
        v1 = rxsettings[146 * v0 + 19] ? &heli_img : &plain_img;
        displayGFX((int)v1, 74, 24);
        displayGFX((int)&arrow_gfx, 0, 24);
        LCD_updateCALL();
        v2 = getKeyCode();
        if ( v2 != 8 && v2 != 24 )
          break;
        if ( v0 )
        {
          --v0;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_15:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v2 != 9 && v2 != 23 )
        break;
      if ( v0 < 0x13 )
      {
        ++v0;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_15;
      }
    }
    if ( v2 == 10 )
      break;
    if ( v2 == 11 )
      return 0;
  }
  result = sub_23F4();
  if ( result )
  {
    v4 = &rxsettings[146 * v0];
    memcpy(v4 + 10, 53625, 0x92u);
    printNumberAsStringAt(v0 + 1, v4 + 16, 2u);
    result = 1;
  }
  return result;
}
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// 200002AD: using guessed type char currentModel;

//----- (00007888) --------------------------------------------------------
signed int modelSelectPage()
{
  unsigned int v0; // r4@1
  char *v1; // r0@3
  int v2; // r0@4
  char *v4; // r0@19
  unsigned int v5; // r0@21
  int v6; // r0@22
  unsigned __int8 v7; // [sp+0h] [bp-38h]@21
  __int16 v8; // [sp+1h] [bp-37h]@21
  char v9; // [sp+3h] [bp-35h]@21
  char v10; // [sp+4h] [bp-34h]@21

  v0 = (unsigned __int8)currentModel;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Model select");
        printNumberAsStringAt(v0 + 1, &aModel00[6], 2u);
        displayTextAt(aModel00, 36, 16, 0);
        displayGFX((int)&arrow_gfx, 28, 16);
        displayTextAt(&rxsettings[146 * v0 + 10], 32, 32, 0);
        v1 = rxsettings[146 * v0 + 19] ? &heli_img : &plain_img;
        displayGFX((int)v1, 36, 48);
        LCD_updateCALL();
        v2 = getKeyCode();
        if ( v2 != 8 && v2 != 24 )
          break;
        if ( v0 )
        {
          --v0;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_15:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v2 != 9 && v2 != 23 )
        break;
      if ( v0 < 0x13 )
      {
        ++v0;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_15;
      }
    }
    if ( v2 == 10 || v2 == 25 )
      break;
    if ( v2 == 11 )
      return 0;
  }
  currentModel = v0;
  usedModelPtr = (int)&rxsettings[146 * v0 + 10];
  v4 = &rxsettings[146 * (unsigned __int8)v0];
  if ( v4[106] )
  {
    dword_20000140 = 0;
    dword_1FFFF884 = -1;
    if ( byte_2000013C )
    {
      sendingPacket = 1;
      v7 = 0x9Bu;
      v5 = (unsigned __int8)v4[109] | ((unsigned __int8)v4[110] << 8) | ((unsigned __int8)v4[111] << 16) | ((unsigned __int8)v4[112] << 24);
      v8 = v5;
      v9 = v5 >> 16;
      v10 = BYTE3(v5);
      sendPacketToRadio(&v7, (char *)(v5 >> 16), (int)&v7);
      addPacketToResend1FFFFCF5When2000013C(0x9A);
      sendingPacket = 0;
      if ( byte_2000013F == 1 )
      {
        dword_20000054 = 0;
        v6 = 0;
        while ( 1 )
        {
          byte_2000013F = 1;
          if ( timer - timer < 0x32 )
            break;
LABEL_26:
          if ( (unsigned int)++v6 >= 5 )
            return 1;
        }
        while ( (((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 114] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 113]) != dword_20000054 )
        {
          if ( timer - timer >= 0x32 )
            goto LABEL_26;
        }
      }
    }
  }
  return 1;
}
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// 1FFFF884: using guessed type int dword_1FFFF884;
// 2000002C: using guessed type int usedModelPtr;
// 20000054: using guessed type int dword_20000054;
// 2000013C: using guessed type char byte_2000013C;
// 2000013E: using guessed type char sendingPacket;
// 2000013F: using guessed type char byte_2000013F;
// 20000140: using guessed type int dword_20000140;
// 200002AD: using guessed type char currentModel;

//----- (00007A38) --------------------------------------------------------
int sub_7A38()
{
  int result; // r0@1

  result = 0x40037100;
  if ( v4003710C << 31 )
  {
    v4003710C |= (unsigned int)byte_1;
    result = main(0x40037100, v4003710C, (const char **)byte_1);
  }
  return result;
}

//----- (00007A78) --------------------------------------------------------
__int16 *tpmMethod()
{
  __int16 *result; // r0@1

  v4004803C |= 0x4000000u;                      // System Clock Gating Control Register 6 (SIM_SCGC6)
  v40049004 = 768;                              // Pin Control Register n (PORTA_PCR1)
  v40049008 = 768;                              // Pin Control Register n (PORTA_PCR2)
                                                //  DMA request on either edge. 
                                                // 
  v4003A000 = 9;                                // Status and Control (TPM2_SC) 
                                                // Divide by 2
                                                // TPM counter increments on every TPM counter clock 
  v4003A00C &= 0xFFFFFFC3;                      // Channel (n) Status and Control (TPM2_C0SC)
  v4003A00C |= 0x14u;
  v4003A00C |= 0x40u;
  v4003A010 = 4000;                             // Channel (n) Value (TPM2_C0V)
  v4003A014 &= 0xFFFFFFC3;                      // Channel (n) Status and Control (TPM2_C1SC)
  v4003A014 |= 0xCu;
  v4003A014 |= 0x40u;
  v4003A018 = 0;
  v4003A004 = 0;
  v4003A008 = 0xFFFF;
  vE000E410 = (vE000E410 & 0xFFFFFF) - 0x40000000;
  vE000E100 |= 0x80000u;
  result = &word_2000012C;
  word_2000012C = 0;
  return result;
}
// 2000012C: using guessed type __int16 word_2000012C;

//----- (00007B14) --------------------------------------------------------
signed int sub_7B14()
{
  return showSingleValuePage("Pitch curve", usedModelPtr + 31, (int)&unk_D198);
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00007B34) --------------------------------------------------------
void startupWarning()
{
  unsigned int v0; // r6@10
  int varAt1FFFF89C; // r4@10

  adcMethod2(1);
  while ( !byte_1FFFF896 || sub_232C() )
    sendPacketWithTimer();
  if ( (unsigned int)(getInputStates() << 12) >> 28 || !(getInputStates() & 0x100000) )
    goto LABEL_10;
  if ( stickModeSW == 1 || stickModeSW == 3 )
  {
    if ( (unsigned int)ch3_ADC_VAL >= 500 )
      goto LABEL_10;
  }
  else if ( ch3_ADC_VAL <= (unsigned int)&byte_DA0[12] )
  {
LABEL_10:
    callSetupDMAandSend();
    displayTextAt2("!! Warning !!", 64, 0, 0);
    displayTextAt2("Place all", 64, 16, 0);
    displayTextAt2("switches in", 64, 24, 0);
    displayTextAt2("their up", 64, 32, 0);
    displayTextAt2("position and", 64, 40, 0);
    displayTextAt2("lower the", 64, 48, 0);
    displayTextAt2("throttle", 64, 56, 0);
    LCD_updateCALL();
    beep(523, 100);
    beep(370, 250);
    v0 = timer;
    varAt1FFFF89C = getInputStates();
    while ( 1 )
    {
      if ( !(varAt1FFFF89C & 0xB0000) && !(~varAt1FFFF89C & 0x100000) )
      {
        if ( stickModeSW == 1 || stickModeSW == 3 )
        {
          if ( (unsigned int)ch3_ADC_VAL < 0x1F4 )
            return;
        }
        else if ( ch3_ADC_VAL > (unsigned int)&byte_DA0[12] )
        {
          return;
        }
      }
      if ( !sub_232C() )
        adcMethod2(1);
      if ( timer - v0 >= 1000 )
      {
        beep(523, 100);
        beep(370, 250);
        v0 = timer;
      }
      varAt1FFFF89C = getInputStates();
      sendPacketWithTimer();
    }
  }
}
// 1FFFF896: using guessed type char byte_1FFFF896;
// 200002AA: using guessed type char stickModeSW;
// 20000F08: using guessed type int ch3_ADC_VAL;

//----- (00007CAC) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int sub_7CAC()
{
  unsigned int v0; // r5@1
  int v1; // r2@2
  int v2; // r0@2
  int result; // r0@9
  _BYTE v4; // cf@13
  unsigned int v5; // r0@20
  char v6; // [sp+0h] [bp-48h]@2
  __int16 v7; // [sp+1h] [bp-47h]@2
  __int16 v8; // [sp+3h] [bp-45h]@2
  __int16 v9; // [sp+5h] [bp-43h]@2
  _BYTE text; // [sp+20h] [bp-28h]@2

  v0 = 0;
  dword_20000044 = 0;
  dword_20000048 = 0;
  dword_2000004C = 0;
  sendingPacket = 1;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("RF frequency");
        displayTextAt("Frequency", 8, 8, 0);
        sprintf((int)&text, "%u.%u", 0);
        displayTextAt2(&text, 64, 16, 0);
        displayTextAt("Mode", 8, 28, 0);
        displayTextAt2(off_200000F4[dword_20000048], 64, 36, 0);
        displayTextAt("Ant", 8, 48, 0);
        displayTextAt2(*(_BYTE **)&aA[4 * dword_2000004C], 64, 56, 0);
        displayGFX((int)&arrow_gfx, 0, 20 * v0 + 8);
        LCD_updateCALL();
        setupDMA(&v6, 0x1Du, 0xFFu);
        v6 = 0x54;
        v7 = 0;
        v8 = dword_20000048;
        v9 = dword_2000004C;
        sendPacketToRadio(&v6, (char *)((unsigned int)dword_2000004C >> 8), v1);
        v2 = getKeyCode();
        if ( v2 == 10 )
        {
          if ( v0 < 2 )
            ++v0;
          else
            v0 = 0;
          v4 = (unsigned int)sub_9BC0() >= 2;
          goto LABEL_14;
        }
        if ( v2 != 8 && v2 != 24 )
          break;
        if ( v0 )
        {
          if ( v0 == 1 )
          {
            if ( dword_20000048 )
            {
              --dword_20000048;
              if ( (unsigned int)sub_9BC0() >= 2 )
              {
LABEL_30:
                beep(784, 15);
                beep(0, 15);
              }
            }
          }
          else if ( v0 == 2 )
          {
            dword_2000004C ^= 1u;
            v5 = sub_9BC0();
            v4 = v5 >= 2;
            if ( v5 >= 2 )
              goto LABEL_30;
LABEL_14:
            if ( v4 )
              goto LABEL_30;
          }
        }
      }
      if ( v2 != 9 && v2 != 23 )
        break;
      if ( v0 )
      {
        if ( v0 == 1 )
        {
          if ( (unsigned int)dword_20000048 < 2 )
          {
            ++dword_20000048;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_30;
          }
        }
        else if ( v0 == 2 )
        {
          dword_2000004C ^= 1u;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_30;
        }
      }
      else
      {
        dword_20000044 = 1;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_30;
      }
    }
  }
  while ( v2 != 25 && v2 != 11 );
  result = 0;
  sendingPacket = 0;
  return result;
}
// 7CB4: write access to const memory at 20000044 has been detected
// 7E36: write access to const memory at 20000044 has been detected
// 7DDE: write access to const memory at 20000044 has been detected
// 7CAC: too many cbuild loops
// 20000044: using guessed type int dword_20000044;
// 20000048: using guessed type int dword_20000048;
// 2000004C: using guessed type int dword_2000004C;
// 2000013E: using guessed type char sendingPacket;

//----- (00007E9C) --------------------------------------------------------
char *sub_7E9C()
{
  char *result; // r0@1

  result = &byte_2000016C;
  if ( (byte_20000171 == 5 || byte_20000171 == 6 || byte_20000171 == 7) && byte_20000178 != 3 )
  {
    byte_2000017A = 1;
    if ( byte_20000172 == 6 )
      byte_20000171 = 2;
  }
  return result;
}
// 4: using guessed type int Reset;
// C: using guessed type int HardFault;
// 2000016C: using guessed type char byte_2000016C;
// 20000171: using guessed type char byte_20000171;
// 20000172: using guessed type char byte_20000172;
// 20000178: using guessed type char byte_20000178;
// 2000017A: using guessed type char byte_2000017A;

//----- (00007EC8) --------------------------------------------------------
char *callSendPacket()
{
  return sendPAcket();
}

//----- (00007ED0) --------------------------------------------------------
signed int sendSettingsPacket()
{
  char *modelSettings; // r5@5
  unsigned int v2; // r5@7
  void *v3; // r0@9
  char *v4; // r0@10
  _WORD *v5; // r1@12
  unsigned int v6; // r0@15
  char v7; // r1@17
  unsigned int v8; // r5@19
  char *i; // r0@21
  _WORD *v10; // r1@23

  if ( resend1FFFFCF5 )
  {
    memcpy((_BYTE *)dword_1FFFFCD8, (int)&dword_1FFFFCF4[1], 0x1Du);
    resend1FFFFCF5 = 0;
  }
  else
  {
    if ( sendingPacket )
      return 0;
    modelSettings = &rxsettings[146 * (unsigned __int8)currentModel];
    if ( dword_20000140 || !modelSettings[106] )// modelSettings[106] - > AFHDS2 enabled
    {
      if ( byte_2000013F )
      {
        setupDMA(dword_1FFFFCD8, 29u, 0xFFu);
        dword_1FFFFCD8[0] = 0xFDAAu;            // settings packet id 0xAA
        LOBYTE(dword_1FFFFCD8[1]) = -1;
        HIBYTE(dword_1FFFFCD8[1]) = modelSettings[113];
        LOBYTE(dword_1FFFFCDC) = modelSettings[114];
        v6 = (unsigned __int8)modelSettings[107];
        *(_WORD *)((char *)&dword_1FFFFCDC + 1) = v6 & 1;
        BYTE1(dword_1FFFFCE4) = -34 - (v6 >> 1);
        dword_20000140 = 0;
        byte_2000013F = 0;
LABEL_27:
        dword_20000140 = 1000;
        return 1;
      }
      if ( modelSettings[106] )                 // AFHDS2 enabled
        v7 = 0x58;                              // sticks_packet
      else
        v7 = 0x57;
      LOBYTE(dword_1FFFFCD8[0]) = v7;
      v8 = 0;
LABEL_21:
      for ( i = (char *)&unk_5DC + div__0(600 * dword_1FFFFDE0[v8], 12000); ; i = (char *)&unk_5DC )
      {
        v10 = &dword_1FFFFCD8[v8];
        *((_BYTE *)v10 + 1) = (_BYTE)i;
        ++v8;
        *((_BYTE *)v10 + 2) = BYTE1(i);
        if ( v8 >= 0xE )
          break;
        if ( v8 < 0xA )
          goto LABEL_21;
      }
    }
    else
    {
      LOBYTE(dword_1FFFFCD8[0]) = 0x56;         // fail safe packet
      v2 = 0;
LABEL_9:
      v3 = (void *)((signed __int16)((unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 116] + 2 * v2) << 8) | (unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 115] + 2 * v2));
      if ( v3 != &loc_7FFE )
      {
        v4 = (char *)&unk_5DC
           + div__0(
               600
             * ((signed __int16)((unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 116] + 2 * v2) << 8) | (unsigned __int8)*(&rxsettings[146 * (unsigned __int8)currentModel + 115] + 2 * v2)),
               12000);
        goto LABEL_12;
      }
      while ( 1 )
      {
        LOWORD(v4) = 0xFFFFu;
LABEL_12:
        v5 = &dword_1FFFFCD8[v2];
        *((_BYTE *)v5 + 1) = (_BYTE)v4;
        ++v2;
        *((_BYTE *)v5 + 2) = BYTE1(v4);
        if ( v2 >= 0xE )
          break;
        if ( v2 < 6 )
          goto LABEL_9;
      }
    }
  }
  if ( !dword_20000140 )
    goto LABEL_27;
  --dword_20000140;
  return 1;
}
/* Orphan comments:
servo frequency High byte
//servo freq Low byte
PPM
Always 0. To enable SBUS 1FFFFFCE5 = 0xDD IBUS is problably 0xDE
*/
// 8: using guessed type int NMI;
// 1FFFFCDC: using guessed type int dword_1FFFFCDC;
// 1FFFFCE4: using guessed type int dword_1FFFFCE4;
// 2000013D: using guessed type char resend1FFFFCF5;
// 2000013E: using guessed type char sendingPacket;
// 2000013F: using guessed type char byte_2000013F;
// 20000140: using guessed type int dword_20000140;
// 200002AD: using guessed type char currentModel;

//----- (00008028) --------------------------------------------------------
signed int sub_8028()
{
  signed int result; // r0@1

  result = 1073971200;
  v40038000 &= 0xFFFFFFE7;
  return result;
}

//----- (00008038) --------------------------------------------------------
signed int sub_8038()
{
  signed int result; // r0@1

  result = 1073971200;
  v40038000 = (v40038000 & 0xFFFFFFE7) + 8;
  return result;
}

//----- (0000804C) --------------------------------------------------------
char *configurePINandTimers()
{
  char *result; // r0@1

  v4004B01C = 256;                              // Pin Control Register n (PORTC_PCR7)
  v4004B00C = 256;                              // Pin Control Register n (PORTC_PCR3)
  v4004D004 = 256;                              // Pin Control Register n (PORTE_PCR1)
  v4004D000 = 256;                              // Pin Control Register n (PORTE_PCR0)
  v400FF094 |= 0x88u;                           // Port Data Direction Register (GPIOC_PDDR)
  v400FF114 = 16 * (v400FF114 >> 4) + 3;        // Port Data Direction Register (GPIOE_PDDR)
  v4004C00C = 655616;                           // Pin Control Register n (PORTD_PCR3)
  vE000E41C = vE000E41C & 0xFFFFFF | 0x40000000;
  vE000E100 |= 0x80000000;
  v4004803C |= 0x1000000u;                      // System Clock Gating Control Register 6 (SIM_SCGC6)
  v40038000 = 3;                                // Status and Control (TPM0_SC)
  v40038008 = 0xFFFF;                           // Modulo (TPM0_MOD)
  v4003800C = 84;                               //  Channel (n) Status and Control (TPM0_C0SC
  vE000E410 &= 0xFFFF00FF;
  vE000E100 |= 0x20000u;
  sub_8AD4(0xE000E100, vE000E100, 0x20000, 65280);
  result = &byte_2000013C;
  byte_2000013C = 1;
  return result;
}
// 2000013C: using guessed type char byte_2000013C;

//----- (00008104) --------------------------------------------------------
unsigned int __fastcall callRxpacketHandle(_BYTE *a1)
{
  return rxpacketHandle(a1);
}

//----- (0000810C) --------------------------------------------------------
int sub_810C()
{
  int result; // r0@1

  result = 0;
  v40038004 = 0;
  return result;
}

//----- (00008118) --------------------------------------------------------
signed int __fastcall addPacketToResend1FFFFCF5When2000013C(signed int result)
{
  char v1; // [sp+0h] [bp-30h]@2
  _BYTE v2[3]; // [sp+1h] [bp-2Fh]@2

  if ( byte_2000013C )
  {
    v1 = result;
    setupDMA((_WORD *)v2, 0x1Cu, 0xFFu);
    while ( resend1FFFFCF5 )
      sendPacketWithTimer();
    memcpy(&dword_1FFFFCF4[1], (int)&v1, 0x1Du);
    result = 1;
    resend1FFFFCF5 = 1;
  }
  return result;
}
// 2000013C: using guessed type char byte_2000013C;
// 2000013D: using guessed type char resend1FFFFCF5;

//----- (00008160) --------------------------------------------------------
char *__fastcall sendPacketToRadio(_BYTE *targetAddress, char *a2, int a3)
{
  _BYTE *targetAddress_1; // r5@1
  char *result; // r0@1
  signed int paketType; // r0@9
  char *secondByteAddress; // r4@9
  unsigned int typeBelow0x55; // r0@13
  int v8; // r0@51
  unsigned int v9; // r1@42
  unsigned __int8 v10; // cf@59
  char v11; // r1@59
  int v12; // r6@64
  signed int v13; // r4@64
  signed int v14; // r12@64
  unsigned int v15; // r2@64
  _WORD *v16; // r3@65
  signed int v17; // r1@65
  signed int v18; // r5@65
  int v19; // r7@66
  int v20; // r0@66
  int v21; // r0@73
  char v22; // r0@75
  unsigned __int8 v23; // [sp+0h] [bp-38h]@42
  char v24; // [sp+1h] [bp-37h]@42
  char v25; // [sp+2h] [bp-36h]@42
  char v26; // [sp+3h] [bp-35h]@42
  char v27; // [sp+4h] [bp-34h]@42
  __int16 v28; // [sp+5h] [bp-33h]@42
  char v29; // [sp+7h] [bp-31h]@42
  char v30; // [sp+8h] [bp-30h]@42
  _BYTE v31[3]; // [sp+9h] [bp-2Fh]@42
  unsigned int v32; // [sp+20h] [bp-18h]@38

  targetAddress_1 = targetAddress;
  result = (char *)*targetAddress;
  if ( !result )
    return result;
  if ( (unsigned int)(result - 'À') >= 16 )
  {
    if ( byte_20000178 == 3 )
    {
      if ( byte_20000172 != 6 )
      {
LABEL_8:
        byte_20000178 = 0;
        goto LABEL_9;
      }
    }
    else if ( byte_20000172 != 6 )
    {
      goto LABEL_9;
    }
    byte_20000173 = 7;
    sub_8028();
    dword_20000184 = 1;
    byte_20000171 = 5;
    sub_810C();
    sub_8540(1);
    sub_8038();
    goto LABEL_8;
  }
LABEL_9:
  paketType = *targetAddress_1;
  secondByteAddress = targetAddress_1 + 1;
  if ( paketType == 0x9A )
  {
    v23 = 0xA5u;
    v9 = (unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24);
    v24 = TX_ID;
    v25 = BYTE1(v9);
    v26 = v9 >> 16;
    v27 = BYTE3(v9);
    v28 = dword_2000018C;
    v29 = (unsigned int)dword_2000018C >> 16;
    v30 = BYTE3(dword_2000018C);
    setupDMA((_WORD *)v31, 20u, 0xFFu);
    return (char *)callRxpacketHandle(&v23);
  }
  if ( paketType <= 0x9A )
  {
    if ( paketType != 0x55 )
    {
      if ( paketType <= 0x55 )
      {
        typeBelow0x55 = paketType - 0x50;
        if ( typeBelow0x55 < 5 )
        {
          switch ( typeBelow0x55 )
          {
            case 3u:
              goto LABEL_58;
            case 4u:
              dword_200001A0 = (targetAddress_1[2] << 8) | targetAddress_1[1];
              v21 = (targetAddress_1[4] << 8) | targetAddress_1[3];
              if ( v21 )
              {
                if ( v21 == 1 )
                {
                  v22 = 4;
                }
                else
                {
                  byte_20000176 = 10;
                  v22 = 5;
                }
                byte_20000173 = v22;
              }
              else
              {
                byte_20000173 = 3;
              }
              byte_2000017C = ((targetAddress_1[6] << 8) | targetAddress_1[5]) != 0;
              sub_8028();
              dword_20000184 = 1;
              byte_20000171 = 5;
              sub_810C();
              sub_8540(1);
              result = (char *)sub_8038();
              break;
            case 2u:
              if ( (targetAddress_1[2] << 8) | (unsigned __int8)*secondByteAddress )
                dword_20000194 = 0;
              else
                dword_20000194 = dword_20000190;
              result = byte_1;
              byte_20000174 = 1;
              break;
            case 1u:
              targetAddress_1[2];
              v10 = __CFSHL__(targetAddress_1[4], 8);
              v11 = targetAddress_1[3];
              byte_20000180 = *secondByteAddress;
              byte_20000181 = v11;
              result = (char *)spiSend(&byte_20000180, 2u);
              break;
            case 0u:
              v12 = (signed __int16)(targetAddress_1[2] << 8) | targetAddress_1[1];
              v32 = 2;
              v13 = 0x1000000;
              v14 = 7;
              v15 = 0;
              do
              {
                v16 = (_WORD *)(16 * v15 + 60670);
                v17 = 0;
                v18 = 8;
                do
                {
                  v19 = *v16;
                  ++v16;
                  v20 = v19 + 169 - v12;
                  if ( v20 < 0 )
                    v20 = -v20;
                  if ( v20 < v13 )
                  {
                    v14 = v17;
                    v13 = v20;
                    v32 = v15;
                  }
                  ++v17;
                  --v18;
                }
                while ( v18 );
                ++v15;
              }
              while ( v15 < 4 );
              result = &byte_2000016C;
              dword_20000190 = 8 * v32 | v14;
              dword_20000194 = 8 * v32 | v14;
              byte_20000174 = 1;
              break;
          }
          return result;
        }
LABEL_58:
        memcpy(&byte_1FFFFD9C, (int)targetAddress_1, 29u);
        result = byte_1;
        byte_2000016F = 1;
        return result;
      }
      if ( paketType == 0x56 )
        goto LABEL_58;
      if ( paketType != 0x57 && paketType != 0x58 )
      {
        if ( paketType == 0x99 )
        {
          sub_8028();
          dword_20000184 = 1;
          byte_20000171 = 0;
          sub_810C();
          sub_8540(1);
          return (char *)sub_8038();
        }
        goto LABEL_58;
      }
    }
    if ( paketType == 0x57 )
    {
      byte_20000173 = 0;
      *targetAddress_1 = 0x55;
    }
    else if ( paketType == 0x55 )
    {
      byte_20000173 = 1;
    }
    else
    {
      byte_20000173 = 2;
    }
    if ( (unsigned int)dword_2000019C > 0x11 )
    {
      v8 = (targetAddress_1[28] << 8) | targetAddress_1[27] | 0x8000;
      targetAddress_1[27] = targetAddress_1[27];
      targetAddress_1[28] = BYTE1(v8);
    }
    if ( !byte_20000171 || byte_20000172 == 3 )
    {
      sub_8028();
      dword_20000184 = 1;
      byte_20000171 = 5;
      sub_810C();
      sub_8540(1);
      sub_8038();
    }
    goto LABEL_58;
  }
  if ( paketType == 0xC0 )
    goto LABEL_58;
  if ( paketType > 0xC0 )
  {
    if ( paketType == 0xC1 )
    {
      if ( !byte_20000171 || byte_20000172 == 3 )
      {
        v32 = 5;
        sub_8028();
        dword_20000184 = 1;
        byte_20000171 = 5;
        sub_810C();
        sub_8540(1);
        sub_8038();
      }
      if ( targetAddress_1[1] | (targetAddress_1[2] << 8) | (targetAddress_1[3] << 16) | (targetAddress_1[4] << 24) )
      {
        byte_20000178 = 0;
        byte_20000173 = 6;
        sub_8028();
        dword_20000184 = 1;
        byte_20000171 = 5;
        sub_810C();
        sub_8540(1);
        sub_8038();
      }
      else
      {
        byte_20000178 = 3;
      }
    }
    else if ( paketType == 0xC2 || paketType == 0xC3 || paketType == 0xC4 )
    {
      sub_8028();
      dword_20000184 = 1;
      byte_20000171 = 5;
      sub_810C();
      sub_8540(1);
      sub_8038();
    }
    goto LABEL_58;
  }
  if ( paketType == 0x9B )
  {
    result = (char *)(targetAddress_1[1] | (targetAddress_1[2] << 8) | (targetAddress_1[3] << 16) | (targetAddress_1[4] << 24));
    dword_2000018C = targetAddress_1[1] | (targetAddress_1[2] << 8) | (targetAddress_1[3] << 16) | (targetAddress_1[4] << 24);
    return result;
  }
  if ( paketType != 0xA5 )
  {
    if ( paketType == 0xA6 )
    {
      result = &byte_2000016C;
      byte_20000178 = 0;
      return result;
    }
    goto LABEL_58;
  }
  result = (char *)((unsigned __int8)byte_20000178 | (unsigned __int8)byte_2000016C);
  if ( !result )
  {
    byte_20000178 = 1;
    byte_20000179 = 0;
    byte_2000016C = 50;
    if ( !byte_20000171 || (result = (char *)(unsigned __int8)byte_20000172, byte_20000172 == 3) )
    {
      sub_8028();
      dword_20000184 = 1;
      byte_20000171 = 5;
      sub_810C();
      sub_8540(1);
      result = (char *)sub_8038();
    }
  }
  return result;
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// C: using guessed type int HardFault;
// 1400: using guessed type int TX_ID;
// 1FFFFD9C: using guessed type char byte_1FFFFD9C;
// 2000016C: using guessed type char byte_2000016C;
// 2000016F: using guessed type char byte_2000016F;
// 20000171: using guessed type char byte_20000171;
// 20000172: using guessed type char byte_20000172;
// 20000173: using guessed type char byte_20000173;
// 20000174: using guessed type char byte_20000174;
// 20000176: using guessed type char byte_20000176;
// 20000178: using guessed type char byte_20000178;
// 20000179: using guessed type char byte_20000179;
// 2000017C: using guessed type char byte_2000017C;
// 20000180: using guessed type char byte_20000180;
// 20000181: using guessed type char byte_20000181;
// 20000184: using guessed type int dword_20000184;
// 2000018C: using guessed type int dword_2000018C;
// 20000190: using guessed type int dword_20000190;
// 20000194: using guessed type int dword_20000194;
// 2000019C: using guessed type int dword_2000019C;
// 200001A0: using guessed type int dword_200001A0;

//----- (00008508) --------------------------------------------------------
int __fastcall setC7_unsetC4(int result)
{
  if ( result )
  {
    v400FF088 = 128;                            // Port Clear Output Register (GPIOC_PCOR)
    v400FF084 = 8;                              // Port Set Output Register (GPIOC_PSOR
  }
  else
  {
    v400FF088 = 8;                              // Port Clear Output Register (GPIOC_PCOR)
    v400FF084 = 128;                            // Port Set Output Register (GPIOC_PSOR
  }
  return result;
}

//----- (00008524) --------------------------------------------------------
int __fastcall setPortE1_unsetE0(int result)
{
  if ( result )
  {
    v400FF108 = 1;
    v400FF104 = 2;
  }
  else
  {
    v400FF108 = 2;
    v400FF104 = 1;
  }
  return result;
}

//----- (00008540) --------------------------------------------------------
int __fastcall sub_8540(int result)
{
  v40038010 = result;
  return result;
}

//----- (0000854C) --------------------------------------------------------
char *trySendSettingsPacket()
{
  char *result; // r0@3
  char *v1; // r1@3
  int v2; // r2@3

  sensorsFunction4();
  if ( !sub_232C() )
    adcMethod2(1);
  createRadioPacket();
  result = (char *)sendSettingsPacket();
  if ( result )
    result = sendPacketToRadio((_BYTE *)dword_1FFFFCD8, v1, v2);
  return result;
}

//----- (00008578) --------------------------------------------------------
char *sendPAcket()
{
  char *result; // r0@1
  int *v1; // r0@10
  unsigned int v2; // r0@23
  unsigned int v3; // r0@36
  signed __int64 v4; // r0@38
  int v5; // r7@48
  int v6; // r4@49
  char *v7; // r1@51
  char *v8; // r1@53
  unsigned int v9; // r1@71
  unsigned int v10; // r1@76
  unsigned int v11; // r0@82
  unsigned int v12; // r2@84
  int v13; // r1@84
  __int16 *v14; // r0@84
  unsigned int v15; // r3@88
  unsigned int v16; // r7@95
  unsigned int v17; // [sp+0h] [bp-80h]@7
  unsigned int v18; // [sp+4h] [bp-7Ch]@15
  int v19; // [sp+8h] [bp-78h]@17
  unsigned __int8 v20; // [sp+13h] [bp-6Dh]@71
  unsigned __int8 v21; // [sp+14h] [bp-6Ch]@71
  int v22; // [sp+20h] [bp-60h]@55
  unsigned __int8 v23; // [sp+28h] [bp-58h]@23
  _BYTE v24[3]; // [sp+29h] [bp-57h]@8
  char v25; // [sp+2Ch] [bp-54h]@23
  __int16 v26; // [sp+2Dh] [bp-53h]@23
  char v27; // [sp+2Fh] [bp-51h]@23
  char v28; // [sp+30h] [bp-50h]@23
  char v29; // [sp+48h] [bp-38h]@28
  _BYTE v30[3]; // [sp+49h] [bp-37h]@28

  result = &byte_2000016C;
  if ( !byte_2000016D || byte_2000016E )
    return result;
  byte_2000016E = 1;
  if ( byte_20000171 == 2 )
  {
    if ( !byte_2000017A )
      goto LABEL_93;
    byte_2000017A = 0;
    sendOverSPI_useDMA(64, &v17, 1u);
    if ( !(v17 & 0x20) )
    {
      dword_2000019C = 0;
      byte_2000017D = -16;
      spiSend(&byte_2000017D, 1u);
      sendOverSPI_useDMA(69, &v17, 0x25u);
      setupDMA((_WORD *)v24, 28u, 0xFFu);
      if ( (unsigned int)(unsigned __int8)v17 - 187 < 0xB )
      {
        switch ( (unsigned __int8)v17 )
        {
          case 0xC2u:
          case 0xC3u:
          case 0xC4u:
          case 0xC5u:
            v1 = (int *)&v17;
            goto LABEL_26;
          case 0xBBu:
            if ( byte_20000172 != 1 )
              goto LABEL_41;
            if ( byte_20000178 == 1 )
            {
              if ( (((unsigned __int8)v18 << 24) | (v17 >> 8)) == ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24))
                && ((BYTE2(v18) << 8) | BYTE1(v18)) == 9 )
              {
                dword_2000018C = BYTE3(v18) | (v19 << 8);
                byte_20000178 = 2;
              }
              goto LABEL_93;
            }
            if ( byte_20000178 != 2
              || (((unsigned __int8)v19 << 24) | (v18 >> 8)) != dword_2000018C
              || ((BYTE2(v19) << 8) | BYTE1(v19)) != 254 )
            {
              goto LABEL_93;
            }
            byte_20000178 = 0;
            v23 = 0xA5u;
            v2 = (unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24);
            v24[0] = TX_ID;
            v24[1] = BYTE1(v2);
            v24[2] = v2 >> 16;
            v25 = BYTE3(v2);
            v26 = dword_2000018C;
            v27 = (unsigned int)dword_2000018C >> 16;
            v28 = BYTE3(dword_2000018C);
            v1 = (int *)&v23;
LABEL_26:
            callRxpacketHandle(v1);
            goto LABEL_41;
          case 0xBCu:
            if ( byte_20000172 != 2 )
              goto LABEL_41;
            v29 = v17;
            memcpy(v30, (int)&v19 + 1, 0x1Cu);
            if ( byte_20000178 == 1 )
            {
              if ( (((unsigned __int8)v18 << 24) | (v17 >> 8)) == ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24))
                && (((unsigned __int8)v30[1] << 8) | (unsigned __int8)v30[0]) == 1 )
              {
                dword_2000018C = ((unsigned __int8)v19 << 24) | (v18 >> 8);
                byte_20000178 = 2;
              }
            }
            else if ( byte_20000178 == 2
                   && (((unsigned __int8)v19 << 24) | (v18 >> 8)) == dword_2000018C
                   && (((unsigned __int8)v30[1] << 8) | (unsigned __int8)v30[0]) == 2 )
            {
              byte_20000178 = 0;
              v23 = 0xA5u;
              v3 = (unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24);
              v24[0] = TX_ID;
              v24[1] = BYTE1(v3);
              v24[2] = v3 >> 16;
              v25 = BYTE3(v3);
              v26 = dword_2000018C;
              v27 = (unsigned int)dword_2000018C >> 16;
              v28 = BYTE3(dword_2000018C);
              callRxpacketHandle(&v23);
              goto LABEL_41;
            }
            break;
          case 0xBDu:
          case 0xBEu:
          case 0xBFu:
          case 0xC0u:
          case 0xC1u:
            goto LABEL_38;
        }
        goto LABEL_93;
      }
LABEL_38:
      HIDWORD(v4) = (unsigned __int8)v18;
      LODWORD(v4) = v17;
      if ( byte_20000172 == 2 )
      {
        if ( (unsigned int)(v4 >> 8) != ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24))
          || (((unsigned __int8)v19 << 24) | (v18 >> 8)) != dword_2000018C )
        {
          goto LABEL_93;
        }
        v23 = v17;
        memcpy(v24, (int)&v19 + 1, 28u);
        callRxpacketHandle(&v23);
      }
      else if ( (unsigned int)(v4 >> 8) == ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24)) )
      {
        v23 = v17;
        memcpy(v24, (int)&v18 + 1, 28u);
        callRxpacketHandle(&v23);
      }
    }
LABEL_41:
    if ( byte_20000172 == 6 )
    {
      sub_8028();
      dword_20000184 = 1;
      byte_20000171 = 3;
      sub_810C();
      sub_8540(1);
      sub_8038();
    }
    goto LABEL_93;
  }
  if ( byte_20000171 == 6 && byte_20000177 )
  {
    v5 = (unsigned __int8)byte_20000173;
    if ( byte_20000173 == 6 )
    {
      memcpy(&byte_1FFFFDBA, (int)&byte_1FFFFD9C, 29u);
LABEL_92:
      byte_20000177 = 0;
      goto LABEL_93;
    }
    v6 = (unsigned __int8)byte_20000178;
    if ( byte_20000178 != 1 && byte_20000178 != 2 )
    {
      v7 = &byte_1FFFFD9C;
LABEL_80:
      if ( !byte_2000016F )
      {
LABEL_86:
        if ( !v6 && byte_2000016C )
          --byte_2000016C;
        goto LABEL_92;
      }
LABEL_81:
      byte_1FFFFDBA = *v7;
      if ( v5 )
      {
        v11 = (unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24);
        byte_1FFFFDBB = TX_ID;
        byte_1FFFFDBC = BYTE1(v11);
        byte_1FFFFDBD = v11 >> 16;
        byte_1FFFFDBE = BYTE3(v11);
        if ( v6 == 1 )
        {
          word_1FFFFDBF = -1;
          byte_1FFFFDC1 = -1;
          byte_1FFFFDC2 = -1;
        }
        else
        {
          word_1FFFFDBF = dword_2000018C;
          byte_1FFFFDC1 = (unsigned int)dword_2000018C >> 16;
          byte_1FFFFDC2 = BYTE3(dword_2000018C);
        }
        v12 = 28;
        v13 = (int)(v7 + 1);
        v14 = &word_1FFFFDC3;
      }
      else
      {
        v15 = (unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24);
        byte_1FFFFDBB = TX_ID;
        byte_1FFFFDBC = BYTE1(v15);
        byte_1FFFFDBD = v15 >> 16;
        byte_1FFFFDBE = BYTE3(v15);
        v12 = 16;
        v13 = (int)(v7 + 1);
        v14 = &word_1FFFFDBF;
      }
      memcpy(v14, v13, v12);
      byte_2000016F = 0;
      goto LABEL_86;
    }
    setupDMA(&v17, 29u, 0xFFu);
    v8 = &byte_2000016C;
    if ( !v5 )
    {
      LOBYTE(v17) = 0xAAu;
LABEL_78:
      *v8 = 50;
      v7 = (char *)&v17;
      if ( v6 == 1 || v6 == 2 )
        goto LABEL_81;
      goto LABEL_80;
    }
    if ( v5 == 1 )
    {
      LOBYTE(v17) = 0xBBu;
      if ( v6 == 1 )
      {
        *(_WORD *)((char *)&v17 + 1) = 1;
      }
      else if ( v6 == 2 )
      {
        *(_WORD *)((char *)&v17 + 1) = 0;
      }
      memcpy((_BYTE *)&v17 + 3, (int)RANDOM_BYTES, 0x10u);
      goto LABEL_77;
    }
    v22 = word_2000017E & 0x7FFF;
    if ( v6 != 1 )
    {
      if ( v6 == 2 )
      {
        LOWORD(v17) = 700;
        BYTE2(v17) = 0;
        v10 = (((v21 << 8) | (unsigned int)v20) >> 15 << 15) | v22;
        v20 = v22;
        v21 = BYTE1(v10) | 0x80;
      }
LABEL_77:
      v8 = &byte_2000016C;
      goto LABEL_78;
    }
    if ( !byte_20000179 )
    {
      if ( dword_20000198 == 16 )
      {
        LOWORD(v17) = 0x1BB;
        BYTE2(v17) = 0;
        memcpy((_BYTE *)&v17 + 3, (int)RANDOM_BYTES, 0x10u);
        goto LABEL_72;
      }
      byte_20000179 = 1;
    }
    LOBYTE(v17) = 0xBCu;
    if ( byte_20000179 == 1 )
    {
      *(_WORD *)((char *)&v17 + 1) = 0;
      memcpy((_BYTE *)&v17 + 3, (int)RANDOM_BYTES, 0x10u);
    }
    else
    {
      *(_WORD *)((char *)&v17 + 1) = 1;
      memcpy((_BYTE *)&v17 + 3, (int)&RANDOM_BYTES[16], 0x10u);
    }
    v9 = (((v21 << 8) | (unsigned int)v20) >> 15 << 15) | v22;
    v20 = v22;
    v21 = BYTE1(v9) | 0x80;
LABEL_72:
    if ( (unsigned __int8)++byte_20000179 > 2u )
      byte_20000179 = 0;
    goto LABEL_77;
  }
LABEL_93:
  if ( byte_20000170 )
  {
    trySendSettingsPacket();
    byte_20000170 = 0;
    result = (char *)(getCurrentTicks() << 8);
    packetSendAt = (int)result;
  }
  else
  {
    v16 = packetSendAt - (getCurrentTicks() << 8);
    result = (char *)toSysTick(7000);
    if ( v16 >= (unsigned int)result )
    {
      packetSendAt -= toSysTick(7000);
      result = trySendSettingsPacket();
    }
  }
  byte_2000016E = 0;
  return result;
}
// 4: using guessed type int Reset;
// C: using guessed type int HardFault;
// 10: using guessed type int dword_10;
// 1400: using guessed type int TX_ID;
// 1FFFFD9C: using guessed type char byte_1FFFFD9C;
// 1FFFFDBA: using guessed type char byte_1FFFFDBA;
// 1FFFFDBB: using guessed type char byte_1FFFFDBB;
// 1FFFFDBC: using guessed type char byte_1FFFFDBC;
// 1FFFFDBD: using guessed type char byte_1FFFFDBD;
// 1FFFFDBE: using guessed type char byte_1FFFFDBE;
// 1FFFFDBF: using guessed type __int16 word_1FFFFDBF;
// 1FFFFDC1: using guessed type char byte_1FFFFDC1;
// 1FFFFDC2: using guessed type char byte_1FFFFDC2;
// 1FFFFDC3: using guessed type __int16 word_1FFFFDC3;
// 2000016C: using guessed type char byte_2000016C;
// 2000016D: using guessed type char byte_2000016D;
// 2000016E: using guessed type char byte_2000016E;
// 2000016F: using guessed type char byte_2000016F;
// 20000170: using guessed type char byte_20000170;
// 20000171: using guessed type char byte_20000171;
// 20000172: using guessed type char byte_20000172;
// 20000173: using guessed type char byte_20000173;
// 20000177: using guessed type char byte_20000177;
// 20000178: using guessed type char byte_20000178;
// 20000179: using guessed type char byte_20000179;
// 2000017A: using guessed type char byte_2000017A;
// 2000017D: using guessed type char byte_2000017D;
// 2000017E: using guessed type __int16 word_2000017E;
// 20000184: using guessed type int dword_20000184;
// 20000188: using guessed type int packetSendAt;
// 2000018C: using guessed type int dword_2000018C;
// 20000190: using guessed type int dword_20000190;
// 20000198: using guessed type int dword_20000198;
// 2000019C: using guessed type int dword_2000019C;

//----- (00008AD4) --------------------------------------------------------
int __fastcall sub_8AD4(int a1, int a2, int a3, int a4)
{
  int v4; // r0@4
  unsigned int v5; // r4@6
  char v6; // r6@14
  unsigned int v7; // r4@14
  char v8; // r5@16
  unsigned int v9; // r0@16
  unsigned __int8 v10; // r2@17
  unsigned __int8 v11; // r1@20
  signed int v12; // lr@28
  signed int v13; // r4@28
  signed int v14; // r12@28
  unsigned int v15; // r1@28
  _WORD *v16; // r3@29
  signed int v17; // r2@29
  signed int v18; // r5@29
  int v19; // r7@30
  int v20; // r0@30
  int result; // r0@36
  int v22; // [sp+0h] [bp-18h]@1

  v22 = a4;
  dword_2000018C = 0;
  byte_20000171 = 0;
  byte_20000178 = 0;
  byte_20000172 = 7;
  byte_20000173 = 2;
  dword_2000019C = 0;
  byte_20000177 = 0;
  byte_2000016E = 0;
  packetSendAt = getCurrentTicks() << 8;
  byte_20000170 = 0;
  if ( (HIBYTE(UNKNOWN_ID) << 8) | (unsigned __int8)UNKNOWN_ID
    && ((HIBYTE(UNKNOWN_ID) << 8) | (unsigned __int8)UNKNOWN_ID) != 0x7FFF
    && ((HIBYTE(UNKNOWN_ID) << 8) | (unsigned __int8)UNKNOWN_ID) != 0xFFFF )
  {
    v4 = (HIBYTE(UNKNOWN_ID) << 8) | (unsigned __int8)UNKNOWN_ID;
  }
  else
  {
    LOWORD(v4) = 1;
  }
  word_2000017E = v4;
  byte_1FFFFDB9 = 5;
  spiSend((_BYTE *)dword_EA48, 2u);
  spiSend((_BYTE *)dword_EA48 + 2, 5u);
  v5 = 0;
  do
    spiSend((_BYTE *)(2 * v5++ + 60033), 2u);
  while ( v5 < 0x2E );
  byte_2000017D = -96;
  spiSend(&byte_2000017D, 1u);
  byte_20000180 = 2;
  byte_20000181 = 1;
  spiSend(&byte_20000180, 2u);
  do
    sendOverSPI_useDMA(66, &v22, 1u);
  while ( v22 & 1 );
  timerSendPacket(10);
  sendOverSPI_useDMA(98, &v22, 1u);
  if ( v22 & 0x10 )
  {
    while ( 1 )
      ;
  }
  byte_20000180 = 36;
  byte_20000181 = 19;
  spiSend(&byte_20000180, 2u);
  byte_20000180 = 38;
  byte_20000181 = 59;
  spiSend(&byte_20000180, 2u);
  byte_20000180 = 15;
  byte_20000181 = 0;
  spiSend(&byte_20000180, 2u);
  byte_20000180 = 2;
  byte_20000181 = 2;
  spiSend(&byte_20000180, 2u);
  do
    sendOverSPI_useDMA(66, &v22, 1u);
  while ( v22 & 2 );
  sendOverSPI_useDMA(101, &v22, 1u);
  v6 = v22;
  byte_20000180 = 15;
  byte_20000181 = -96;
  v7 = v22 & 7;
  spiSend(&byte_20000180, 2u);
  byte_20000180 = 2;
  byte_20000181 = 2;
  spiSend(&byte_20000180, 2u);
  do
    sendOverSPI_useDMA(66, &v22, 1u);
  while ( v22 & 2 );
  sendOverSPI_useDMA(101, &v22, 1u);
  v8 = v22;
  v9 = v22 & 7;
  if ( v7 < 4 )
    v10 = 4 - v7;
  else
    v10 = v7 - 4;
  if ( v9 < 4 )
    v11 = 4 - v9;
  else
    v11 = v9 - 4;
  if ( v10 < (unsigned int)v11 )
  {
    byte_20000180 = 37;
    byte_20000181 = v9 | 8;
    spiSend(&byte_20000180, 2u);
  }
  else
  {
    byte_20000180 = 37;
    byte_20000181 = v7 | 8;
    spiSend(&byte_20000180, 2u);
  }
  if ( v6 & 8 && v8 & 8 )
  {
    while ( 1 )
      ;
  }
  v12 = 2;
  v13 = 0x1000000;
  v14 = 7;
  v15 = 0;
  do
  {
    v16 = (_WORD *)(16 * v15 + 60670);
    v17 = 0;
    v18 = 8;
    do
    {
      v19 = *v16;
      ++v16;
      v20 = v19 - 1;
      if ( v19 - 1 < 0 )
        v20 = -v20;
      if ( v20 < v13 )
      {
        v12 = v15;
        v14 = v17;
        v13 = v20;
      }
      ++v17;
      --v18;
    }
    while ( v18 );
    ++v15;
  }
  while ( v15 < 4 );
  dword_20000190 = 8 * v12 | v14;
  dword_20000194 = 8 * v12 | v14;
  byte_20000174 = 1;
  sub_8028();
  dword_20000184 = 1;
  byte_20000171 = 0;
  sub_810C();
  sub_8540(1);
  result = sub_8038();
  byte_2000016D = 1;
  return result;
}
// 4: using guessed type int Reset;
// 1424: using guessed type __int16 UNKNOWN_ID;
// EA48: using guessed type int dword_EA48[6];
// 1FFFFDB9: using guessed type char byte_1FFFFDB9;
// 2000016D: using guessed type char byte_2000016D;
// 2000016E: using guessed type char byte_2000016E;
// 20000170: using guessed type char byte_20000170;
// 20000171: using guessed type char byte_20000171;
// 20000172: using guessed type char byte_20000172;
// 20000173: using guessed type char byte_20000173;
// 20000174: using guessed type char byte_20000174;
// 20000177: using guessed type char byte_20000177;
// 20000178: using guessed type char byte_20000178;
// 2000017D: using guessed type char byte_2000017D;
// 2000017E: using guessed type __int16 word_2000017E;
// 20000180: using guessed type char byte_20000180;
// 20000181: using guessed type char byte_20000181;
// 20000184: using guessed type int dword_20000184;
// 20000188: using guessed type int packetSendAt;
// 2000018C: using guessed type int dword_2000018C;
// 20000190: using guessed type int dword_20000190;
// 20000194: using guessed type int dword_20000194;
// 2000019C: using guessed type int dword_2000019C;

//----- (00008D54) --------------------------------------------------------
int methodOnTPM_Event()
{
  unsigned int v0; // r1@13
  char *v1; // r0@13
  unsigned int v2; // r1@27
  unsigned int v3; // r0@47
  char v4; // r0@50
  signed int v5; // r0@70
  signed int v6; // r0@76
  unsigned int v7; // r5@77
  int v8; // r6@77

  if ( (unsigned __int8)byte_20000171 < 9u )
  {
    switch ( byte_20000171 )
    {
      case 0:
        byte_20000170 = 1;
        dword_20000184 += 3850;
        break;
      case 1:
        if ( byte_20000172 )
        {
          if ( byte_20000172 == 3 )
            goto LABEL_21;
          byte_20000171 = 2;
          dword_20000184 += 900;
        }
        else
        {
          byte_20000171 = 3;
          dword_20000184 += 1000;
        }
        break;
      case 2:
        byte_20000171 = 3;
        dword_20000184 += 500;
        break;
      case 3:
        if ( !byte_20000172 )
          goto LABEL_14;
        byte_20000171 = 4;
        ++dword_2000019C;
        dword_20000184 += 200;
        if ( byte_20000172 != 3 && byte_20000172 != 4 && byte_20000172 != 5 )
        {
          byte_2000017A = 0;
          byte_2000017D = -16;
          spiSend(&byte_2000017D, 1u);
          setPortE1_unsetE0(0);
          byte_20000180 = 15;
          byte_20000181 = byte_20000176 - 1;
          spiSend(&byte_20000180, 2u);
          byte_2000017D = -64;
          v0 = 1;
          v1 = &byte_2000017D;
          goto LABEL_64;
        }
        break;
      case 5:
LABEL_14:
        byte_20000171 = 6;
        byte_20000177 = 1;
        goto LABEL_15;
      case 4:
        byte_20000171 = 5;
        byte_20000170 = 1;
        if ( byte_20000172 == 1 )
        {
          dword_20000184 += (int)&unk_5DC;
        }
        else
        {
          dword_20000184 += 1750;
          if ( byte_20000172 == 6 )
LABEL_21:
            sub_8028();
        }
        break;
      case 6:
        byte_20000171 = 7;
LABEL_15:
        dword_20000184 += 100;
        break;
      case 7:
        byte_20000171 = 8;
        dword_20000184 += 200;
        byte_2000017D = -96;
        spiSend(&byte_2000017D, 1u);
        if ( byte_20000172 == 3
          || ((byte_2000017D = -32, spiSend(&byte_2000017D, 1u), !byte_20000172) ? (v2 = 22) : byte_20000172 == 1 ? (v2 = 38) : byte_20000172 == 6 ? (v2 = 30) : (v2 = 39),
              (spiSend(&byte_1FFFFDB9, v2), byte_20000172 == 3) || byte_20000172 == 4 || byte_20000172 == 5) )
        {
          setC7_unsetC4((unsigned __int8)byte_2000017C);
        }
        else
        {
          setC7_unsetC4((unsigned __int8)byte_2000017B);
          byte_2000017B ^= 1u;
        }
        if ( byte_20000174 )
        {
          byte_20000174 = 0;
          byte_20000180 = 40;
          byte_20000181 = dword_20000194;
          spiSend(&byte_20000180, 2u);
        }
        setPortE1_unsetE0(1);
        if ( byte_20000178 && byte_20000178 != 3 )
        {
          if ( byte_20000178 == 1 || byte_20000178 == 2 )
          {
            if ( byte_20000172 )
            {
              if ( byte_20000176 == 13 )
              {
                byte_20000176 = -116;
                byte_2000017B ^= 1u;
              }
              else
              {
                v4 = 13;
LABEL_53:
                byte_20000176 = v4;
              }
            }
            else
            {
              byte_20000176 = 1;
            }
          }
        }
        else
        {
          if ( (unsigned __int8)++byte_20000175 >= (unsigned int)dword_20000198 )
          {
            byte_20000175 = 0;
            byte_2000017B ^= 1u;
          }
          if ( (unsigned __int8)byte_20000173 < 7u )
          {
            switch ( byte_20000173 )
            {
              case 0:
                v3 = ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | ((unsigned int)BYTE3(TX_ID) << 24)) << 24 >> 28;
                if ( v3 > 9 )
                  v3 = 9;
                byte_20000176 = *((_BYTE *)&dword_EA64[4 * v3 + 30]
                                + *((_BYTE *)&dword_EA64[70]
                                  + (16
                                   * ((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | (BYTE3(TX_ID) << 24)) & 0xFF)
                                  + (unsigned __int8)byte_20000175
                                  + 1)
                                + 1);
                break;
              case 1:
                v4 = (TX_ID & 0x1F)
                   + 7
                   * *((_BYTE *)&dword_EA64[4
                                          * (((unsigned __int8)TX_ID | (BYTE1(TX_ID) << 8) | (BYTE2(TX_ID) << 16) | ((unsigned int)BYTE3(TX_ID) << 24)) << 24 >> 29)
                                          + 134]
                     + (unsigned __int8)byte_20000175
                     + 1)
                   + 5;
                goto LABEL_53;
              case 2:
                v4 = *((_BYTE *)&TX_ID + (unsigned __int8)byte_20000175 + 4);
                goto LABEL_53;
              case 3:
              case 4:
                v4 = dword_200001A0;
                goto LABEL_53;
              case 5:
                if ( (unsigned int)(unsigned __int8)++byte_20000176 - 10 < 0x8D )
                  break;
                v4 = 10;
                goto LABEL_53;
              case 6:
                v4 = -96;
                goto LABEL_53;
              default:
                break;
            }
          }
        }
        byte_20000180 = 15;
        byte_20000181 = byte_20000176;
        v0 = 2;
        v1 = &byte_20000180;
LABEL_64:
        spiSend(v1, v0);
        break;
      case 8:
        dword_20000184 += 100;
        if ( (unsigned __int8)byte_20000172 == (unsigned __int8)byte_20000173 )
        {
          byte_20000171 = 1;
          byte_2000017D = -48;
          spiSend(&byte_2000017D, 1u);
        }
        else
        {
          byte_20000172 = byte_20000173;
          byte_20000175 = 0;
          if ( byte_20000173
            && byte_20000173 != 1
            && (unsigned __int8)RANDOM_BYTES[0] != (unsigned __int8)RANDOM_BYTES[16] )
          {
            v5 = 32;
          }
          else
          {
            v5 = 16;
          }
          dword_20000198 = v5;
          if ( byte_20000173 )
          {
            switch ( byte_20000173 )
            {
              case 1:
                v6 = 1;
                break;
              case 3:
                v6 = 3;
                break;
              case 6:
                v6 = 4;
                break;
              default:
                v6 = 2;
                break;
            }
          }
          else
          {
            v6 = 0;
          }
          v7 = 0;
          v8 = 10 * v6 + 0xEA4F;
          do
            spiSend((_BYTE *)(v8 + 2 * v7++), 2u);
          while ( v7 < 5 );
        }
        break;
      default:
        return sub_8540(dword_20000184);
    }
  }
  return sub_8540(dword_20000184);
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// C: using guessed type int HardFault;
// 10: using guessed type int dword_10;
// 1400: using guessed type int TX_ID;
// EA64: using guessed type int dword_EA64[182];
// 1FFFFDB9: using guessed type char byte_1FFFFDB9;
// 20000170: using guessed type char byte_20000170;
// 20000171: using guessed type char byte_20000171;
// 20000172: using guessed type char byte_20000172;
// 20000173: using guessed type char byte_20000173;
// 20000174: using guessed type char byte_20000174;
// 20000175: using guessed type char byte_20000175;
// 20000176: using guessed type char byte_20000176;
// 20000177: using guessed type char byte_20000177;
// 20000178: using guessed type char byte_20000178;
// 2000017A: using guessed type char byte_2000017A;
// 2000017B: using guessed type char byte_2000017B;
// 2000017C: using guessed type char byte_2000017C;
// 2000017D: using guessed type char byte_2000017D;
// 20000180: using guessed type char byte_20000180;
// 20000181: using guessed type char byte_20000181;
// 20000184: using guessed type int dword_20000184;
// 20000194: using guessed type int dword_20000194;
// 20000198: using guessed type int dword_20000198;
// 2000019C: using guessed type int dword_2000019C;
// 200001A0: using guessed type int dword_200001A0;

//----- (000090B8) --------------------------------------------------------
char *rxBindingPage()
{
  char *result; // r0@7
  unsigned int v1; // r1@9

  timerSendPacket(50000);
  sendingPacket = 1;
  addPacketToResend1FFFFCF5When2000013C(165);
  byte_20000003 = 0;
  callSetupDMAandSend();
  do
  {
    displayTextAt("RXBinding..", 0, 10, 0);
    LCD_updateCALL();
  }
  while ( (sub_2574() == 255 || getKeyCode() != 11) && !byte_20000003 );
  if ( byte_20000003 )
  {
    displayTextAt("RXBind Fail", 0, 20, 0);
    LCD_updateCALL();
    addPacketToResend1FFFFCF5When2000013C(166);
  }
  result = (char *)(unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 106];
  if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
  {
    result = (char *)(unsigned __int8)byte_20000003;
    if ( byte_20000003 )
    {
      displayTextAt("RXBind OK  ", 0, 20, 0);
      LCD_updateCALL();
      timerSendPacket(500000);
      addPacketToResend1FFFFCF5When2000013C(154);
      timerSendPacket(50000);
      v1 = dword_1FFFF884;
      result = &rxsettings[146 * (unsigned __int8)currentModel + 97];
      result[12] = dword_1FFFF884;
      result[13] = BYTE1(v1);
      result[14] = v1 >> 16;
      result[15] = BYTE3(v1);
    }
  }
  sendingPacket = 0;
  return result;
}
// 8: using guessed type int NMI;
// 1FFFF884: using guessed type int dword_1FFFF884;
// 20000003: using guessed type char byte_20000003;
// 2000013E: using guessed type char sendingPacket;
// 200002AD: using guessed type char currentModel;

//----- (000091B0) --------------------------------------------------------
int RxSetupPage()
{
  showNavigationPage("RX Setup", 9u, (char **)&unk_D2C0);
  return 0;
}

//----- (000091C8) --------------------------------------------------------
signed int RFStandardPage()
{
  const char *v0; // r0@2
  int v1; // r0@4
  int v3; // r1@12
  unsigned int v4; // r0@13
  char v5; // cf@14
  int v6; // r1@18
  unsigned int v7; // r0@19
  unsigned int v8; // r0@20
  char v9; // [sp+0h] [bp-38h]@13
  char v10; // [sp+1h] [bp-37h]@13
  char v11; // [sp+2h] [bp-36h]@13
  char v12; // [sp+3h] [bp-35h]@13
  char v13; // [sp+4h] [bp-34h]@13

  while ( 1 )
  {
    while ( 1 )
    {
      callSetupDMAandSend();
      displayPageHeader("RF Standard");
      displayTextAt("AFHDS 2A", 36, 24, 0);
      if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
        v0 = "On";
      else
        v0 = "Off";
      displayTextAt(v0, 54, 40, 0);
      LCD_updateCALL();
      v1 = getKeyCode();
      if ( v1 == 9 || v1 == 23 )
      {
        v3 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 106] ^ 1;
        rxsettings[146 * (unsigned __int8)currentModel + 106] = v3;
        if ( v3 == 1 )
        {
          timerSendPacket(25000);
          v9 = -101;
          v4 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 109] | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 110] << 8) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 111] << 16) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 112] << 24);
          v10 = rxsettings[146 * (unsigned __int8)currentModel + 109];
          v11 = BYTE1(v4);
          v12 = v4 >> 16;
          v13 = BYTE3(v4);
          sendPacketToRadio(&v9, &v9, v4 >> 16);
        }
        v5 = (unsigned int)sub_9BC0() >= 2;
        goto LABEL_15;
      }
      if ( v1 != 8 && v1 != 24 )
        break;
      v6 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 106] ^ 1;
      rxsettings[146 * (unsigned __int8)currentModel + 106] = v6;
      if ( v6 == 1 )
      {
        timerSendPacket(25000);
        v9 = -101;
        v7 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 109] | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 110] << 8) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 111] << 16) | ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 112] << 24);
        v10 = rxsettings[146 * (unsigned __int8)currentModel + 109];
        v11 = BYTE1(v7);
        v12 = v7 >> 16;
        v13 = BYTE3(v7);
        sendPacketToRadio(&v9, &v9, v7 >> 16);
      }
      v8 = sub_9BC0();
      v5 = v8 >= 2;
      if ( v8 < 2 )
      {
LABEL_15:
        if ( v5 )
          goto LABEL_21;
      }
      else
      {
LABEL_21:
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v1 == 25 || v1 == 10 )
      return 1;
    if ( v1 == 11 )
      return 0;
  }
}
// 8: using guessed type int NMI;
// 200002AD: using guessed type char currentModel;

//----- (00009334) --------------------------------------------------------
signed int ServosFreqMenu()
{
  int v0; // r0@1
  char *v2; // r1@10
  unsigned int v3; // r0@10
  __int16 v4; // r0@11
  char *v5; // r1@13
  unsigned int v6; // r0@13
  __int16 v7; // r0@14
  char *v8; // r0@16
  unsigned int v9; // r5@18
  int v10; // [sp+0h] [bp-20h]@1

  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("Servos Freq");
          displayTextAt("Frequency", 28, 24, 0);
          intToString(
            ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 114] << 8) | (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 113],
            (char *)&v10,
            3u);
          BYTE3(v10) = 0;
          displayTextAt(&v10, 50, 40, 0);
          LCD_updateCALL();
          v0 = getKeyCode();
          if ( v0 != 8 && v0 != 24 )
            break;
          v2 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
          v3 = ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 114] << 8) | (unsigned __int8)*v2;
          if ( v3 > 0x32 )
          {
            v4 = v3 - 1;
            *v2 = v4;
            v2[1] = HIBYTE(v4);
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_17:
              beep(784, 15);
              beep(0, 15);
            }
          }
        }
        if ( v0 != 9 && v0 != 23 )
          break;
        v5 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
        v6 = ((unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 114] << 8) | (unsigned __int8)*v5;
        if ( v6 < 0x17C )
        {
          v7 = v6 + 1;
          *v5 = v7;
          v5[1] = HIBYTE(v7);
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_17;
        }
      }
      if ( v0 != 22 )
        break;
      v8 = &rxsettings[146 * (unsigned __int8)currentModel + 113];
      *v8 = 50;
      v8[1] = 0;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_17;
    }
    if ( v0 == 25 || v0 == 10 )
      break;
    if ( v0 == 11 )
      return 0;
  }
  v9 = 0;
  do
  {
    while ( byte_2000013F == 1 )
      sendPacketWithTimer();
    ++v9;
    byte_2000013F = 1;
  }
  while ( v9 < 5 );
  return 1;
}
// 8: using guessed type int NMI;
// 2000013F: using guessed type char byte_2000013F;
// 200002AD: using guessed type char currentModel;

//----- (00009470) --------------------------------------------------------
int ibussetupmenu()
{
  unsigned int channel; // r4@1
  unsigned int channelChar; // r6@2
  int v2; // r0@4
  int v4; // r2@25
  int v5; // [sp+0h] [bp-50h]@20
  int v6; // [sp+4h] [bp-4Ch]@20
  int v7; // [sp+8h] [bp-48h]@20
  int v8; // [sp+Ch] [bp-44h]@20
  int v9; // [sp+10h] [bp-40h]@20
  _BYTE text[4]; // [sp+14h] [bp-3Ch]@1
  __int16 targetAddress; // [sp+18h] [bp-38h]@25
  unsigned __int8 v12; // [sp+1Ah] [bp-36h]@25
  char v13; // [sp+1Bh] [bp-35h]@25
  char v14; // [sp+1Ch] [bp-34h]@25
  __int16 v15; // [sp+1Dh] [bp-33h]@25

  channel = 1;
  *(_DWORD *)text = '1HC';
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("i-BUS Setup");
          displayTextAt("Channel", 36, 24, 0);
          channelChar = (unsigned __int8)(channel + 48);
          text[2] = channel + 48;
          displayTextAt(text, 50, 40, 0);
          if ( channel >= 0xA )
            displayTextAt("CH10", 50, 40, 0);
          LCD_updateCALL();
          v2 = getKeyCode();
          if ( v2 != 8 && v2 != 24 )
            break;
          if ( channel > 1 )
          {
            --channel;
            if ( (unsigned int)sub_9BC0() >= 2 )
            {
LABEL_17:
              beep(784, 15);
              beep(0, 15);
            }
          }
        }
        if ( v2 != 9 && v2 != 23 )
          break;
        if ( channel < 0xA )
        {
          ++channel;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_17;
        }
      }
      if ( v2 != 25 && v2 != 10 )
        break;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
      v8 = 0;
      v7 = 'hC g';
      v6 = 'ning';
      v5 = 'issA';
      v9 = 0;
      callSetupDMAandSend();
      displayPageHeader("i-BUS Setup");
      LOWORD(v8) = (unsigned __int8)channelChar;
      if ( channelChar >= ':' )
      {
        LOWORD(v8) = '01';
        BYTE2(v8) = 0;
      }
      displayTextAt(&v5, 10, 10, 0);
      displayTextAt("Press the", 28, 22, 0);
      displayTextAt("corresponding", 10, 30, 0);
      displayTextAt("servo interface", 4, 38, 0);
      displayTextAt("button or", 28, 46, 0);
      displayTextAt("press 'CANCEL'", 8, 54, 0);
      LCD_updateCALL();
      sendingPacket = 1;
      dword_20000058 = 0;
      dword_2000005C = channel - 1;
      dword_20000030 = -1;
      while ( dword_20000030 == -1 )
      {
        if ( timer - dword_20000058 >= 0xA )
        {
          setupDMA(&targetAddress, 29u, 0xFFu);
          targetAddress = 0xFEAAu;
          v12 = 0xFFu;
          v13 = 0;
          v14 = 0;
          v15 = dword_2000005C;
          sendPacketToRadio(&targetAddress, (char *)((unsigned int)dword_2000005C >> 8), v4);
          dword_20000058 = timer;
        }
        if ( sub_2574() != 255 && getKeyCode() == 11 )
        {
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
            beep(784, 15);
            beep(0, 15);
          }
          break;
        }
      }
      sendingPacket = 0;
    }
  }
  while ( v2 != 11 );
  return 0;
}
// 20000030: using guessed type int dword_20000030;
// 20000058: using guessed type int dword_20000058;
// 2000005C: using guessed type int dword_2000005C;
// 2000013E: using guessed type char sendingPacket;

//----- (000096AC) --------------------------------------------------------
void PPMOutMenu()
{
  int v0; // r1@1
  const char *v1; // r2@1
  _BYTE *v2; // r0@4
  int v3; // r0@6
  unsigned int v4; // r5@17

  do
  {
    while ( 1 )
    {
      callSetupDMAandSend();                    // ca77 ->ON
                                                // 
      displayPageHeader("RX Output");
      v0 = (unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 107];
      v1 = "IBUS/PWM";
      while ( v0 )
      {
        v0 -= (signed int)byte_1;
        v1 += 9;
      }
      displayTextAt(v1, 54, 40, 0);
      LCD_updateCALL();
      v3 = getKeyCode();
      if ( v3 != 9 && v3 != 23 && v3 != 8 && v3 != 24 )
        break;
      v2 = &byte_1[(unsigned __int8)rxsettings[146 * (unsigned __int8)currentModel + 107]];
      if ( (signed int)v2 >= 4 )
        v2 = 0;
      rxsettings[146 * (unsigned __int8)currentModel + 107] = (char)v2;
      if ( v2 == byte_1 )
        timerSendPacket(25000);
      v4 = 0;
      do
      {
        while ( byte_2000013F == 1 )
          sendPacketWithTimer();
        ++v4;
        byte_2000013F = 1;
      }
      while ( v4 < 5 );
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
        beep(784, 15);
        beep(0, 15);
      }
    }
  }
  while ( v3 != 25 && v3 != 10 && v3 != 11 );
}
// 8: using guessed type int NMI;
// 2000013F: using guessed type char byte_2000013F;
// 200002AD: using guessed type char currentModel;

//----- (00009798) --------------------------------------------------------
int setFactVal()
{
  unsigned int v0; // r4@1
  int result; // r0@2

  *(_DWORD *)rxsettings = 1;
  trainerMode = 0;
  trainerSW = 19;
  lcdBrightnes = HIBYTE(stickAdjustData[18]);
  stickModeSW = stickAdjustData[18];
  byte_200002AB = 1;
  currentModel = 0;
  FailSafeCH1L = -1;
  FailSafeCH1H = 127;
  FailSafeCH2L = -1;
  FailSafeCH2H = 127;
  FailSafeCH3L = -1;
  FailSafeCH3H = 127;
  FailSafeCH4L = -1;
  FailSafeCH4H = 127;
  FailSafeCH5L = -1;
  FailSafeCH5H = 127;
  FailSafeCH6L = -1;
  FailSafeCH6H = 127;
  usedModelPtr = (int)modelname;
  settings_10 = 0;
  settings_11 = 0;
  settings_12 = 0;
  settings_13 = 0;
  v0 = 0;
  do
  {
    memcpy(&rxsettings[146 * v0 + 10], 0xD179, 146u);
    result = printNumberAsStringAt(v0 + 1, &rxsettings[146 * v0 + 16], 2u);
    ++v0;
  }
  while ( v0 < 0x14 );
  return result;
}
// 2000002C: using guessed type int usedModelPtr;
// 200002A8: using guessed type char trainerMode;
// 200002A9: using guessed type char trainerSW;
// 200002AA: using guessed type char stickModeSW;
// 200002AB: using guessed type char byte_200002AB;
// 200002AC: using guessed type char lcdBrightnes;
// 200002AD: using guessed type char currentModel;
// 200002B8: using guessed type char settings_10;
// 200002B9: using guessed type char settings_11;
// 200002BA: using guessed type char settings_12;
// 200002BB: using guessed type char settings_13;
// 20000317: using guessed type char FailSafeCH1L;
// 20000318: using guessed type char FailSafeCH1H;
// 20000319: using guessed type char FailSafeCH2L;
// 2000031A: using guessed type char FailSafeCH2H;
// 2000031B: using guessed type char FailSafeCH3L;
// 2000031C: using guessed type char FailSafeCH3H;
// 2000031D: using guessed type char FailSafeCH4L;
// 2000031E: using guessed type char FailSafeCH4H;
// 2000031F: using guessed type char FailSafeCH5L;
// 20000320: using guessed type char FailSafeCH5H;
// 20000321: using guessed type char FailSafeCH6L;
// 20000322: using guessed type char FailSafeCH6H;

//----- (00009830) --------------------------------------------------------
signed int ResetOdo1Menu()
{
  signed int result; // r0@1
  int v1; // r0@2

  callSetupDMAandSend();
  displayPageHeader("Reset odometer 1");
  displayTextAt2("This will reset", 64, 16, 0);
  displayTextAt2("the odmeter 1", 64, 24, 0);
  LCD_updateCALL();
  result = sub_23F4();
  if ( result )
  {
    v1 = usedModelPtr + 130;
    *(_BYTE *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 9) = 0;
    *(_BYTE *)(v1 + 10) = 0;
    result = 1;
  }
  return result;
}
// 2000002C: using guessed type int usedModelPtr;

//----- (000098AC) --------------------------------------------------------
signed int ResetOdo2Menu()
{
  signed int result; // r0@1
  int v1; // r0@2

  callSetupDMAandSend();
  displayPageHeader("Reset odometer 2");
  displayTextAt2("This will reset", 64, 16, 0);
  displayTextAt2("the odmeter 2", 64, 24, 0);
  LCD_updateCALL();
  result = sub_23F4();
  if ( result )
  {
    v1 = usedModelPtr + 130;
    *(_BYTE *)(v1 + 12) = 0;
    *(_BYTE *)(v1 + 13) = 0;
    *(_BYTE *)(v1 + 14) = 0;
    result = 1;
  }
  return result;
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00009940) --------------------------------------------------------
signed int ReverseMenu()
{
  unsigned int v0; // r4@2
  void *v1; // r0@4
  int v2; // r0@7
  signed int result; // r0@12
  int v4; // r0@16
  unsigned int v5; // [sp+0h] [bp-20h]@1
  char text; // [sp+4h] [bp-1Ch]@3
  char v7; // [sp+5h] [bp-1Bh]@3

  byte_20000002 = 1;
  v5 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Reverse");
        displayTextAt2("Ch", 12, 24, 0);
        displayTextAt("Nor", 0, 36, 0);
        displayTextAt("Rev", 0, 52, 0);
        displayGFX((int)&unk_CC04, 16 * v5 + 28, 16);
        v0 = 0;
        do
        {
          text = v0 + 49;
          v7 = 0;
          displayTextAt(&text, 16 * v0 + 28, 24, 0);
          if ( *(_BYTE *)(usedModelPtr + 94) & (1 << v0) )
            v1 = &unk_CC28;
          else
            v1 = &unk_CC1C;
          displayGFX((int)v1, 16 * v0++ + 24, 32);
        }
        while ( v0 < 6 );
        LCD_updateCALL();
        v2 = getKeyCode();
        if ( v2 != 9 && v2 != 8 )
          break;
        *(_BYTE *)(usedModelPtr + 94) ^= 1 << v5;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_14;
      }
      if ( v2 != 10 )
        break;
      if ( v5 < 5 )
        v4 = v5 + 1;
      else
        v4 = 0;
      v5 = v4;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
LABEL_14:
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v2 == 25 )
      break;
    if ( v2 == 11 )
    {
      result = 0;
      byte_20000002 = 0;
      return result;
    }
  }
  byte_20000002 = 0;
  return 1;
}
// 20000002: using guessed type char byte_20000002;
// 2000002C: using guessed type int usedModelPtr;

//----- (00009A60) --------------------------------------------------------
signed int __fastcall RotationLenMenu(int a1, int a2, int a3, int a4)
{
  int v4; // r6@2
  int v5; // r5@2
  unsigned int v6; // r0@3
  char v7; // r1@3
  unsigned int v8; // r0@3
  char v9; // r1@3
  char v10; // r1@3
  int *v11; // r0@3
  char v12; // r1@5
  char v13; // r5@5
  unsigned int v14; // r0@5
  char v15; // r1@5
  char v16; // r1@6
  int v17; // r0@7
  int v19; // r1@15
  unsigned int v20; // r0@15
  __int16 v21; // r0@16
  int v22; // r1@18
  unsigned int v23; // r0@18
  __int16 v24; // r0@20
  int v25; // [sp+0h] [bp-18h]@1

  v25 = a4;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Rotation length ");
        displayTextAt("Length(mm)", 24, 24, 0);
        v4 = usedModelPtr + 128;
        v5 = (*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136);
        if ( (unsigned int)(v5 + 99) < 0xC7 )
        {
          if ( (unsigned int)(v5 + 9) < 0x13 )
          {
            div_Other((*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136), 0xAu);
            v11 = &v25;
            LOWORD(v25) = (unsigned __int8)(v16 + 48);
          }
          else
          {
            div_Other((*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136), 0xAu);
            v13 = v12;
            div_Other(v14, 0xAu);
            v11 = &v25;
            LOBYTE(v25) = v15 + 48;
            *(_WORD *)((char *)&v25 + 1) = (unsigned __int8)(v13 + 48);
          }
        }
        else
        {
          div_Other((*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136), 0x64u);
          div_Other(v6, 0xAu);
          LOBYTE(v25) = v7 + 48;
          div_Other(v5, 0xAu);
          div_Other(v8, 0xAu);
          BYTE1(v25) = v9 + 48;
          div_Other((*(_BYTE *)(v4 + 9) << 8) | *(_BYTE *)(v4 + 8), 0xAu);
          v11 = &v25;
          HIWORD(v25) = (unsigned __int8)(v10 + 48);
        }
        displayTextAt(v11, 54, 40, 0);
        LCD_updateCALL();
        v17 = getKeyCode();
        if ( v17 != 9 && v17 != 23 )
          break;
        v19 = usedModelPtr + 128;
        v20 = (*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136);
        if ( v20 < 0x1F4 )
        {
          v21 = v20 + 1;
          *(_BYTE *)(usedModelPtr + 136) = v21;
          *(_BYTE *)(v19 + 9) = HIBYTE(v21);
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_21:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v17 != 8 && v17 != 24 )
        break;
      v22 = usedModelPtr + 128;
      v23 = (*(_BYTE *)(usedModelPtr + 137) << 8) | *(_BYTE *)(usedModelPtr + 136);
      if ( v23 > 1 )
      {
        v24 = v23 - 1;
        *(_BYTE *)(usedModelPtr + 136) = v24;
        *(_BYTE *)(v22 + 9) = HIBYTE(v24);
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_21;
      }
    }
    if ( v17 == 25 || v17 == 10 )
      return 1;
    if ( v17 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (00009BC0) --------------------------------------------------------
int sub_9BC0()
{
  int v0; // r0@1

  v0 = dword_1FFFF88C;
  if ( dword_1FFFF888 > (unsigned int)dword_1FFFF88C )
    v0 = dword_1FFFF88C + 16;
  return 15 - (v0 - dword_1FFFF888);
}
// 1FFFF888: using guessed type int dword_1FFFF888;
// 1FFFF88C: using guessed type int dword_1FFFF88C;

//----- (00009BD8) --------------------------------------------------------
unsigned int buzzerSetup()
{
  unsigned int result; // r0@1

  dword_1FFFF890 = 0;
  dword_1FFFF888 = 0;
  dword_1FFFF88C = 0;
  v4004803C |= 0x2000000u;                      // System Clock Gating Control Register 6 (SIM_SCGC6
  v40049030 = 768;                              // Pin Control Register n (PORTA_PCR12)
  v40039000 = 75;                               // Status and Control (TPM1_SC)
  v40039008 = 0xFFFF;                           // Modulo (TPM1_MOD)
  v4003900C = 40;                               // Channel (n) Status and Control (TPM1_C0SC
  v40039004 = 0;                                // Counter (TPM1_CNT)
  v40039010 = 0;                                // Channel (n) Value (TPM1_C0V)
  vE000E410 &= 0xFF00FFFF;
  result = 0xE000E100;
  vE000E100 |= 0x40000u;
  return result;
}
// 1FFFF888: using guessed type int dword_1FFFF888;
// 1FFFF88C: using guessed type int dword_1FFFF88C;
// 1FFFF890: using guessed type int dword_1FFFF890;

//----- (00009C3C) --------------------------------------------------------
int __fastcall beep(int result, __int16 a2)
{
  bool v2; // r5@1
  int v3; // r2@1
  int v4; // r6@4

  v2 = dword_1FFFF88C == dword_1FFFF888;
  v3 = dword_1FFFF88C + 1;
  if ( (unsigned int)(dword_1FFFF88C + 1) >= 0x10 )
    v3 = 0;
  if ( v3 != dword_1FFFF888 )
  {
    v4 = 2 * dword_1FFFF88C;
    word_1FFFFD12[v4] = result;
    result = (int)&word_1FFFFD12[v4];
    word_1FFFFD12[v4 + 1] = a2;
    dword_1FFFF88C = v3;
    if ( v2 )
    {
      TMP1_method_beep_modulation();
      result = 768;
      v40049030 = 768;
    }
  }
  return result;
}
// 1FFFF888: using guessed type int dword_1FFFF888;
// 1FFFF88C: using guessed type int dword_1FFFF88C;

//----- (00009C88) --------------------------------------------------------
int *TMP1_method_beep_modulation()
{
  int *result; // r0@1
  int v1; // r4@5
  unsigned int v2; // r1@7
  unsigned int v3; // r0@8
  unsigned int v4; // r1@8
  unsigned int v5; // r4@9
  int v6; // r0@9

  result = &dword_1FFFF888;
  if ( dword_1FFFF890 )
  {
    if ( --dword_1FFFF890 <= 0 )
      dword_1FFFF890 = 0;
  }
  else
  {
    v1 = dword_1FFFF888;
    if ( dword_1FFFF888 == dword_1FFFF88C )
    {
      v40049030 = 256;                          // Pin Control Register n (PORTA_PCR12)
    }
    else
    {
      v40039004 = 0;                            // Counter (TPM1_CNT)
      v2 = word_1FFFFD12[2 * dword_1FFFF888];
      if ( word_1FFFFD12[2 * dword_1FFFF888] )
      {
        v40049030 = 768;
        div_Other(0xF4240u, v2);
        v4 = v3;
        v40039010 = (v3 >> 1) - 1;
      }
      else
      {
        v40049030 = 256;
        v400FF014 |= 0x1000u;
        v400FF008 = 4096;
        v4 = 1000;
      }
      v40039008 = v4 - 1;
      div_Other(1000 * word_1FFFFD12[2 * v1 + 1], v4);
      v5 = v1 + 1;
      dword_1FFFF890 = v6;
      if ( v5 >= 0x10 )
        v5 = 0;
      dword_1FFFF888 = v5;
      result = TMP1_method_beep_modulation();
    }
  }
  return result;
}
// 1FFFF888: using guessed type int dword_1FFFF888;
// 1FFFF88C: using guessed type int dword_1FFFF88C;
// 1FFFF890: using guessed type int dword_1FFFF890;

//----- (00009D28) --------------------------------------------------------
signed int setupPortsC4_c5_c6_spi_DMA2_DMA3()
{
  signed int result; // r0@1

  v40048034 |= 0x400000u;                       // System Clock Gating Control Register 4 (SIM_SCGC4)
  v4004B010 = 256;                              // Pin Control Register n (PORTC_PCR4)
  v4004B014 = 512;                              // Pin Control Register n (PORTC_PCR5)
  v4004B018 = 512;                              // Pin Control Register n (PORTC_PCR6)
  v400FF094 |= 0x10u;
  v400FF084 = 16;                               // Port Set Output Register (GPIOC_PSOR)
  v40076003 = 82;                               // SPI Control Register 1 (SPI0_C1)
  v40076002 = 1;                                // SPI Control Register 2 (SPI0_C2)
  v40076001 = 1;                                // SPI Baud Rate Register (SPI0_BR)
  v40021002 = 0x91u;                            // Channel Configuration register (DMAMUX0_CHCFG2)
  result = 1073774848;
  v40008124 = 0x40076006;                       // Destination Address Register (DMA_DAR2)
  v4000812C = 542244992;                        // DMA Control Register (DMA_DCR2)
  v40021003 = -112;                             // Channel Configuration register (DMAMUX0_CHCFG3)
  v40008130 = 0x40076006;                       // Source Address Register (DMA_SAR3)
  v4000813C = 538574976;                        // DMA Control Register (DMA_DCR3
  return result;
}

//----- (00009D98) --------------------------------------------------------
signed int __fastcall sendOverSPI_useDMA(char a1, _BYTE *destination, unsigned int length)
{
  _BYTE *v3; // r7@1
  unsigned int v4; // r6@1
  signed int result; // r0@16

  v3 = destination;
  v4 = length;
  v40076002 |= 8u;                              // SPI Control Register 2 (SPI0_C2)
  v400FF088 = 16;                               // Port Clear Output Register (GPIOC_PCOR)
  v40076002 &= 0xDBu;                           // SPI Control Register 2 (SPI0_C2)
  v4000812C &= 0xBFFFFFFF;                      // DMA Control Register (DMA_DCR2)
  while ( !(v40076000 & 0x20) )                 // SPI Status Register (SPI0_S)
    ;
  v40076006 = a1;                               // SPI Data Register low (SPI0_DL)
  while ( !(v40076000 & 0x80) )                 // SPI Status Register (SPI0_S)
    ;
  v40076002 &= 0xF7u;                           // SPI Control Register 2 (SPI0_C2)
  v40008134 = destination;                      // Destination Address Register (DMA_DAR3)
  v40008138 = length;                           // DMA_DSR_BCR3
  v40076002 |= 4u;
  v4000813C |= 0x40000000u;
  if ( length > 1 )
  {
    v40008120 = destination + 1;                // Source Address Register (DMA_SAR2)
    v40008128 = length - 1;                     // DMA Status Register / Byte Count Register DMA_DSR_BCR2
  }
  while ( !(v40076000 & 0x20) )                 // SPI Status Register (SPI0_S)
    ;
  sub_A158();
  v40076006 = *v3;                              // SPI Data Register low (SPI0_DL)
  if ( v4 > 1 )
  {
    v40076002 |= 0x20u;                         // // SPI Control Register 2 (SPI0_C2)
    v4000812C |= 0x40000000u;                   // DMA Control Register (DMA_DCR2)
  }
  sub_A190();
  while ( v40008138 << 8 )                      // DMA Status Register / Byte Count Register DMA_DSR_BCR3
    ;
  if ( v40008128 & 0x1000000 )                  // DMA Status Register / Byte Count Register DMA_DSR_BCR2
    v40008128 |= 0x1000000u;
  if ( v40008138 & 0x1000000 )                  // DMA Status Register / Byte Count Register DMA_DSR_BCR3
    v40008138 |= 0x1000000u;
  result = 16;
  v400FF084 = 16;                               // Port Set Output Register (GPIOC_PSOR)
  return result;
}

//----- (00009E58) --------------------------------------------------------
signed int __fastcall spiSend(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // r7@1
  unsigned int v3; // r6@1
  signed int result; // r0@14

  v2 = a1;
  v3 = a2;
  v40076002 &= 0xDBu;                           //  SPI Control Register 2 (SPI0_C2) 
  v4000812C &= 0xBFFFFFFF;                      // DMA Control Register (DMA_DCR2)
  while ( !(v40076000 & 0x20) )                 // SPI Status Register (SPI0_S)
    ;
  if ( a2 > 1 )
  {
    v40008120 = a1 + 1;                         // Source Address Register (DMA_SAR2) 
    v40008128 = a2 - 1;                         // DMA Status Register / Byte Count Register (DMA_DSR_BCR2)
                                                // 
  }
  v40076002 |= 8u;                              // SPI Control Register 2 (SPI0_C2)
  v400FF088 = 16;                               // Port Clear Output Register (GPIOC_PCOR)
  sub_A158();
  v40076006 = *v2;                              // SPI Data Register low (SPI0_DL)
  if ( v3 > 1 )
  {
    v40076002 |= 0x20u;                         // SPI Control Register 2 (SPI0_C2)
    v4000812C |= 0x40000000u;                   // DMA Control Register (DMA_DCR2)
  }
  sub_A190();
  if ( v3 > 1 )
  {
    while ( v40008128 << 8 )                    // DMA Status Register / Byte Count Register (DMA_DSR_BCR2)
      ;
    if ( v40008128 & 0x1000000 )
      v40008128 |= 0x1000000u;
    if ( v40008138 & 0x1000000 )                // DMA Status Register / Byte Count Register (DMA_DSR_BCR3)
      v40008138 |= 0x1000000u;
  }
  while ( !(v40076000 & 0x20) )                 // SPI Status Register (SPI0_S)
    ;
  strageSPILoop(4);
  result = 16;
  v400FF084 = 16;                               // Port Set Output Register (GPIOC_PSOR)
  return result;
}

//----- (00009EFC) --------------------------------------------------------
signed int sendPacketWithTimer()
{
  signed int result; // r0@1

  result = vE000E018 << 8;
  if ( (unsigned int)(dword_2000015C - (vE000E018 << 8)) >= 7680 )
  {
    dword_2000015C = vE000E018 << 8;
    callSendPacket();
    if ( timer - dword_20000148 >= 0x927C0 && timer - dword_2000014C >= (unsigned int)&byte_DA0[1512] )
    {
      dword_2000014C = timer;
      beep(523, 75);
      beep(784, 75);
      beep(523, 75);
    }
    sub_61EC();
    sub_618C();
    result = 1074036992;
    v40048104 = 170;
  }
  return result;
}
// 20000148: using guessed type int dword_20000148;
// 2000014C: using guessed type int dword_2000014C;
// 2000015C: using guessed type int dword_2000015C;

//----- (00009F84) --------------------------------------------------------
unsigned int __fastcall dualRateExpFunction(unsigned int a1, int a2)
{
  unsigned int v2; // r4@1
  unsigned int v3; // r2@1
  int v4; // r3@1
  int v5; // r7@1

  v2 = 0x10000;
  v3 = 0;
  v4 = 0x8000 - a2;
  v5 = a2 << 15;
  do
  {
    if ( (((v5 + v4 * ((v3 + v2) >> 1) - a2 * ((v3 + v2) >> 1)) >> 15) * ((v3 + v2) >> 1)
        + a2 * ((v3 + v2) >> 1)
        + 0x4000) >> 15 >= a1 )
      v2 = (v3 + v2) >> 1;
    else
      v3 = (v3 + v2) >> 1;
  }
  while ( v2 - v3 > 1 );
  if ( a1 - ((((v5 + v4 * v3 - a2 * v3) >> 15) * v3 + a2 * v3 + 0x4000) >> 15) > ((((v5 + v4 * v2 - a2 * v2) >> 15) * v2
                                                                                 + a2 * v2
                                                                                 + 0x4000) >> 15)
                                                                               - a1 )
    v3 = v2;
  return ((((v4 << 15) + a2 * v3 - (0x8000 - a2) * v3) >> 15) * v3 + (0x8000 - a2) * v3 + 0x4000) >> 15;
}

//----- (0000A020) --------------------------------------------------------
unsigned int __fastcall crcCheck(_BYTE *startPTR, signed int length)
{
  _BYTE *v2; // r2@1
  unsigned int result; // r0@1
  unsigned int v4; // r4@3
  int v5; // r2@6
  signed int i; // r1@8
  unsigned __int16 v7; // r4@9

  v2 = startPTR;
  result = 0xFFFF;
  if ( (unsigned int)length <= 0x7FFFFFFF )
  {
    if ( length > 0 )
    {
      v5 = (int)(v2 - 1);
      if ( length << 31 )
        result = (unsigned __int16)(*((_WORD *)dword_E828 + (*(_BYTE *)++v5 ^ 0xFF)) ^ 0xFF00);
      for ( i = length >> 1; i; --i )
      {
        v7 = *((_WORD *)dword_E828 + ((result >> 8) ^ *(_BYTE *)(v5 + 1)));
        v5 += 2;
        result = (unsigned __int16)(*((_WORD *)dword_E828
                                    + (((unsigned int)(unsigned __int16)(v7 ^ ((_WORD)result << 8)) >> 8) ^ *(_BYTE *)v5)) ^ ((v7 ^ (unsigned __int16)((_WORD)result << 8)) << 8));
      }
    }
  }
  else
  {
    for ( ; length; --length )
    {
      v4 = *((_WORD *)dword_E828 + ((result >> 8) ^ *v2++)) ^ (result << 8);
      result = (unsigned __int16)v4;
    }
  }
  return result;
}
// E828: using guessed type int dword_E828[128];

//----- (0000A0A4) --------------------------------------------------------
int __fastcall strageSPILoop(int a1)
{
  int result; // r0@1

  result = a1 << 8;
  while ( (unsigned int)result > 0 )
    ;
  return result;
}

//----- (0000A0BC) --------------------------------------------------------
signed int __fastcall timerSendPacket(int a1)
{
  unsigned int v1; // r0@1
  signed int result; // r0@3

  v1 = 768 * a1;
  while ( v1 > 0 )
    ;
  result = vE000E018 << 8;
  if ( (unsigned int)(dword_2000015C - (vE000E018 << 8)) >= 7680 )
  {
    dword_2000015C = vE000E018 << 8;
    callSendPacket();
    if ( timer - dword_20000148 >= 0x927C0 && timer - dword_2000014C >= (unsigned int)&byte_DA0[1512] )
    {
      dword_2000014C = timer;
      beep(523, 75);
      beep(784, 75);
      beep(523, 75);
    }
    sub_61EC();
    sub_618C();
    result = 0x40048100;
    v40048104 = 170;
  }
  return result;
}
// 20000148: using guessed type int dword_20000148;
// 2000014C: using guessed type int dword_2000014C;
// 2000015C: using guessed type int dword_2000015C;

//----- (0000A158) --------------------------------------------------------
char *sub_A158()
{
  char *result; // r0@1

  result = &studentMode;
  if ( !dword_20000154 )
  {
    dword_20000158 = vE000E100;
    vE000E100 = 0;
  }
  ++dword_20000154;
  return result;
}
// 20000144: using guessed type char studentMode;
// 20000154: using guessed type int dword_20000154;
// 20000158: using guessed type int dword_20000158;

//----- (0000A178) --------------------------------------------------------
int __fastcall div__0(int a1, signed int a2)
{
  int v2; // r2@1
  unsigned int v3; // r0@2

  v2 = a2 / 2;
  if ( a1 >= 0 )
    v3 = v2 + a1;
  else
    v3 = a1 - v2;
  return div_(v3, a2);
}

//----- (0000A190) --------------------------------------------------------
char *sub_A190()
{
  char *result; // r0@1

  result = &studentMode;
  if ( dword_20000154 )
  {
    if ( !--dword_20000154 )
    {
      result = (char *)dword_20000158;
      vE000E100 = dword_20000158;
    }
  }
  return result;
}
// 20000144: using guessed type char studentMode;
// 20000154: using guessed type int dword_20000154;
// 20000158: using guessed type int dword_20000158;

//----- (0000A1B0) --------------------------------------------------------
int getCurrentTicks()
{
  return vE000E018;
}

//----- (0000A1BC) --------------------------------------------------------
unsigned int kindOfInit()
{
  unsigned int result; // r0@9

  v40048100 = 13;                               // COP Control Register (SIM_COPC)
                                                // Windowed mode
                                                // COP WatchdogTimeout COP timeout after 210 LPO cycles or 218 bus clock cycles
                                                // 
  dword_20000154 = 0;
  vE000E014 = 0xFFFFFF;
  vE000E010 |= 1u;
  v40064001 = 0x9Cu;                            // MCG Control 2 Register (MCG_C2)
  v40064000 = 0x98u;                            // MCG Control 1 Register (MCG_C1)
  while ( v40064006 & 0x10 )                    //  MCG Status Register (MCG_S)
    ;
  while ( (unsigned int)v40064006 << 28 >> 30 != 2 )
    ;
  v40064004 = 32 * (v40064004 >> 5) + 3;        // MCG Control 5 Register (MCG_C5)
  v40064005 |= 0x40u;                           // MCG Control 6 Register (MCG_C6)
  v40064005 = 32 * (v40064005 >> 5);
  while ( !(v40064006 & 0x20) )                 //  MCG Status Register (MCG_S)
    ;
  while ( !(v40064006 & 0x40) )
    ;
  v40048044 = v40048044 & 0x70000 | 0x10000;
  v40064000 &= 0x3Fu;
  while ( (unsigned int)v40064006 << 28 >> 30 != 3 )//  MCG Status Register (MCG_S)
    ;
  v40065000 |= 0x80u;
  v40048004 = v40048004 & 0x3000000 | 0x2000000;// OSC Control Register (OSC0_CR)
  v40048038 |= 0x3E00u;                         // System Clock Gating Control Register 5 (SIM_SCGC5)
  v4004803C |= 2u;                              // System Clock Gating Control Register 6 (SIM_SCGC6)
  v40048040 |= 0x100u;                          // System Clock Gating Control Register 7 (SIM_SCGC7)
  dword_2000014C = 0;
  result = timer - 1;
  dword_20000148 = timer - 1;
  return result;
}
// 20000148: using guessed type int dword_20000148;
// 2000014C: using guessed type int dword_2000014C;
// 20000154: using guessed type int dword_20000154;

//----- (0000A2A8) --------------------------------------------------------
int __fastcall intToString(signed int sourceVal, char *targetText, unsigned int length)
{
  signed int v3; // r6@1
  unsigned int v4; // r4@1
  char *v5; // r7@1
  signed int v6; // r5@1
  char *v7; // r4@3
  int result; // r0@4
  char v9; // r1@4

  v3 = 0;
  v4 = length;
  v5 = targetText;
  v6 = sourceVal;
  if ( sourceVal < 0 )
  {
    v6 = -sourceVal;
    v3 = 1;
  }
  setupDMA(targetText, length, 0x20u);
  v7 = &v5[v4 - 1];
  do
  {
    result = div_(v6, 0xAu);
    *v7-- = v9 + 48;
    v6 = result;
  }
  while ( result );
  if ( v3 )
  {
    result = 45;
    *v7 = 45;
  }
  return result;
}

//----- (0000A2E4) --------------------------------------------------------
int __fastcall printNumberAsStringAt(signed int a1, char *a2, unsigned int a3)
{
  signed int v3; // r6@1
  unsigned int v4; // r4@1
  char *v5; // r7@1
  signed int v6; // r5@1
  char *v7; // r4@3
  int result; // r0@4
  char v9; // r1@4

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a1 < 0 )
  {
    v6 = -a1;
    v3 = 1;
  }
  setupDMA(a2, a3, 0x30u);
  v7 = &v5[v4 - 1];
  do
  {
    result = div_(v6, 0xAu);
    *v7-- = v9 + 48;
    v6 = result;
  }
  while ( result );
  if ( v3 )
  {
    result = 45;
    *v7 = 45;
  }
  return result;
}

//----- (0000A320) --------------------------------------------------------
char *sub_A320()
{
  char *result; // r0@1

  result = &studentMode;
  dword_20000148 = timer - 1;
  dword_2000014C = 0;
  return result;
}
// 20000144: using guessed type char studentMode;
// 20000148: using guessed type int dword_20000148;
// 2000014C: using guessed type int dword_2000014C;

//----- (0000A338) --------------------------------------------------------
signed int someSPImethod()
{
  signed int result; // r0@1

  result = 0x40048100;
  v40048104 = 0xAA;
  return result;
}

//----- (0000A348) --------------------------------------------------------
int *createRadioPacket()
{
  unsigned int v0; // r0@2
  int v1; // r0@5
  int *v2; // r1@5
  signed int v3; // r2@5
  unsigned int ch_index; // r4@11
  unsigned int v5; // r6@19
  unsigned int v6; // r7@19
  __int16 *v7; // r5@19
  int v8; // r0@19
  unsigned int v9; // r1@20
  int v10; // r0@25
  unsigned int v11; // r0@25
  int v12; // r0@27
  int v13; // r1@27
  int v14; // r0@32
  int v15; // r0@38
  int v16; // r0@41
  int v17; // r0@48
  int v18; // r0@55
  int v19; // r0@57
  int *tmpCH_1; // r0@59
  int *tmpCH2; // r0@63
  int *tmpCH3; // r0@67
  int *tmpCH4; // r0@71
  int *tmpCH5; // r0@75
  int *tmpCH6; // r0@80
  int ch_index2; // r5@86
  int v27; // r0@90
  int v28; // r7@90
  int chValue; // r0@90
  int v30; // r0@92
  unsigned int v31; // r2@92
  unsigned int v32; // r0@92
  int v33; // r12@92
  unsigned int v34; // r0@99
  int v35; // r0@102
  unsigned int v36; // r0@103
  int v37; // r0@105
  int v38; // r7@112
  int v39; // r6@112
  int v40; // r0@112
  int v41; // r1@112
  int v42; // r2@114
  int v43; // r1@114
  int v44; // r0@117
  signed int v45; // r3@120
  int modelPtr3; // r5@123
  unsigned int modelPtrPlus9; // r6@123
  int v48; // r1@126
  int v49; // r0@126
  int v50; // r1@127
  int v51; // r2@127
  int v52; // r0@130
  int v53; // r0@132
  int indexFrom0To3; // r6@133
  int v55; // r4@134
  unsigned int v56; // r3@134
  unsigned int v57; // r0@135
  int v58; // r1@136
  unsigned int v59; // r7@138
  int v60; // r0@139
  unsigned int v61; // r0@146
  int v62; // r5@149
  int v63; // r0@149
  int v64; // r5@151
  int v65; // r0@151
  unsigned int ch_index3; // r4@153
  int modelNamePtr; // r7@153
  int offset; // r6@154
  int value; // r0@154
  int v70; // r0@159
  signed int ch6_tmp; // r0@164
  signed int ch1_tmp; // r2@165
  unsigned int v73; // r0@167
  signed int ch6_tmp2; // r1@170
  signed int ch1_tmp2; // r3@171
  signed int ch2_tmp; // r3@173
  signed int ch3_tmp; // r3@177
  signed int ch4_tmp; // r3@181
  signed int ch5_tmp; // r3@185
  int modelSetPTR; // r5@193
  int v81; // r0@193
  int v82; // r0@193
  int v83; // r0@193
  int *result; // r0@193
  int ch1_val; // [sp+0h] [bp-A0h]@133
  int ch2_val; // [sp+4h] [bp-9Ch]@133
  int ch3_val; // [sp+8h] [bp-98h]@133
  int ch4_val; // [sp+Ch] [bp-94h]@133
  int *ch5_val; // [sp+10h] [bp-90h]@133
  int ch6_val; // [sp+14h] [bp-8Ch]@5
  int ch_1; // [sp+18h] [bp-88h]@15
  int ch_2; // [sp+1Ch] [bp-84h]@55
  int *ch_3; // [sp+20h] [bp-80h]@55
  int ch_4; // [sp+24h] [bp-7Ch]@55
  int *ch_5; // [sp+28h] [bp-78h]@75
  int ch_6; // [sp+2Ch] [bp-74h]@79
  int modelPtrPlus32; // [sp+34h] [bp-6Ch]@25
  int v98; // [sp+3Ch] [bp-64h]@19
  int modelNamePlus64; // [sp+44h] [bp-5Ch]@11
  int v100; // [sp+48h] [bp-58h]@55
  int v101; // [sp+4Ch] [bp-54h]@57
  int *v102; // [sp+50h] [bp-50h]@57
  int v103; // [sp+54h] [bp-4Ch]@57
  int v104; // [sp+58h] [bp-48h]@11
  int pointerSettings; // [sp+5Ch] [bp-44h]@11
  unsigned int v106; // [sp+64h] [bp-3Ch]@92
  int v107; // [sp+68h] [bp-38h]@11
  int studentMod1; // [sp+6Ch] [bp-34h]@11
  int pointeSettingsAfterName; // [sp+70h] [bp-30h]@11
  int v110; // [sp+74h] [bp-2Ch]@11
  int trainerSW_1; // [sp+78h] [bp-28h]@11
  int trainerMod; // [sp+7Ch] [bp-24h]@11
  int studentMod2; // [sp+84h] [bp-1Ch]@11

  if ( byte_20000145[0] )
  {
    v0 = timer - dword_20000150;
    if ( timer - dword_20000150 >= 0x2EE0 )
    {
      dword_20000150 += 12000;
      v0 -= 12000;
    }
    if ( v0 > (unsigned int)&byte_BB8 )
    {
      if ( v0 > (unsigned int)&off_2328 )
        v0 -= 12000;
      else
        v0 = (unsigned int)&byte_1426[-v0 + 842];
    }
    v1 = div_(10 * v0, 3u);
    v2 = &ch6_val;
    v3 = 3;
    do
    {
      v2[1] = v1;
      v2 += 2;
      *v2 = v1;
      --v3;
    }
    while ( v3 );
    goto LABEL_152;
  }
  modelNamePlus64 = getInputStates();
  studentMod1 = (unsigned __int8)studentMode;
  studentMod2 = (unsigned __int8)studentMode;
  trainerMod = (unsigned __int8)trainerMode;
  ch_index = 0;
  trainerSW_1 = (1 << trainerSW) & modelNamePlus64;
  v104 = (unsigned __int8)stickModeSW;
  v110 = 4 * (unsigned __int8)stickModeSW;
  v107 = v110 + 56609;
  pointerSettings = usedModelPtr;
  pointeSettingsAfterName = usedModelPtr + 10;
  do
  {
    if ( !studentMod2 && trainerMod && trainerSW_1 )
    {
      *(&ch_1 + ch_index) = dword_1FFFFCC0[ch_index];
      goto LABEL_16;
    }
    v5 = ch_index;
    v6 = *(&ch1_ADC_VAL + ch_index);
    v7 = &stickAdjustData[3 * ch_index];
    v8 = (*((_BYTE *)v7 + 1) << 8) | *(_BYTE *)v7;
    v98 = v8;
    if ( v6 >= v8 )
    {
      v9 = (HIBYTE(stickAdjustData[3 * ch_index + 2]) << 8) | LOBYTE(stickAdjustData[3 * ch_index + 2]);
      if ( v6 <= v9 )
      {
        if ( ch_index && ch_index != 1 && ch_index != 3 )
          goto LABEL_39;
        v10 = (HIBYTE(stickAdjustData[3 * ch_index + 1]) << 8) | LOBYTE(stickAdjustData[3 * ch_index + 1]);
        modelPtrPlus32 = v10;
        v11 = v10 - 80;
        if ( v6 > v11 && v6 < modelPtrPlus32 + 80 )
        {
          v12 = modelPtrPlus32 - ((unsigned int)modelPtrPlus32 >> 3);
          v13 = v6 >> 3;
LABEL_33:
          v8 = v12 + v13;
          goto LABEL_40;
        }
        if ( ch_index && ch_index != 1 && ch_index != 3 )
          goto LABEL_39;
        if ( v6 >= modelPtrPlus32 + 80 )
        {
          div_Other((v6 - modelPtrPlus32 - 80) * (v9 - modelPtrPlus32 - 10), v9 - modelPtrPlus32 - 80);
          v13 = modelPtrPlus32;
          v12 = v14 + 10;
          goto LABEL_33;
        }
        if ( ch_index && ch_index != 1 && ch_index != 3 || v6 > v11 )
        {
LABEL_39:
          v8 = v6;
          goto LABEL_40;
        }
        div_Other((modelPtrPlus32 - v6 - 80) * (modelPtrPlus32 - v98 - 10), modelPtrPlus32 - v98 - 80);
        v8 = modelPtrPlus32 - v15 - 10;
      }
      else
      {
        v8 = (HIBYTE(stickAdjustData[3 * ch_index + 2]) << 8) | LOBYTE(stickAdjustData[3 * ch_index + 2]);
      }
    }
LABEL_40:
    if ( ((HIBYTE(stickAdjustData[3 * ch_index + 1]) << 8) | LOBYTE(stickAdjustData[3 * ch_index + 1])) <= v8 )
      v16 = div_(
              (v8 - ((*((_BYTE *)v7 + 3) << 8) | *((_BYTE *)v7 + 2))) * (_DWORD)dword_2710,
              ((*((_BYTE *)v7 + 5) << 8) | *((_BYTE *)v7 + 4)) - ((*((_BYTE *)v7 + 3) << 8) | *((_BYTE *)v7 + 2)));
    else
      v16 = div_((v8 - v98) * (_DWORD)dword_2710, ((*((_BYTE *)v7 + 3) << 8) | *((_BYTE *)v7 + 2)) - v98) + 4294957296;
    if ( ch_index < 4 )
    {
      if ( v104 == 1 || v104 == 3 )
        v16 += 20 * *(_BYTE *)(*(_BYTE *)(v107 + ch_index) + pointeSettingsAfterName);
      else
        v16 -= 20 * *(_BYTE *)(*(_BYTE *)(v107 + ch_index) + pointeSettingsAfterName);
    }
    *(int *)((char *)&ch_1 + v5 * 4) = v16;
    v17 = v6 - byte_1FFFFD54[v5];
    if ( v17 < 0 )
      v17 = -v17;
    if ( v17 > 300 )
    {
      byte_1FFFFD54[v5] = v6;
      dword_20000148 = timer - 1;
      dword_2000014C = 0;
    }
LABEL_16:
    ++ch_index;
  }
  while ( ch_index < 6 );
  if ( studentMod1 || !trainerMod || !trainerSW_1 )
  {
    v18 = v110 + 56593;
    *(&v100 + *(_BYTE *)(v110 + 56593)) = ch_1;
    *(&v100 + *(_BYTE *)(v18 + 1)) = ch_2;
    *(&v100 + *(_BYTE *)(v18 + 2)) = (int)ch_3;
    *(&v100 + *(_BYTE *)(v18 + 3)) = ch_4;
    if ( v104 == 1 || v104 == 3 )
    {
      ch_1 = v100;
      ch_2 = v101;
      ch_3 = v102;
      v19 = v103;
    }
    else
    {
      ch_1 = -v100;
      ch_2 = -v101;
      ch_3 = (int *)-(signed int)v102;
      v19 = -v103;
    }
    ch_4 = v19;
  }
  tmpCH_1 = (int *)ch_1;
  if ( ch_1 <= -10000 )
    tmpCH_1 = (int *)-10000;
  ch_1 = (int)tmpCH_1;
  if ( (signed int)tmpCH_1 > (signed int)dword_2710 )
    tmpCH_1 = dword_2710;
  ch_1 = (int)tmpCH_1;
  dword_1FFFFD7C[2] = tmpCH_1;
  tmpCH2 = (int *)ch_2;
  if ( ch_2 <= -10000 )
    tmpCH2 = (int *)-10000;
  ch_2 = (int)tmpCH2;
  if ( (signed int)tmpCH2 > (signed int)dword_2710 )
    tmpCH2 = dword_2710;
  ch_2 = (int)tmpCH2;
  dword_1FFFFD7C[3] = tmpCH2;
  tmpCH3 = ch_3;
  if ( (signed int)ch_3 <= -10000 )
    tmpCH3 = (int *)-10000;
  ch_3 = tmpCH3;
  if ( (signed int)tmpCH3 > (signed int)dword_2710 )
    tmpCH3 = dword_2710;
  ch_3 = tmpCH3;
  dword_1FFFFD7C[4] = tmpCH3;
  tmpCH4 = (int *)ch_4;
  if ( ch_4 <= -10000 )
    tmpCH4 = (int *)-10000;
  ch_4 = (int)tmpCH4;
  if ( (signed int)tmpCH4 > (signed int)dword_2710 )
    tmpCH4 = dword_2710;
  ch_4 = (int)tmpCH4;
  dword_1FFFFD7C[5] = tmpCH4;
  tmpCH5 = ch_5;
  if ( (signed int)ch_5 <= -10000 )
    tmpCH5 = (int *)-10000;
  ch_5 = tmpCH5;
  if ( (signed int)tmpCH5 > (signed int)dword_2710 )
    tmpCH5 = dword_2710;
  ch_5 = tmpCH5;
  dword_1FFFFD7C[6] = tmpCH5;
  if ( ch_6 <= -10000 )
    tmpCH6 = (int *)-10000;
  else
    tmpCH6 = (int *)ch_6;
  ch_6 = (int)tmpCH6;
  if ( (signed int)tmpCH6 > (signed int)dword_2710 )
    tmpCH6 = dword_2710;
  ch_6 = (int)tmpCH6;
  dword_1FFFFD7C[7] = tmpCH6;
  if ( studentMod1 )
    goto LABEL_164;
  ch_index2 = 0;
LABEL_90:
  v27 = 4 * (((1 << *(_BYTE *)(pointerSettings + 14)) & modelNamePlus64) != 0) + pointerSettings + ch_index2;
  trainerMod = v27;
  v28 = 98 * *(_BYTE *)(v27 + 23) + 0x4000;
  trainerSW_1 = 4 * ch_index2;
  chValue = *(&ch_1 + ch_index2);
  studentMod1 = chValue;
  if ( chValue < 0 )
    chValue = -chValue;
  v30 = div_(chValue << 15, (unsigned int)dword_2710);
  v31 = 0x10000;
  v106 = v30;
  v32 = 0;
  v33 = 0x8000 - v28;
  v104 = v28 << 15;
  do
  {
    if ( (((v104 + v33 * ((v32 + v31) >> 1) - v28 * ((v32 + v31) >> 1)) >> 15) * ((v32 + v31) >> 1)
        + v28 * ((v32 + v31) >> 1)
        + 0x4000) >> 15 >= v106 )
      v31 = (v32 + v31) >> 1;
    else
      v32 = (v32 + v31) >> 1;
  }
  while ( v31 - v32 > 1 );
  if ( v106 - ((((v104 + v33 * v32 - v28 * v32) >> 15) * v32 + v28 * v32 + 0x4000) >> 15) > ((((v104
                                                                                              + v33 * v31
                                                                                              - v28 * v31) >> 15)
                                                                                            * v31
                                                                                            + v28 * v31
                                                                                            + 0x4000) >> 15)
                                                                                          - v106 )
    v32 = v31;
  v34 = 100
      * ((((((0x8000 - v28) << 15) + v28 * v32 - (0x8000 - v28) * v32) >> 15) * v32 + (0x8000 - v28) * v32 + 0x4000) >> 15);
  v35 = v34 * *(_BYTE *)(trainerMod + 15);
  if ( v35 >= 0 )
    v36 = v35 + 0x4000;
  else
    v36 = v35 - 0x4000;
  v37 = div_(v36, 0x8000u);
  if ( studentMod1 < 0 )
    v37 = -v37;
  *(int *)((char *)&ch_1 + trainerSW_1) = v37;
  while ( (unsigned int)++ch_index2 < 6 )
  {
    if ( !ch_index2 || ch_index2 == 1 || ch_index2 == 3 )
      goto LABEL_90;
  }
  if ( (unsigned int)*(_BYTE *)(pointerSettings + 9) >= 2 )
    ch_6 = sub_237C((int)ch_3, pointerSettings + 31);
  if ( (unsigned int)*(_BYTE *)(usedModelPtr + 9) >= 3 )
  {
    v38 = div__0(ch_1 * *(_BYTE *)(usedModelPtr + 41), 100);
    v39 = div__0(ch_2 * *(_BYTE *)(usedModelPtr + 42), 100);
    v40 = div__0(ch_6 * *(_BYTE *)(usedModelPtr + 43), 100);
    v41 = *(_BYTE *)(usedModelPtr + 9);
    if ( v41 == 3 )
    {
      ch_1 = v40 - v38;
      v48 = v40 + v39;
      v49 = v40 + v38;
      ch_2 = v48;
    }
    else
    {
      if ( v41 != 4 )
      {
        v42 = v40 - (50203 * v39 >> 15);
        v43 = v38 * (signed int)&dword_DD3C[30] >> 15;
        ch_2 = v40 + v39;
        ch_1 = v42 - v43;
        ch_6 = v42 + v43;
        goto LABEL_115;
      }
      v50 = v40 - v39 / 2;
      v51 = 28378 * v38 >> 15;
      ch_2 = v40 + v39;
      ch_1 = v50 - v51;
      v49 = v50 + v51;
    }
    ch_6 = v49;
  }
LABEL_115:
  if ( *(_BYTE *)(usedModelPtr + 55) << 31 && (1 << *(_BYTE *)(usedModelPtr + 56)) & modelNamePlus64 )
    v44 = 200 * (*(_BYTE *)(usedModelPtr + 57) - 50);
  else
    v44 = sub_237C((int)ch_3, usedModelPtr + 45);
  ch_3 = (int *)v44;
  if ( *(_BYTE *)(usedModelPtr + 9) && *(_BYTE *)(usedModelPtr + 55) & 8 )
  {
    v45 = 0;
    if ( (1 << *(_BYTE *)(usedModelPtr + 44)) & modelNamePlus64 )
      v45 = 1;
    ch_5 = (int *)(200 * (*(_BYTE *)(usedModelPtr + v45 + 58) - 50));
  }
  getInputStates();
  modelPtr3 = usedModelPtr;
  modelPtrPlus9 = *(_BYTE *)(usedModelPtr + 9);
  if ( !*(_BYTE *)(usedModelPtr + 9) || !(*(_BYTE *)(usedModelPtr + 55) & 8) )
  {
    createPacketsForCH7_10(*(_BYTE *)(usedModelPtr + 60));
    dword_1FFFFD7C[6] = v52;
    ch_5 = (int *)v52;
  }
  if ( modelPtrPlus9 < 3 )
  {
    createPacketsForCH7_10(*(_BYTE *)(modelPtr3 + 61));
    dword_1FFFFD7C[7] = v53;
    ch_6 = v53;
  }
  modelPtrPlus32 = modelPtr3 + 32;
  ch1_val = ch_1;
  ch2_val = ch_2;
  ch3_val = (int)ch_3;
  ch4_val = ch_4;
  indexFrom0To3 = 0;
  ch6_val = ch_6;
  ch5_val = ch_5;
  while ( 2 )
  {
    v55 = 4 * indexFrom0To3 + modelPtr3;
    v56 = *(_BYTE *)(v55 + 62);
    if ( !(v56 >> 7) )
      goto LABEL_142;
    v57 = v56 & 0xF;
    if ( v57 >= 6 )
      v58 = dword_1FFFFD7C[v57];
    else
      v58 = *(&ch1_val + v57);
    v59 = (unsigned int)*(_BYTE *)(v55 + 62) << 25 >> 29;
    if ( v58 < 0 )
    {
      v60 = *(_BYTE *)(v55 + 64) * v58;
      if ( v60 >= 0 )
        goto LABEL_147;
      goto LABEL_146;
    }
    v60 = *(_BYTE *)(4 * indexFrom0To3 + modelPtr3 + 63) * v58;
    if ( v60 < 0 )
    {
LABEL_146:
      v61 = v60 - 50;
      goto LABEL_141;
    }
LABEL_147:
    v61 = v60 + 50;
LABEL_141:
    *(&ch_1 + (v56 << 25 >> 29)) += div_(v61, 0x64u);
    *(&ch_1 + v59) += 200 * *(_BYTE *)(v55 + 65);
LABEL_142:
    if ( (unsigned int)++indexFrom0To3 < 3 )
      continue;
    break;
  }
  if ( !*(_BYTE *)(modelPtr3 + 9) )
  {
    if ( !(*(_BYTE *)(modelPtrPlus32 + 23) & 4)
      || (v62 = div__0(ch_2 * *(_BYTE *)(modelPtr3 + 75) + ch_1 * *(_BYTE *)(modelPtr3 + 74), 100),
          v63 = div__0(ch_2 * *(_BYTE *)(usedModelPtr + 75) - ch_1 * *(_BYTE *)(usedModelPtr + 74), 100),
          ch_1 = v62,
          ch_2 = v63,
          !*(_BYTE *)(usedModelPtr + 9)) )
    {
      if ( *(_BYTE *)(usedModelPtr + 55) & 2 )
      {
        v64 = div__0(ch_2 * *(_BYTE *)(usedModelPtr + 75) - ch_4 * *(_BYTE *)(usedModelPtr + 74), 100);
        v65 = div__0(ch_2 * *(_BYTE *)(usedModelPtr + 75) + ch_4 * *(_BYTE *)(usedModelPtr + 74), 100);
        ch_2 = v64;
        ch_4 = v65;
      }
    }
  }
LABEL_152:
  if ( !studentMode )
  {
    ch_index3 = 0;
    modelNamePtr = usedModelPtr;
    modelNamePlus64 = usedModelPtr + 64;
    do
    {
      offset = 4 * ch_index3;
      value = *(&ch_1 + ch_index3) + 20 * *(_BYTE *)(modelNamePtr + ch_index3 + 76);
      *(&ch_1 + ch_index3) = value;
      if ( value <= 4294957296 )
        value = 4294957296;
      *(int *)((char *)&ch_1 + offset) = value;
      if ( value > (signed int)dword_2710 )
        value = (int)dword_2710;
      *(int *)((char *)&ch_1 + offset) = value;
      if ( value >= 0 )
      {
        v70 = value * *(_BYTE *)(2 * ch_index3 + modelNamePtr + 83);
        if ( v70 >= 0 )
        {
LABEL_168:
          v73 = v70 + 50;
          goto LABEL_161;
        }
      }
      else
      {
        v70 = value * *(_BYTE *)(2 * ch_index3 + modelNamePtr + 82);
        if ( v70 >= 0 )
          goto LABEL_168;
      }
      v73 = v70 - 50;
LABEL_161:
      *(int *)((char *)&ch_1 + offset) = div_(v73, 0x64u);
      if ( *(_BYTE *)(modelNamePlus64 + 30) & (1 << ch_index3) )
        *(int *)((char *)&ch_1 + offset) = -*(int *)((char *)&ch_1 + offset);
      ++ch_index3;
    }
    while ( ch_index3 < 6 );
  }
LABEL_164:
  ch6_tmp = 0xFFFFD120;
  if ( ch_1 <= (signed int)0xFFFFD120 )
    ch1_tmp = 0xFFFFD120;
  else
    ch1_tmp = ch_1;
  ch6_tmp2 = 0x2EE0;
  ch_1 = ch1_tmp;
  if ( ch1_tmp <= 0x2EE0 )
    ch1_tmp2 = ch1_tmp;
  else
    ch1_tmp2 = 0x2EE0;
  ch_1 = ch1_tmp2;
  dword_1FFFFDE0[0] = ch1_tmp2;
  ch2_tmp = ch_2;
  if ( ch_2 <= (signed int)0xFFFFD120 )
    ch2_tmp = 0xFFFFD120;
  ch_2 = ch2_tmp;
  if ( ch2_tmp > 0x2EE0 )
    ch2_tmp = 0x2EE0;
  ch_2 = ch2_tmp;
  dword_1FFFFDE4 = ch2_tmp;
  ch3_tmp = (signed int)ch_3;
  if ( (signed int)ch_3 <= (signed int)0xFFFFD120 )
    ch3_tmp = 0xFFFFD120;
  ch_3 = (int *)ch3_tmp;
  if ( ch3_tmp > 0x2EE0 )
    ch3_tmp = 0x2EE0;
  ch_3 = (int *)ch3_tmp;
  dword_1FFFFDE8 = ch3_tmp;
  ch4_tmp = ch_4;
  if ( ch_4 <= (signed int)0xFFFFD120 )
    ch4_tmp = 0xFFFFD120;
  ch_4 = ch4_tmp;
  if ( ch4_tmp > 0x2EE0 )
    ch4_tmp = 0x2EE0;
  ch_4 = ch4_tmp;
  dword_1FFFFDEC = ch4_tmp;
  ch5_tmp = (signed int)ch_5;
  if ( (signed int)ch_5 <= (signed int)0xFFFFD120 )
    ch5_tmp = 0xFFFFD120;
  ch_5 = (int *)ch5_tmp;
  if ( ch5_tmp > 0x2EE0 )
    ch5_tmp = 0x2EE0;
  ch_5 = (int *)ch5_tmp;
  dword_1FFFFDF0 = ch5_tmp;
  if ( ch_6 > (signed int)0xFFFFD120 )
    ch6_tmp = ch_6;
  ch_6 = ch6_tmp;
  if ( ch6_tmp <= 0x2EE0 )
    ch6_tmp2 = ch6_tmp;
  dword_1FFFFDF4 = ch6_tmp2;
  modelSetPTR = usedModelPtr;
  createPacketsForCH7_10(*(_BYTE *)(usedModelPtr + 141) & 0xF);
  dword_1FFFFDF8 = v81;
  createPacketsForCH7_10((unsigned int)*(_BYTE *)(modelSetPTR + 141) >> 4);
  dword_1FFFFDFC = v82;
  createPacketsForCH7_10(*(_BYTE *)(modelSetPTR + 145) & 0xF);
  dword_1FFFFE00 = v83;
  createPacketsForCH7_10((unsigned int)*(_BYTE *)(modelSetPTR + 145) >> 4);
  dword_1FFFFE04 = (int)result;
  return result;
}
// BB8: using guessed type char byte_BB8;
// 2328: using guessed type void *off_2328;
// 2710: using guessed type int dword_2710[28];
// DD3C: using guessed type int dword_DD3C[63];
// 1FFFFDE4: using guessed type int dword_1FFFFDE4;
// 1FFFFDE8: using guessed type int dword_1FFFFDE8;
// 1FFFFDEC: using guessed type int dword_1FFFFDEC;
// 1FFFFDF0: using guessed type int dword_1FFFFDF0;
// 1FFFFDF4: using guessed type int dword_1FFFFDF4;
// 1FFFFDF8: using guessed type int dword_1FFFFDF8;
// 1FFFFDFC: using guessed type int dword_1FFFFDFC;
// 1FFFFE00: using guessed type int dword_1FFFFE00;
// 1FFFFE04: using guessed type int dword_1FFFFE04;
// 2000002C: using guessed type int usedModelPtr;
// 20000144: using guessed type char studentMode;
// 20000148: using guessed type int dword_20000148;
// 2000014C: using guessed type int dword_2000014C;
// 20000150: using guessed type int dword_20000150;
// 200002A8: using guessed type char trainerMode;
// 200002A9: using guessed type char trainerSW;
// 200002AA: using guessed type char stickModeSW;

//----- (0000ABA0) --------------------------------------------------------
int __fastcall toSysTick(int a1)
{
  return 768 * a1;
}

//----- (0000ABA8) --------------------------------------------------------
int saveModelSettings()
{
  unsigned int v0; // r6@1
  unsigned int v1; // r7@1
  unsigned int v2; // r5@1
  unsigned int settingsIndex; // r4@1
  unsigned int spiAddress; // r0@2

  v0 = 0xFFFFFFFF;
  v1 = 0;
  v2 = 0;
  settingsIndex = 0;                            // settings indes is saying which settings should be loaded
                                                // model data
                                                // sticks config 
                                                // 
  do
  {
    spiAddress = settingRelatedValue[settingsIndex];
    if ( !settingsIndex || v0 && spiAddress >= 0x80000000 || spiAddress < v0 )
    {
      v1 = settingsIndex;
      if ( spiAddress < 0x80000000 )
        v0 = settingRelatedValue[settingsIndex];
      else
        v0 = 0;
    }
    if ( spiAddress < 0x80000000 && (!settingsIndex || spiAddress > v2) )
      v2 = settingRelatedValue[settingsIndex];
    someSPImethod();
    ++settingsIndex;
  }
  while ( settingsIndex < 4 );
  *(_DWORD *)rxsettings = v2 + 1;
  settingRelatedValue[v1] = v2 + 1;
  settingsCRC = crcCheck(rxsettings, 2930);
  return saveEepromData(rxsettings, (v1 << 12) + 64, (unsigned int)&dword_B74);// 3rd param E0430806
}
// B74: using guessed type int dword_B74;
// 20000E16: using guessed type __int16 settingsCRC;

//----- (0000AC34) --------------------------------------------------------
int SpeedDistancePage()
{
  showNavigationPage("Speed-distance", 4u, (char **)&byte_D2A0);
  return 0;
}
// D2A0: using guessed type char byte_D2A0;

//----- (0000AC58) --------------------------------------------------------
signed int SpeedSensor()
{
  unsigned int v0; // r5@1
  unsigned int v1; // r4@1
  unsigned int v2; // r6@1
  unsigned int v3; // r1@1
  unsigned int v4; // r7@7
  int v5; // r3@7
  unsigned int v6; // r5@7
  unsigned int v7; // r6@7
  int v8; // r3@9
  int v9; // r1@11
  int v10; // r1@14
  int v11; // r3@17
  int v12; // r0@20
  int v13; // r1@23
  int v14; // r1@26
  int v15; // r0@29
  int v17; // [sp+0h] [bp-1D8h]@1
  char v18[128]; // [sp+100h] [bp-D8h]@9
  char v19; // [sp+180h] [bp-58h]@7

  v0 = 0;
  v1 = 0;
  sub_A158();
  v2 = activeSensors;
  strcpy(&v17, sensorsArrayInRam, 0x100u);
  sub_A190();
  v3 = 0;
  if ( v2 )
  {
    do
    {
      if ( *((_BYTE *)&v17 + 8 * v3) == 2 )
        v0 = (unsigned __int8)(v0 + 1);
      if ( *(_BYTE *)(usedModelPtr + 135) == *((_BYTE *)&v17 + 8 * v3 + 1) )
      {
        v1 = v0;
        goto LABEL_7;
      }
      ++v3;
    }
    while ( v3 < v2 );
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_7:
        callSetupDMAandSend();
        displayPageHeader("Speed sensor");
        sub_A158();
        v4 = activeSensors;
        strcpy(&v17, sensorsArrayInRam, 256u);
        sub_A190();
        sprintf((int)&v19, "%s", v5);
        v6 = 1;
        v7 = 0;
        if ( v4 )
        {
          do
          {
            if ( *((_BYTE *)&v17 + 8 * v7) == 2 )
            {
              v8 = *((_BYTE *)&v17 + 8 * v7 + 1);
              *(_DWORD *)&v18[4 * v6] = v8;
              sprintf((int)(&v19 + 16 * v6++), "%s %u", v8 + 1);
            }
            ++v7;
          }
          while ( v7 < v4 );
        }
        v9 = *(_BYTE *)(usedModelPtr + 129);
        if ( v9 == 124 || v9 == 125 || v9 == 126 )
        {
          v10 = *(_BYTE *)(usedModelPtr + 135);
          if ( v10 == 255 )
            *(_BYTE *)(usedModelPtr + 129) = -1;
          else
            *(_BYTE *)(usedModelPtr + 130) = v10;
        }
        v11 = *(_BYTE *)(usedModelPtr + 131);
        if ( v11 == 124 || v11 == 125 || v11 == 126 )
        {
          v12 = *(_BYTE *)(usedModelPtr + 135);
          if ( v12 == 255 )
            *(_BYTE *)(usedModelPtr + 131) = -1;
          else
            *(_BYTE *)(usedModelPtr + 132) = v12;
        }
        v13 = *(_BYTE *)(usedModelPtr + 133);
        if ( v13 == 124 || v13 == 125 || v13 == 126 )
        {
          v14 = *(_BYTE *)(usedModelPtr + 135);
          if ( v14 == 255 )
            *(_BYTE *)(usedModelPtr + 133) = -1;
          else
            *(_BYTE *)(usedModelPtr + 134) = v14;
        }
        displayTextAt2(&v19 + 16 * v1, 64, 24, 0);
        LCD_updateCALL();
        v15 = getKeyCode();
        if ( v15 != 9 && v15 != 23 )
          break;
        if ( v1 < v6 - 1 )
          ++v1;
        if ( (unsigned int)sub_9BC0() >= 2 )
        {
LABEL_45:
          beep(784, 15);
          beep(0, 15);
        }
      }
      if ( v15 != 8 && v15 != 24 )
        break;
      if ( v1 )
        --v1;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_45;
    }
    if ( v15 == 25 || v15 == 10 )
      break;
    if ( v15 == 11 )
      return 0;
  }
  if ( v1 >= v6 )
  {
    if ( !v1 )
      *(_BYTE *)(usedModelPtr + 135) = -1;
  }
  else
  {
    *(_BYTE *)(usedModelPtr + 135) = v18[4 * v1];
  }
  return 1;
}
// 20000024: using guessed type int activeSensors;
// 2000002C: using guessed type int usedModelPtr;
// AC58: using guessed type char var_D8[128];

//----- (0000AE44) --------------------------------------------------------
signed int SticksAdjustPage()
{
  int v0; // r0@2
  unsigned int v1; // r5@5
  int v2; // r0@6
  __int16 *v3; // r1@8
  int v4; // r0@28
  int v6; // r5@31
  __int16 *v7; // r0@32

  callSetupDMAandSend();
  displayPageHeader("Sticks adjust");
  displayTextAt2("Place all sticks", 64, 24, 0);
  displayTextAt2("in their middle", 64, 32, 0);
  displayTextAt2("position and", 64, 40, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  LCD_updateCALL();
  while ( 1 )
  {
    v0 = getKeyCode();
    if ( v0 == 11 )
      return 0;
    if ( v0 == 25 || v0 == 10 )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = *(&ch1_ADC_VAL + v1);
        if ( v2 - 1536 >= (unsigned int)&unk_401 )
          break;
        v3 = &stickAdjustData[3 * v1];
        *v3 = v2;
        v3[1] = v2;
        ++v1;
        v3[2] = v2;
        if ( v1 >= 4 )
          goto LABEL_9;
      }
      beep(523, 100);
      beep(370, 250);
LABEL_9:
      if ( v1 == 4 )
        break;
    }
  }
  beep(1047, 100);
  fillRegion(0, 16, 127, 63, 1);
  displayTextAt2("Move all sticks", 64, 24, 0);
  displayTextAt2("to their extreme", 64, 32, 0);
  displayTextAt2("positions and", 64, 40, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  LCD_updateCALL();
  do
  {
    while ( 1 )
    {
      do
      {
        if ( ch1_ADC_VAL < (unsigned int)(unsigned __int16)stickAdjustData[0] )
          stickAdjustData[0] = ch1_ADC_VAL;
        if ( ch1_ADC_VAL > (unsigned int)(unsigned __int16)stickAdjustData[2] )
          stickAdjustData[2] = ch1_ADC_VAL;
        if ( ch2_ADC_VAL < (unsigned int)(unsigned __int16)stickAdjustData[3] )
          stickAdjustData[3] = ch2_ADC_VAL;
        if ( ch2_ADC_VAL > (unsigned int)(unsigned __int16)stickAdjustData[5] )
          stickAdjustData[5] = ch2_ADC_VAL;
        if ( ch3_ADC_VAL < (unsigned int)(unsigned __int16)stickAdjustData[6] )
          stickAdjustData[6] = ch3_ADC_VAL;
        if ( ch3_ADC_VAL > (unsigned int)(unsigned __int16)stickAdjustData[8] )
          stickAdjustData[8] = ch3_ADC_VAL;
        if ( ch4_ADC_VAL < (unsigned int)(unsigned __int16)stickAdjustData[9] )
          stickAdjustData[9] = ch4_ADC_VAL;
        if ( ch4_ADC_VAL > (unsigned int)(unsigned __int16)stickAdjustData[11] )
          stickAdjustData[11] = ch4_ADC_VAL;
      }
      while ( sub_2574() == 255 );
      v4 = getKeyCode();
      if ( v4 == 10 )
        break;
      if ( v4 == 11 )
        return 0;
    }
    v6 = 0;
    while ( 1 )
    {
      v7 = &stickAdjustData[3 * v6];
      if ( (unsigned __int16)*v7 > 0x400u || (unsigned __int16)v7[2] < 0xC00u )
        break;
      if ( (unsigned int)++v6 >= 4 )
        goto LABEL_36;
    }
    beep(523, 100);
    beep(370, 250);
LABEL_36:
    ;
  }
  while ( v6 != 4 );
  return 1;
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// 10: using guessed type int dword_10;
// 14: using guessed type int dword_14;
// 20000F04: using guessed type int ch2_ADC_VAL;
// 20000F08: using guessed type int ch3_ADC_VAL;
// 20000F0C: using guessed type int ch4_ADC_VAL;

//----- (0000AFF8) --------------------------------------------------------
signed int SticksMode()
{
  __int16 *v0; // r4@2
  char *v1; // r0@6
  int v2; // r0@8
  unsigned int v4; // r0@19
  char v5; // [sp+0h] [bp-18h]@4

  if ( factoryMode )
    v0 = &stickAdjustData[18];
  else
    v0 = (__int16 *)&stickModeSW;
  v5 = *(_BYTE *)v0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        v1 = factoryMode ? "Def sticks mode" : 0xCFED;
        displayPageHeader(v1);
        displayGFX((int)&unk_CC34, 28, 32);
        displayGFX((int)&unk_CC34, 92, 32);
        aMode1[5] = *(_BYTE *)v0 + 49;
        byte_20000007 = BYTE1(dword_D20C[*(_BYTE *)v0 + 10]) + 49;
        displayTextAt(&byte_20000005, 68, 44, 0);
        byte_20000007 = BYTE2(dword_D20C[*(_BYTE *)v0 + 10]) + 49;
        displayTextAt(&byte_20000005, 96, 24, 0);
        byte_20000007 = BYTE3(dword_D20C[*(_BYTE *)v0 + 10]) + 49;
        displayTextAt(&byte_20000005, 32, 24, 0);
        byte_20000007 = LOBYTE(dword_D20C[*(_BYTE *)v0 + 11]) + 49;
        displayTextAt(&byte_20000005, 4, 44, 0);
        displayTextAt(aMode1, 0, 12, 0);
        LCD_updateCALL();
        v2 = getKeyCode();
        if ( v2 != 8 && v2 != 24 )
          break;
        if ( *(_BYTE *)v0 )
        {
          --*(_BYTE *)v0;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_18:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v2 != 9 && v2 != 23 )
        break;
      v4 = *(_BYTE *)v0;
      if ( v4 < 3 )
      {
        *(_BYTE *)v0 = v4 + 1;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_18;
      }
    }
    if ( v2 == 10 || v2 == 25 )
      break;
    if ( v2 == 11 )
    {
      *(_BYTE *)v0 = v5;
      return 0;
    }
  }
  if ( factoryMode )
  {
    stickModeSW = stickAdjustData[18];
    saveModelSettings();
  }
  return 1;
}
// D20C: using guessed type int dword_D20C[15];
// 20000001: using guessed type char factoryMode;
// 20000005: using guessed type char byte_20000005;
// 20000007: using guessed type char byte_20000007;
// 200002AA: using guessed type char stickModeSW;

//----- (0000B154) --------------------------------------------------------
signed int StudentModePage()
{
  signed int v0; // r2@2
  const char *v1; // r0@2
  int v2; // r0@4
  signed int result; // r0@7

  callSetupDMAandSend();
  displayPageHeader("Student mode");
  if ( studentMode )
  {
    displayTextAt2("This will cancel", 64, 24, 0);
    v0 = 32;
    v1 = "student mode";
  }
  else
  {
    displayTextAt2("This will enter", 64, 15, 0);
    displayTextAt2("student mode", 64, 23, 0);
    displayTextAt2("all settings", 64, 31, 0);
    v0 = 39;
    v1 = "will be bypassed";
  }
  displayTextAt2(v1, 64, v0, 0);
  displayTextAt2("Press \"OK\"", 64, 48, 0);
  displayTextAt2("to proceed", 64, 56, 0);
  LCD_updateCALL();
  do
  {
    v2 = getKeyCode();
    if ( v2 == 11 )
      return 0;
  }
  while ( v2 != 10 );
  if ( studentMode )
  {
    studentMode = 0;
    result = 1;
  }
  else
  {
    result = sub_23F4();
    if ( result )
    {
      result = 1;
      studentMode = 1;
    }
  }
  return result;
}
// 20000144: using guessed type char studentMode;

//----- (0000B220) --------------------------------------------------------
signed int SubtrimPage()
{
  unsigned int v0; // r6@2
  int v1; // r5@3
  int v2; // r0@3
  int v3; // r0@4
  signed int v5; // r0@13
  signed int v6; // r1@17
  unsigned int v7; // r0@23
  _BYTE text[4]; // [sp+4h] [bp-2Ch]@2
  int v9; // [sp+8h] [bp-28h]@2
  unsigned int v10; // [sp+Ch] [bp-24h]@1
  int v11; // [sp+10h] [bp-20h]@3
  int v12; // [sp+14h] [bp-1Ch]@3

  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v9 = 0;
            *(_DWORD *)text = 3237955;
            callSetupDMAandSend();
            displayPageHeader("Subtrim");
            v0 = 0;
            do
            {
              text[2] = v0 + 49;
              v1 = 8 * v0;
              v11 = 8 * v0 + 16;
              displayTextAt(text, 8, v11, 0);
              v12 = 8 * v0 + 18;
              sub_4E8C(35, v1 + 18, 35, v1 + 22, 0);
              sub_4E8C(80, v1 + 20, 80, v1 + 22, 0);
              sub_4E8C(125, v12, 125, 8 * v0 + 22, 0);
              sub_4E8C(35, v1 + 22, 125, v1 + 22, 0);
              v2 = div__0(42 * *(_BYTE *)(usedModelPtr + v0 + 76), 120);
              displayGFX((int)&unk_CC10, v2 + 78, v11);
              ++v0;
            }
            while ( v0 < 6 );
            displayGFX((int)&arrow_gfx, 0, 8 * v10 + 16);
            LCD_updateCALL();
            v3 = getKeyCode();
            if ( v3 != 24 && v3 != 8 )
              break;
            v5 = *(_BYTE *)(usedModelPtr + v10 + 76);
            if ( v5 > -120 )
            {
              *(_BYTE *)(usedModelPtr + v10 + 76) = v5 - 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_15;
            }
          }
          if ( v3 != 23 && v3 != 9 )
            break;
          v6 = *(_BYTE *)(usedModelPtr + v10 + 76);
          if ( v6 < 120 )
          {
            *(_BYTE *)(usedModelPtr + v10 + 76) = v6 + 1;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_15;
          }
        }
        if ( v3 != 22 )
          break;
        *(_BYTE *)(usedModelPtr + v10 + 76) = 0;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_15;
      }
      if ( v3 != 10 )
        break;
      if ( v10 < 5 )
        v7 = (unsigned __int8)(v10 + 1);
      else
        v7 = 0;
      v10 = v7;
      if ( (unsigned int)sub_9BC0() >= 2 )
      {
LABEL_15:
        beep(784, 15);
        beep(0, 15);
      }
    }
    if ( v3 == 25 )
      return 1;
    if ( v3 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (0000B3A0) --------------------------------------------------------
signed int SwitchesAssigPage()
{
  unsigned int v0; // r6@1
  int v1; // r7@2
  char *v2; // r0@4
  char *v3; // r0@6
  char *v4; // r0@8
  int v5; // r1@14
  const char *v6; // r0@14
  int v7; // r0@17
  int v9; // r1@33
  unsigned int v10; // r0@33
  int v11; // r0@34
  char v12; // cf@36
  int v13; // r0@40
  unsigned int v14; // r1@40
  int v15; // r1@41
  int v16; // r1@45
  unsigned int v17; // r0@45
  int v18; // r0@46
  int v19; // r1@56
  unsigned int v20; // r0@56
  int v21; // r0@57
  int v22; // r0@63
  unsigned int v23; // r1@63
  int v24; // r1@64
  int v25; // r0@68
  unsigned int v26; // r1@68
  int v27; // r1@69
  unsigned int v28; // r0@76

  v0 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("Switches assign");
          v1 = getInputStates();
          if ( v0 > 2 )
          {
            if ( *(_BYTE *)(usedModelPtr + 95) )
            {
              displayTextAt("On", 28, 24, 0);
              v5 = 100;
              v6 = (const char *)&unk_B698;
            }
            else
            {
              displayTextAt("Off", 28, 24, 0);
              v5 = 92;
              v6 = "None";
            }
            displayTextAt(v6, v5, 16, 0);
            displayTextAt("UFO mode", 12, 16, 0);
            displayGFX((int)&arrow_gfx, 4, 16 * v0 - 32);
          }
          else
          {
            displayTextAt("Fly mode", 12, 16, 0);
            sw_X_val = *(_BYTE *)(usedModelPtr + 14) + 49;
            displayTextAt(&sw_X, 100, 16, 0);
            v2 = (1 << *(_BYTE *)(usedModelPtr + 14)) & (unsigned int)v1 ? "Sport" : 51943;
            displayTextAt(v2, 28, 24, 0);
            displayTextAt("Idle mode", 12, 32, 0);
            sw_X_val = *(_BYTE *)(usedModelPtr + 44) + 49;
            displayTextAt(&sw_X, 100, 32, 0);
            v3 = (1 << *(_BYTE *)(usedModelPtr + 44)) & (unsigned int)v1 ? "Idle up" : 51943;
            displayTextAt(v3, 28, 40, 0);
            displayTextAt("Thro. hold", 12, 48, 0);
            sw_X_val = *(_BYTE *)(usedModelPtr + 56) + 49;
            displayTextAt(&sw_X, 100, 48, 0);
            v4 = (1 << *(_BYTE *)(usedModelPtr + 56)) & v1 ? "On" : "Off";
            displayTextAt(v4, 28, 56, 0);
            displayGFX((int)&arrow_gfx, 4, 16 * v0 + 16);
          }
          LCD_updateCALL();
          v7 = getKeyCode();
          if ( v7 != 8 && v7 != 24 )
            break;
          if ( v0 )
          {
            switch ( v0 )
            {
              case 1u:
                v13 = usedModelPtr + 32;
                v14 = *(_BYTE *)(usedModelPtr + 44);
                if ( v14 > 0x10 )
                {
                  v15 = (unsigned __int8)(v14 - 1);
                  *(_BYTE *)(usedModelPtr + 44) = v15;
                  if ( v15 == 18 )
                    *(_BYTE *)(v13 + 12) = 17;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                  {
LABEL_31:
                    beep(784, 15);
                    beep(0, 15);
                  }
                }
                break;
              case 2u:
                v16 = usedModelPtr + 32;
                v17 = *(_BYTE *)(usedModelPtr + 56);
                if ( v17 > 0x10 )
                {
                  v18 = (unsigned __int8)(v17 - 1);
                  *(_BYTE *)(usedModelPtr + 56) = v18;
                  if ( v18 == 18 )
                    *(_BYTE *)(v16 + 24) = 17;
                  if ( (unsigned int)sub_9BC0() >= 2 )
                    goto LABEL_31;
                }
                break;
              case 3u:
                *(_BYTE *)(usedModelPtr + 95) ^= 1u;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_31;
                break;
            }
          }
          else
          {
            v9 = usedModelPtr;
            v10 = *(_BYTE *)(usedModelPtr + 14);
            if ( v10 > 0x10 )
            {
              v11 = (unsigned __int8)(v10 - 1);
              *(_BYTE *)(usedModelPtr + 14) = v11;
              if ( v11 == 18 )
                *(_BYTE *)(v9 + 14) = 17;
              v12 = (unsigned int)sub_9BC0() >= 2;
              goto LABEL_37;
            }
          }
        }
        if ( v7 != 9 && v7 != 23 )
          break;
        if ( v0 )
        {
          switch ( v0 )
          {
            case 1u:
              v22 = usedModelPtr + 32;
              v23 = *(_BYTE *)(usedModelPtr + 44);
              if ( v23 < 0x13 )
              {
                v24 = (unsigned __int8)(v23 + 1);
                *(_BYTE *)(usedModelPtr + 44) = v24;
                if ( v24 == 18 )
                  *(_BYTE *)(v22 + 12) = 19;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_31;
              }
              break;
            case 2u:
              v25 = usedModelPtr + 32;
              v26 = *(_BYTE *)(usedModelPtr + 56);
              if ( v26 < 0x13 )
              {
                v27 = (unsigned __int8)(v26 + 1);
                *(_BYTE *)(usedModelPtr + 56) = v27;
                if ( v27 == 18 )
                  *(_BYTE *)(v25 + 24) = 19;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_31;
              }
              break;
            case 3u:
              *(_BYTE *)(usedModelPtr + 95) ^= 1u;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_31;
              break;
          }
        }
        else
        {
          v19 = usedModelPtr;
          v20 = *(_BYTE *)(usedModelPtr + 14);
          if ( v20 < 0x13 )
          {
            v21 = (unsigned __int8)(v20 + 1);
            *(_BYTE *)(usedModelPtr + 14) = v21;
            if ( v21 == 18 )
              *(_BYTE *)(v19 + 14) = 19;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_31;
          }
        }
      }
      if ( v7 != 10 )
        break;
      if ( v0 < 2 )
        ++v0;
      else
        v0 = 0;
      v28 = sub_9BC0();
      v12 = v28 >= 2;
      if ( v28 >= 2 )
        goto LABEL_31;
LABEL_37:
      if ( v12 )
        goto LABEL_31;
    }
    if ( v7 == 25 )
      break;
    if ( v7 == 11 )
      return 0;
  }
  if ( *(_BYTE *)(usedModelPtr + 95) )
    *(_BYTE *)(usedModelPtr + 61) = 5;
  return 1;
}
// 20000009: using guessed type char sw_X;
// 2000000B: using guessed type char sw_X_val;
// 2000002C: using guessed type int usedModelPtr;

//----- (0000B6A8) --------------------------------------------------------
int TPM0_method()
{
  int result; // r0@1

  result = 0x40038000;
  if ( v4003800C & 0x80 )                       // Channel (n) Status and Control (TPM0_C0SC) if event occurs 
  {
    v4003800C |= 0x80u;
    result = methodOnTPM_Event();
  }
  return result;
}

//----- (0000B800) --------------------------------------------------------
int ThrottleCurvePage()
{
  return showSingleValuePage("Throttle curve", usedModelPtr + 45, 53670);
}
// 2000002C: using guessed type int usedModelPtr;

//----- (0000B820) --------------------------------------------------------
signed int ThrottleHoldPage()
{
  int v0; // r5@1
  _BYTE *v1; // r0@3
  char *v2; // r0@6
  int v3; // r0@7
  unsigned int v5; // r1@25

  v0 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            callSetupDMAandSend();
            displayPageHeader("Throttle hold");
            displayTextAt("Hold", 16, 24, 0);
            v1 = (_BYTE *)(*(_BYTE *)(usedModelPtr + 55) << 31 ? 51831 : "Off");
            displayTextAt(v1, 80, 24, 0);
            displayTextAt("Value", 16, 32, 0);
            intToString(*(_BYTE *)(usedModelPtr + 57), a100_0, 3u);
            displayTextAt(a100_0, 64, 32, 0);
            v2 = getInputStates() & (unsigned int)(1 << *(_BYTE *)(usedModelPtr + 56)) ? "Engaged" : 53449;
            displayTextAt2(v2, 64, 48, 0);
            displayGFX((int)&arrow_gfx, 8, 8 * v0 + 24);
            LCD_updateCALL();
            v3 = getKeyCode();
            if ( v3 != 8 && v3 != 24 )
              break;
            if ( v0 )
            {
              if ( *(_BYTE *)(usedModelPtr + 57) )
              {
                --*(_BYTE *)(usedModelPtr + 57);
                if ( (unsigned int)sub_9BC0() >= 2 )
                {
LABEL_22:
                  beep(784, 15);
                  beep(0, 15);
                }
              }
            }
            else
            {
              *(_BYTE *)(usedModelPtr + 55) ^= 1u;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_22;
            }
          }
          if ( v3 != 9 && v3 != 23 )
            break;
          if ( v0 )
          {
            v5 = *(_BYTE *)(usedModelPtr + 57);
            if ( v5 < 0x64 )
            {
              *(_BYTE *)(usedModelPtr + 57) = v5 + 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_22;
            }
          }
          else
          {
            *(_BYTE *)(usedModelPtr + 55) ^= 1u;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_22;
          }
        }
        if ( v3 != 22 )
          break;
        *(_BYTE *)(usedModelPtr + 57) = 50;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_22;
      }
      if ( v3 != 10 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_22;
    }
    if ( v3 == 25 )
      return 1;
    if ( v3 == 11 )
      return 0;
  }
}
// 2000002C: using guessed type int usedModelPtr;

//----- (0000B998) --------------------------------------------------------
signed int TrainerModePage()
{
  int v0; // r5@1
  _BYTE *v1; // r0@3
  int v2; // r1@6
  const char *v3; // r0@6
  int v4; // r0@8
  char v6; // [sp+0h] [bp-20h]@1
  char v7; // [sp+4h] [bp-1Ch]@1

  v7 = trainerMode;
  v0 = 0;
  v6 = trainerSW;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          callSetupDMAandSend();
          displayPageHeader("Trainer mode");
          displayTextAt("Mode", 24, 24, 0);
          v1 = (_BYTE *)(trainerMode ? 51831 : "Off");
          displayTextAt(v1, 80, 24, 0);
          displayTextAt("Switch", 24, 32, 0);
          sw_X_val = trainerSW + 49;
          displayTextAt(&sw_X, 80, 32, 0);
          if ( getInputStates() & (1 << trainerSW) )
          {
            v2 = 36;
            v3 = "Engaged";
          }
          else
          {
            v2 = 20;
            v3 = "Not engaged";
          }
          displayTextAt(v3, v2, 40, 0);
          displayGFX((int)&arrow_gfx, 16, 8 * v0 + 24);
          LCD_updateCALL();
          v4 = getKeyCode();
          if ( v4 != 8 && v4 != 24 )
            break;
          if ( v0 )
          {
            if ( (unsigned __int8)trainerSW > 0x10u )
            {
              --trainerSW;
              if ( (unsigned int)sub_9BC0() >= 2 )
              {
LABEL_21:
                beep(784, 15);
                beep(0, 15);
              }
            }
          }
          else
          {
            trainerMode ^= 1u;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_21;
          }
        }
        if ( v4 != 9 && v4 != 23 )
          break;
        if ( v0 )
        {
          if ( (unsigned __int8)trainerSW < 0x13u )
          {
            ++trainerSW;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_21;
          }
        }
        else
        {
          trainerMode ^= 1u;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_21;
        }
      }
      if ( v4 != 10 )
        break;
      v0 ^= 1u;
      if ( (unsigned int)sub_9BC0() >= 2 )
        goto LABEL_21;
    }
    if ( v4 == 25 )
      return 1;
    if ( v4 == 11 )
    {
      trainerMode = v7;
      trainerSW = v6;
      return 0;
    }
  }
}
// 4: using guessed type int Reset;
// 20000009: using guessed type char sw_X;
// 2000000B: using guessed type char sw_X_val;
// 200002A8: using guessed type char trainerMode;
// 200002A9: using guessed type char trainerSW;

//----- (0000BAF4) --------------------------------------------------------
signed int typeSelectPage()
{
  char *v0; // r0@2
  int v1; // r0@3
  unsigned int v3; // r0@15

  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Type select");
        printNumberAsStringAt((unsigned __int8)currentModel + 1, &aModel00[6], 2u);
        displayTextAt(aModel00, 32, 12, 0);
        displayTextAt((_BYTE *)usedModelPtr, 32, 20, 0);
        if ( *(_BYTE *)(usedModelPtr + 9) )
        {
          displayTextAt2("Helicopter", 68, 30, 0);
          v0 = &heli_img;
        }
        else
        {
          displayTextAt2("Airplane", 68, 30, 0);
          displayTextAt2("or glider", 68, 38, 0);
          v0 = &plain_img;
        }
        displayGFX((int)v0, 41, 48);
        displayTextAt2(*(_BYTE **)&aT[4 * *(_BYTE *)(usedModelPtr + 9)], 68, 38, 0);
        displayGFX((int)&arrow_gfx, 4, 30);
        displayGFX((int)&arrow_gfx, 4, 38);
        LCD_updateCALL();
        v1 = getKeyCode();
        if ( v1 != 8 && v1 != 24 )
          break;
        if ( *(_BYTE *)(usedModelPtr + 9) )
        {
          --*(_BYTE *)(usedModelPtr + 9);
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_14:
            beep(784, 15);
            beep(0, 15);
          }
        }
      }
      if ( v1 != 9 && v1 != 23 )
        break;
      v3 = *(_BYTE *)(usedModelPtr + 9);
      if ( v3 < 5 )
      {
        *(_BYTE *)(usedModelPtr + 9) = v3 + 1;
        if ( (unsigned int)sub_9BC0() >= 2 )
          goto LABEL_14;
      }
    }
    if ( v1 == 10 || v1 == 25 )
      break;
    if ( v1 == 11 )
      return 0;
  }
  memcpy((_BYTE *)(usedModelPtr + 62), 0xD1B7, 0xCu);
  return 1;
}
// BAF4: too many cbuild loops
// 8: using guessed type int NMI;
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// 2000002C: using guessed type int usedModelPtr;
// 200002AD: using guessed type char currentModel;

//----- (0000BC38) --------------------------------------------------------
signed int vTailPage()
{
  int v0; // r0@3
  unsigned int v1; // r5@7
  _BYTE *v2; // r0@9
  int v3; // r1@12
  const char *v4; // r0@12
  int v5; // r0@14
  signed int v7; // r1@25
  signed int v8; // r0@31
  signed int v9; // r0@36
  signed int v10; // r0@41

  if ( !(*(_BYTE *)(usedModelPtr + 55) & 4) )
  {
    v1 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("V tail");
        displayTextAt("V tail", 28, 16, 0);
        v2 = (_BYTE *)(*(_BYTE *)(usedModelPtr + 55) & 2 ? 51831 : "Off");
        displayTextAt(v2, 92, 16, 0);
        displayTextAt(&unk_BE78, 28, 24, 0);
        intToString(*(_BYTE *)(usedModelPtr + 75), a100_1, 4u);
        displayTextAt(a100_1, 60, 24, 0);
        displayTextAt(&unk_BE80, 28, 32, 0);
        intToString(*(_BYTE *)(usedModelPtr + 74), a100_1, 4u);
        displayTextAt(a100_1, 60, 32, 0);
        displayGFX((int)&arrow_gfx, 20, 8 * v1 + 16);
        if ( *(_BYTE *)(usedModelPtr + 55) & 2 )
        {
          displayTextAt("CH2 <= CH2-CH4", 8, 48, 0);
          v3 = 8;
          v4 = "CH4 <= CH2+CH4";
        }
        else
        {
          displayTextAt("CH2 <= CH2", 24, 48, 0);
          v3 = 24;
          v4 = "CH4 <= CH4";
        }
        displayTextAt(v4, v3, 56, 0);
        LCD_updateCALL();
        v5 = getKeyCode();
        if ( v5 != 8 && v5 != 24 )
          break;
        if ( v1 )
        {
          if ( v1 == 1 )
          {
            v8 = *(_BYTE *)(usedModelPtr + 75);
            if ( v8 > -100 )
            {
              *(_BYTE *)(usedModelPtr + 75) = v8 - 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_30;
            }
          }
          else
          {
            v7 = *(_BYTE *)(usedModelPtr + 74);
            if ( v7 > -100 )
            {
              *(_BYTE *)(usedModelPtr + 74) = v7 - 1;
              if ( (unsigned int)sub_9BC0() >= 2 )
                goto LABEL_30;
            }
          }
        }
        else
        {
          *(_BYTE *)(usedModelPtr + 55) ^= 2u;
          if ( (unsigned int)sub_9BC0() >= 2 )
            goto LABEL_30;
        }
      }
      switch ( v5 )
      {
        case 9:
        case 23:
          if ( v1 )
          {
            if ( v1 == 1 )
            {
              v10 = *(_BYTE *)(usedModelPtr + 75);
              if ( v10 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 75) = v10 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_30;
              }
            }
            else
            {
              v9 = *(_BYTE *)(usedModelPtr + 74);
              if ( v9 < 100 )
              {
                *(_BYTE *)(usedModelPtr + 74) = v9 + 1;
                if ( (unsigned int)sub_9BC0() >= 2 )
                  goto LABEL_30;
              }
            }
          }
          else
          {
            *(_BYTE *)(usedModelPtr + 55) ^= 2u;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_30;
          }
          break;
        case 22:
          if ( v1 == 1 )
          {
            *(_BYTE *)(usedModelPtr + 75) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_30;
          }
          else if ( v1 == 2 )
          {
            *(_BYTE *)(usedModelPtr + 74) = 50;
            if ( (unsigned int)sub_9BC0() >= 2 )
              goto LABEL_30;
          }
          break;
        case 10:
          if ( v1 < 2 )
            ++v1;
          else
            v1 = 0;
          if ( (unsigned int)sub_9BC0() >= 2 )
          {
LABEL_30:
            beep(784, 15);
            beep(0, 15);
          }
          break;
        default:
          if ( v5 == 25 )
            return 1;
          if ( v5 == 11 )
            return 0;
          break;
      }
    }
  }
  callSetupDMAandSend();
  displayPageHeader("V tail");
  displayTextAt2("Elevon enabled", 64, 32, 0);
  LCD_updateCALL();
  do
    v0 = getKeyCode();
  while ( v0 != 10 && v0 != 25 && v0 != 11 );
  return 0;
}
// 2000002C: using guessed type int usedModelPtr;

//----- (0000BFF0) --------------------------------------------------------
int __fastcall copy6Bytes(int result, int a2)
{
  *(_BYTE *)result = *(_BYTE *)a2;
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 3) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(result + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(result + 5) = *(_BYTE *)(a2 + 5);
  return result;
}

//----- (0000C00A) --------------------------------------------------------
bool __fastcall isASCICodeSingleDigit(int a1)
{
  return (unsigned int)(a1 - 48) < 0xA;
}

//----- (0000C018) --------------------------------------------------------
void __noreturn main_screen()
{
  unsigned int v0; // r7@0
  unsigned int v1; // r6@1
  unsigned int v2; // r4@6
  char *v3; // r0@30
  char *v4; // r5@31
  char v5; // r0@33
  char v6; // r1@33
  char v7; // ST00_1@33
  unsigned int v8; // r0@33
  char v9; // r1@33
  unsigned int v10; // r1@35
  int v11; // r0@41
  int v12; // r2@43
  int v13; // ST0C_4@50
  int v14; // ST0C_4@50
  int v15; // ST0C_4@50
  int v16; // r7@50
  unsigned int v17; // r7@50
  int v18; // [sp+0h] [bp-10h]@31
  unsigned int v19; // [sp+4h] [bp-Ch]@6
  unsigned int v20; // [sp+8h] [bp-8h]@6

  dword_20000018 = 0;
  dword_20000040 = 0;
  dword_20000020 = 0;
  dword_2000001C = -1000;
  kindOfInit();
  kindOfInit2();
  stickAdjustData[19] = (unsigned int)dword_2710;
  v1 = 0;
  voltageADC = 12000;
  do
  {
    if ( readEeprom((int)stickAdjustData, (_WORD)v1 << 12, 42)
      && crcCheck((_BYTE *)stickAdjustData, 40) == (unsigned __int16)CRC_STICKDATA )
    {
      goto LABEL_6;
    }
    someSPImethod();
    ++v1;
  }
  while ( v1 < 4 );
  memcpy((_BYTE *)stickAdjustData, 0xD20B, 0x2Au);
LABEL_6:
  loadTimerSettingsFromEeprom();
  LCD_clear();
  byte_20000160 = byte_200002AB;
  studentMode = 0;
  byte_20000002 = 1;
  v2 = 0;
  byte_20000145[0] = 0;
  v20 = timer;
  v19 = ((((v0 >> 8 << 8) | *(_BYTE *)(usedModelPtr + 10)) & 0xFFFF00FF | (*(_BYTE *)(usedModelPtr + 11) << 8) & 0xFF00) & 0xFF00FFFF | (*(_BYTE *)(usedModelPtr + 12) << 16) & 0xFF0000) & 0xFFFFFF | (*(_BYTE *)(usedModelPtr + 13) << 24);
  calibrateADC();
  configurePINS();
  setLCDBrightnes((unsigned __int8)lcdBrightnes);
  buzzerSetup();
  startupWarning();
  setupPortsC4_c5_c6_spi_DMA2_DMA3();
  configurePINandTimers();
  if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
    afhd2Init();
  tpmMethod();
  sendPacketWithTimer();
  beep(523, 50);
  beep(659, 50);
  beep(784, 50);
  beep(1047, 50);
  if ( (stickModeSW == 1 || stickModeSW == 3)
    && ch1_ADC_VAL < 1024u
    && (unsigned int)ch2_ADC_VAL < 1024
    && (unsigned int)ch3_ADC_VAL < 1024
    && (unsigned int)ch4_ADC_VAL < 1024
    || (!stickModeSW || stickModeSW == 2)
    && ch1_ADC_VAL > (unsigned int)&byte_BB8
    && ch2_ADC_VAL > (unsigned int)&byte_BB8
    && ch3_ADC_VAL > (unsigned int)&byte_BB8
    && ch4_ADC_VAL > (unsigned int)&byte_BB8 )
  {
    factoryMode = 1;
    tpmMethod();
    while ( 1 )
      factoryModeMenu(off_CC40, 0xBu, &off_D248);
  }
  factoryMode = 0;
  if ( sub_2574() != 255 && getKeyCode() == 12 )
  {
    rxBindingPage();
    saveModelSettings();
  }
  dword_1FFFF8A8 = 0;
  dword_1FFFF8AC = 0;
  while ( 1 )
  {
    callSetupDMAandSend();
    if ( rxsettings[146 * (unsigned __int8)currentModel + 106] )
      break;
    displayGFX((int)afhd_logo, 7, 0);
    printNumberAsStringAt((unsigned __int8)currentModel + 1, &aModel00[6], 2u);
    displayTextAt(aModel00, 8, 40, 0);
    displayTextAt((_BYTE *)usedModelPtr, 8, 48, 0);
    if ( *(_BYTE *)(usedModelPtr + 9) )
      v3 = &heli_img;
    else
      v3 = &plain_img;
    displayGFX((int)v3, 68, 24);
    v4 = (char *)div__0(voltageADC * (_DWORD)dword_2710, (unsigned __int16)stickAdjustData[19]);
    v18 = div__0((int)v4, 10);
    if ( !v2 || timer - v2 >= 0x7D0 )
    {
      div_Other(v18, 100u);
      voltage[0] = v5 + 48;
      div_Other(v18, 10u);
      v7 = v6;
      div_Other(v8, 0xAu);
      voltage[2] = v9 + 48;
      voltage[3] = v7 + 48;
      v2 = timer;
    }
    if ( v4 >= &byte_DA0[712] || (div_Other(timer, 0x7D0u), v10 < 0x3E8) )
    {
      if ( (unsigned int)v4 >= 4000 )
      {
        if ( v4 > &byte_1426[842] )
          v4 = &byte_1426[842];
      }
      else
      {
        v4 = byte_DA0 + 512;
      }
      displayTextAt(voltage, 80, 12, 0);
      displayGFX((int)&unk_CBA4, 86, 0);
      div_Other(23 * (_DWORD)(v4 - 4000), 0x7D0u);
      fillRegion(87, 1, v11 + 87, 8, 2);
    }
    if ( timer - v20 >= (unsigned int)&byte_BB8 )
    {
      v12 = *(_BYTE *)(usedModelPtr + 10);
      if ( v12 != (char)v19
        || *(_BYTE *)(usedModelPtr + 11) != (signed int)(v19 << 16) >> 24
        || *(_BYTE *)(usedModelPtr + 12) != (signed int)(v19 << 8) >> 24
        || *(_BYTE *)(usedModelPtr + 13) != (signed int)v19 >> 24 )
      {
        v20 = timer;
        v19 = ((((v19 >> 8 << 8) | (unsigned __int8)v12) & 0xFFFF00FF | (*(_BYTE *)(usedModelPtr + 11) << 8) & 0xFF00) & 0xFF00FFFF | (*(_BYTE *)(usedModelPtr + 12) << 16) & 0xFF0000) & 0xFFFFFF | (*(_BYTE *)(usedModelPtr + 13) << 24);
        saveModelSettings();
      }
    }
    if ( studentMode )
    {
      displayTextAt(&unk_C954, 77, 44, 0);
      drawLine(76, 42, 85, 52, 0);
    }
    v13 = div__0(46 * (*(_BYTE *)(usedModelPtr + 12) + 120), 240);
    drawLine(0, 8, 3, 56, 0);
    fillRegion(1, 9, 2, 55, 1);
    sub_4E8C(1, 32, 2, 32, 0);
    sub_4E8C(1, 55 - v13, 2, 55 - v13, 0);
    v14 = div__0(46 * (*(_BYTE *)(usedModelPtr + 13) + 120), 240);
    drawLine(7, 60, 55, 63, 0);
    fillRegion(8, 61, 54, 62, 1);
    sub_4E8C(31, 61, 31, 62, 0);
    sub_4E8C(v14 + 8, 61, v14 + 8, 62, 0);
    v15 = div__0(46 * (*(_BYTE *)(usedModelPtr + 10) + 120), 240);
    drawLine(72, 60, 120, 63, 0);
    fillRegion(73, 61, 119, 62, 1);
    sub_4E8C(96, 61, 96, 62, 0);
    sub_4E8C(v15 + 73, 61, v15 + 73, 62, 0);
    v16 = div__0(46 * (*(_BYTE *)(usedModelPtr + 11) + 120), 240);
    drawLine(124, 8, 127, 56, 0);
    fillRegion(125, 9, 126, 55, 1);
    sub_4E8C(125, 32, 126, 32, 0);
    sub_4E8C(125, 55 - v16, 126, 55 - v16, 0);
    LCD_updateCALL();
    v17 = timer;
    while ( timer - v17 < 100 )
    {
      if ( byte_20000000 )
      {
        byte_20000000 = 0;
        saveModelSettings();
      }
      if ( sub_2574() != 255 && getKeyCode() == 22 )
      {
        beep(523, 75);
        beep(784, 75);
        sub_68A8();
      }
    }
  }
  printTimer();
  JUMPOUT(unk_C1FA);
}
// 4: using guessed type int Reset;
// 8: using guessed type int NMI;
// BB8: using guessed type char byte_BB8;
// 2710: using guessed type int dword_2710[28];
// CB74: using guessed type int afhd_logo[2];
// CB8C: using guessed type char heli_img;
// CB98: using guessed type char plain_img;
// CC40: using guessed type int *off_CC40[2];
// D248: using guessed type char *off_D248;
// 1FFFF8A8: using guessed type int dword_1FFFF8A8;
// 1FFFF8AC: using guessed type int dword_1FFFF8AC;
// 20000000: using guessed type char byte_20000000;
// 20000001: using guessed type char factoryMode;
// 20000002: using guessed type char byte_20000002;
// 20000018: using guessed type int dword_20000018;
// 2000001C: using guessed type int dword_2000001C;
// 20000020: using guessed type int dword_20000020;
// 2000002C: using guessed type int usedModelPtr;
// 20000040: using guessed type int dword_20000040;
// 20000144: using guessed type char studentMode;
// 20000160: using guessed type char byte_20000160;
// 200002AA: using guessed type char stickModeSW;
// 200002AB: using guessed type char byte_200002AB;
// 200002AC: using guessed type char lcdBrightnes;
// 200002AD: using guessed type char currentModel;
// 20000E40: using guessed type __int16 CRC_STICKDATA;
// 20000F04: using guessed type int ch2_ADC_VAL;
// 20000F08: using guessed type int ch3_ADC_VAL;
// 20000F0C: using guessed type int ch4_ADC_VAL;
// 20000F18: using guessed type int voltageADC;

//----- (0000F020) --------------------------------------------------------
int __fastcall RemapSensorIndex(signed int a1, int a2)
{
  if ( a1 >= 0 && a1 <= 255 )
  {
    if ( a1 == 65 )
      a1 = 15;
    if ( a1 <= 15 )
      return a2 + 8 * a1;
    if ( a1 >= 124 )
    {
      if ( a1 <= 127 )
      {
        a1 -= 124;
        a2 += 128;
        return a2 + 8 * a1;
      }
      if ( a1 <= 137 )
        return a2 + 160 + 4 * (a1 - 128);
      if ( a1 >= 249 )
      {
        a1 -= 249;
        a2 += 200;
        return a2 + 8 * a1;
      }
    }
  }
  return a2 + 224;
}

//----- (0000F4D0) --------------------------------------------------------
signed int __fastcall auxChannelsPage(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  unsigned int v5; // r0@1
  unsigned int v6; // r0@1
  unsigned int channel; // r6@2
  int *channelNamePTR; // r5@2
  char *channelAssigmentString; // r0@6
  int currentChVal; // r0@10
  int key; // r0@14
  unsigned int v13; // r0@26
  int v14; // r0@28
  int settingsPtr; // r3@30
  int ch5BytePtr; // [sp+0h] [bp-30h]@1
  int v17; // [sp+4h] [bp-2Ch]@1
  unsigned int v18; // [sp+8h] [bp-28h]@1
  unsigned int v19; // [sp+Ch] [bp-24h]@1
  unsigned int v20; // [sp+10h] [bp-20h]@1
  unsigned int v21; // [sp+14h] [bp-1Ch]@1
  int v22; // [sp+18h] [bp-18h]@1

  v22 = a4;
  v4 = 0;
  ch5BytePtr = *(_BYTE *)(usedModelPtr + 60);
  v17 = *(_BYTE *)(usedModelPtr + 61);
  v5 = *(_BYTE *)(usedModelPtr + 141);
  v18 = v5 & 0xF;
  v19 = v5 >> 4;
  v6 = *(_BYTE *)(usedModelPtr + 145);
  v20 = v6 & 0xF;
  v21 = v6 >> 4;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        while ( 2 )
        {
          callSetupDMAandSend();
          displayPageHeader("Aux. channels");
          channel = 0;
          channelNamePTR = &ch5PTr;
          do
          {
            displayTextAt((_BYTE *)*channelNamePTR, 8, 8 * channel + 12, 0);
            if ( channel )
            {
              if ( channel == 1 && (unsigned int)*(_BYTE *)(usedModelPtr + 9) >= 2 )
              {
                channelAssigmentString = "Used";
                goto LABEL_13;
              }
            }
            else if ( *(_BYTE *)(usedModelPtr + 9) && *(_BYTE *)(usedModelPtr + 55) & 8 )
            {
              channelAssigmentString = "Used";
              goto LABEL_13;
            }
            currentChVal = *(&ch5BytePtr + channel);
            if ( currentChVal < 7 )
              channelAssigmentString = (char *)dword_200000B8[currentChVal];
            else
              channelAssigmentString = &aSwaB[6 * (currentChVal - 7)];
LABEL_13:
            displayTextAt(channelAssigmentString, 88, 8 * channel++ + 12, 0);
            ++channelNamePTR;
          }
          while ( channel < 6 );
          displayGFX((int)&arrow_gfx, 0, 8 * v4 + 12);
          LCD_updateCALL();
          key = getKeyCode();
          if ( key == 8 || key == 24 )
          {
            v14 = *(&ch5BytePtr + v4);
            if ( !v14 )
              continue;
            *(&ch5BytePtr + v4) = v14 - 1;
            goto LABEL_24;
          }
          break;
        }
        if ( key == 9 || key == 23 )
        {
          v13 = *(&ch5BytePtr + v4);
          if ( v13 >= 0xB )
            continue;
          *(&ch5BytePtr + v4) = v13 + 1;
          goto LABEL_24;
        }
        break;
      }
      if ( key == 10 )
      {
        if ( ++v4 == 6 )
          v4 = 0;
LABEL_24:
        if ( (unsigned int)sub_9BC0() >= 2 )
        {
          beep(784, 15);
          beep(0, 15);
        }
        continue;
      }
      break;
    }
    if ( key != 25 )
    {
      if ( key == 11 )
        return 0;
      continue;
    }
    break;
  }
  settingsPtr = usedModelPtr + 60;
  *(_BYTE *)settingsPtr = ch5BytePtr;           //  model +60 ch??
  *(_BYTE *)(settingsPtr + 1) = v17;            // model +61 ch ??
  settingsPtr += 81;
  *(_BYTE *)settingsPtr = 16 * v19 | v18;       // model +141
  *(_BYTE *)(settingsPtr + 4) = 16 * v21 | v20; // model +145
  return 1;
}
// F630: using guessed type int ch5PTr;
// 2000002C: using guessed type int usedModelPtr;

//----- (0000F66C) --------------------------------------------------------
void __fastcall createPacketsForCH7_10(unsigned int switch_1)
{
  JUMPOUT(&loc_F758);
}

//----- (0000F6F0) --------------------------------------------------------
int *__fastcall channelDataHelper(int a1)
{
  int *result; // r0@2

  if ( (1 << (a1 + 16)) & inputStates )
  {
    result = dword_2710;
  }
  else if ( a1 != 2 || inputStates & 0x100000 )
  {
    result = (int *)-10000;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 2710: using guessed type int dword_2710[28];
// 1FFFF89C: using guessed type int inputStates;

//----- (0000F72C) --------------------------------------------------------
void loadTimerSettingsFromEeprom()
{
  settingsValidation();
  readEeprom((int)&sensorsArrayInRam[214], 48, 4);
}
/* Orphan comments:
// if key equalas 11 -> cancall presses
*/

//----- (0000F81C) --------------------------------------------------------
void printTimer()
{
  signed int v0; // r4@1
  int v1; // r5@3
  char v2; // r2@11
  char v3; // r3@11
  int i; // r4@11
  char *v5; // r0@17

  v0 = vE000E018;
  if ( *(_DWORD *)&sensorsArrayInRam[208] )
  {
    if ( vE000E018 > *(_DWORD *)&sensorsArrayInRam[208] )
      v1 = 0xFFFFFF - vE000E018 + *(_DWORD *)&sensorsArrayInRam[208];
    else
      v1 = *(_DWORD *)&sensorsArrayInRam[208] - vE000E018;
    if ( v1 < 2999111 )
      goto LABEL_18;
    *(_DWORD *)&sensorsArrayInRam[208] = v1 - 2999111 + vE000E018;
    ++*(_WORD *)&sensorsArrayInRam[212];
LABEL_11:
    v2 = 0;
    v3 = 0;
    for ( i = *(unsigned __int16 *)&sensorsArrayInRam[212]; i >= 3600; i -= 3600 )
      ++v2;
    while ( i >= 60 )
    {
      ++v3;
      i -= 60;
    }
    sprintf((int)&sensorsArrayInRam[218], "%u:%02u:%02u", v3 & 0x3F, i & 0x3F);
LABEL_18:
    v5 = &sensorsArrayInRam[218];
    goto LABEL_19;
  }
  if ( isTimerActive() )
  {
    if ( v0 <= 2999111 )
      v0 += 0xFFFFFF;
    *(_DWORD *)&sensorsArrayInRam[208] = v0;
    goto LABEL_11;
  }
  v5 = (_BYTE *)(&off_F9F4 + 1);
LABEL_19:
  displaySmallTextAt(v5, 1, 2);
}
// F9F4: using guessed type void *off_F9F4;

//----- (0000F8F6) --------------------------------------------------------
int timerConfiguration()
{
  int v0; // r4@1
  int v1; // r5@1
  int v2; // r3@2
  signed int v3; // r7@2
  int v4; // r3@7
  int result; // r0@9

  v0 = *(unsigned __int16 *)&sensorsArrayInRam[216];
  v1 = sensorsArrayInRam[214] & 0xF;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        callSetupDMAandSend();
        displayPageHeader("Timer");
        v3 = 0;
        if ( v0 == 0xFFFF || v0 < 1000 || v0 > 2000 || v1 <= 0 || v1 > 10 )
        {
          v3 = 1;
          displayTextAt("Off", 10, 30, v2);
        }
        else
        {
          displayTextAt("Start when:", 10, 15, v2);
          sprintf((int)&sensorsArrayInRam[220], (_BYTE *)&dword_F9FC + 2, v0);
          displayTextAt(&sensorsArrayInRam[220], 10, 30, v4);
        }
        LCD_updateCALL();
        result = getKeyCode();
        if ( result != 9 && result != 23 )
          break;
        ++v1;
        if ( v3 == 1 )
        {
LABEL_30:
          v1 = 3;
          v0 = 1000;
        }
        else if ( v1 > 10 )
        {
          v1 = 1;
        }
      }
      if ( result == 8 )
      {
        v0 += 10;
        goto LABEL_24;
      }
      if ( result != 24 )
        break;
      v0 += 100;
LABEL_24:
      if ( v3 == 1 )
        goto LABEL_30;
      if ( v0 > 2000 )
        v0 = 0xFFFF;
    }
    if ( result == 10 || result == 11 )
      return result;
    if ( result == 22 )
    {
      result = 0;
      *(_DWORD *)&sensorsArrayInRam[208] = 0;
      *(_WORD *)&sensorsArrayInRam[212] = 0;
      return result;
    }
  }
  while ( result != 25 );
  if ( v3 == 1 )
  {
    LOWORD(v1) = 3;
    LOWORD(v0) = -1;
  }
  *(_WORD *)&sensorsArrayInRam[214] = v1;
  *(_WORD *)&sensorsArrayInRam[216] = v0;
  return ((int (*)(void))loc_F740)();
}
// F9FC: using guessed type int dword_F9FC;

//----- (0000FB5C) --------------------------------------------------------
void __fastcall GetSensorName(signed int a1)
{
  RemapSensorIndex(a1, (int)"IntV");
}

//----- (0000FB6C) --------------------------------------------------------
int __fastcall formatSensorValue(int a1, signed int a2, signed int a3)
{
  signed int v3; // r4@0
  _BYTE *v4; // r7@1
  int v5; // r3@1
  unsigned int v6; // r0@33
  int v7; // r1@35
  const char *v8; // r1@20

  v4 = (_BYTE *)a1;
  v5 = 0;
  if ( a2 == 4 )
    goto LABEL_24;
  if ( a2 == 5 )
    goto LABEL_42;
  if ( a2 == 6 )
  {
LABEL_25:
    v3 = 64610;
LABEL_33:
    v6 = (signed __int16)a3;
    if ( (signed __int16)a3 < 0 )
    {
      v6 = (signed __int16)-(signed __int16)a3;
      *v4++ = 45;
    }
    div_(v6, 0x64u);
    v5 = v7;
    v8 = (const char *)v3;
    a1 = (int)v4;
    return sprintf(a1, v8, v5);
  }
  if ( a2 == 7 || a2 == 8 || a2 == 9 )
  {
LABEL_42:
    v3 = 64583;
    goto LABEL_33;
  }
  if ( a2 == 10 || a2 == 11 )
    goto LABEL_25;
  if ( a2 == 12 )
  {
    v8 = "%um";
    return sprintf(a1, v8, v5);
  }
  if ( a2 != 13 )
  {
    if ( a2 == 14 )
    {
      v8 = "Unknown";
      if ( a3 > 9 )
        return sprintf(a1, v8, v5);
      a3 *= 8;
      v8 = (const char *)(a3 + 64659);
      if ( !((unsigned __int8)((a3 + 64659 < 0) ^ __OFADD__(a3, 64659)) | (a3 == -64659)) )
        return sprintf(a1, v8, v5);
      goto LABEL_33;
    }
    if ( a2 == 15 )
      goto LABEL_38;
    if ( a2 != 128 )
    {
      if ( a2 == 129 )
      {
        v8 = "%u %02u";
        v5 = (unsigned __int16)a3 >> 8;
        return sprintf(a1, v8, v5);
      }
      if ( a2 != 132 && a2 != 249 )
      {
        if ( a2 == 253 )
        {
          v8 = "NOT IMPL";
          return sprintf(a1, v8, v5);
        }
        if ( a2 == 250 )
        {
          v8 = "%udB";
          return sprintf(a1, v8, v5);
        }
        if ( a2 > 250 )
        {
          v8 = "-%udBm";
          return sprintf(a1, v8, v5);
        }
LABEL_38:
        v8 = "%u";
        return sprintf(a1, v8, v5);
      }
      v3 = 64594;
      goto LABEL_33;
    }
LABEL_24:
    v8 = "%u.%02u";
    return sprintf(a1, v8, v5);
  }
  v8 = "Unarmed";
  if ( a3 )
    v8 = "Armed";
  return sprintf(a1, v8, v5);
}

#error "There were 2 decompilation failure(s) on 210 function(s)"
